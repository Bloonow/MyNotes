# 特殊矩阵的数据结构

## 稀疏矩阵存储格式

稀疏矩阵常用的存储格式有COO（coordinate，坐标格式）、CSR（compressed sparse row，压缩稀疏行）、（compressed sparse column，压缩稀疏列）三种。

COO格式是将矩阵中的非零元素以坐标的方式存储，这种存储格式比较简单，每一个非零元素用一个三元组（行号,列号,数值）来表示，即(row_idx,col_idx,val)，如下图所示。

<img src="数据结构与算法.assets/COO.png" style="zoom: 67%;" />

- row_indices：values数组中对应元素的行索引。
- column_indices：values数组中对应元素的列索引。
- values：矩阵中的非零元素的数值。

CSR格式是将矩阵元素按行顺序存储，如下图所示。

<img src="数据结构与算法.assets/CSR.png" style="zoom:67%;" />

- row_offsets：行偏移量。若矩阵有m行，则数组有m+1个元素。数组的idx索引上的元素代表的是矩阵行索引为idx的行的信息，它表示矩阵idx行之前（不含）所有非零元素的个数，最后一个值就可表示矩阵所有非零元素的个数。显然idx+1行的值减去idx行的值，得到的即是idx行非零元素的个数。如果idx行的非零元素个数不为0（即该行有非零元素），则row_offsets[idx]的值就是，该idx行的其他信息在column_indices数组和values数组中的索引（偏移）。如果计算得到idx行的非零元素个数为0（全是零元素），则跳过该行。

- column_indices：对于某一行来说，非零元素的列索引（从左到右）。
- values：矩阵中的非零元素的数值。

CSC格式是将矩阵元素按列顺序存储，如下图所示。

<img src="数据结构与算法.assets/CSC.png" style="zoom:67%;" />

- column_offsets：列偏移量。若矩阵有n列，则数组有n+1个元素。数组的idx索引上的元素代表的是矩阵列索引为idx的列的信息，它表示矩阵idx列之前（不含）所有非零元素的个数，最后一个值就可表示矩阵所有非零元素的个数。显然idx+1列的值减去idx列的值，得到的即是idx列非零元素的个数。如果idx列的非零元素个数不为0（即该列有非零元素），则column_offsets[idx]的值就是，该idx列的其他信息在row_indices数组和values数组中的索引（偏移）。如果计算得到idx列的非零元素个数为0（全是零元素），则跳过该列。
- row_indices：对于某一列来说，非零元素的行索引（从上到下）。
- values：矩阵中的非零元素的数值。

CSC与CSR类似，只不过其存储遍历方向正好一个按行一个按列。

## 带状矩阵及其存储

当稀疏矩阵的非零元素都集中在以主对角线为中心的带状区域时，称为带状矩阵（Band Matrix）。假设一个M行N列的带状矩阵，其上带宽的对角线条数为U，下带宽的对角线条数为L，则其示意图如下所示。

<img src="数据结构与算法.assets/Band Matrix.png" style="zoom:50%;" />

带状矩阵在计算机中的存储时，将一条对角线组织为一行元素，两端不足的位置使用无意义的值进行补齐，如上图所示。可以看到，带状矩阵实际上存储(U+L+1)\*N个元素，并存在一些无效的占位元素，可以按行主序存储或列主序存储。元素的逻辑位置为A[i,j]时，则该元素在内存中的存储到Storage[i-j+U+1,j]位置。

# 二叉树的非递归遍历

## 判断节点是第几次遍历

在二叉树遍历的非递归实现中，关键之处在于，判断一个节点是被第几次遍历，从而执行相应的访问操作。从原理上分析，一个BTNode节点同时具有value数据、left左孩子、right右孩子，而在递归过程中，总是首先要遍历到一个BTNode节点，于是根据前序遍历（this>left>right）、中序遍历（left>this>right）、后序遍历（left>right>this）的不同顺序要求，可以知道需要在第几次遍历到某个节点时执行访问操作。前序遍历，在第一次遍历到某个节点时，即需要执行访问操作；中序遍历，在第二次遍历到某个节点时，即需要执行访问操作；后续遍历，在第三次遍历到某个节点时，即需要执行访问操作。

为追求极致化的时间复杂度和空间复杂度，前序遍历、中序遍历、后序遍历的非递归实现，往往会巧妙设计各种变量的重复使用、入栈出栈的不同时机，来判断是第几次遍历到某个节点。这种算法的设计较难理解，而直接明确存储某个节点是第几次访问，更容易理解和编程实现。对每个节点而言，需要额外的一个整数的空间，额外的两次入栈出栈操作。

```c++
void Traversal(BTNode *bt) {
    const int FIRST = 1, SECOND = 2, THIRD = 3;
    stack<pair<BTNode*, int>> stack;
    stack.push({ bt, FIRST });
    while (!stack.empty()) {
        auto frame = stack.top(); stack.pop();
        BTNode *node = frame.first;
        int count = frame.second;
        if (node == nullptr) continue;  // do nothing
        switch (count) {
        case FIRST:
            // 第一次遍历到该节点，刚从父节点指过来；若是前序遍历，则在此处执行访问操作
            stack.push({ node, SECOND });       // 第一次遍历结束，入栈以被第二次遍历
            stack.push({ node->left, FIRST });  // 左孩子入栈，以确保下个节点遍历其左孩子
            break;
        case SECOND:
            // 第二次遍历到该节点，刚从左孩子返回来；若是中序遍历，则在此处执行访问操作
            stack.push({ node, THIRD });         // 第二次遍历结束，入栈以被第三次遍历
            stack.push({ node->right, FIRST });  // 右孩子入栈，以确保下个节点遍历其右孩子
            break;
        case THIRD:
        default:
            // 第三次遍历到该节点，刚从右孩子返回来；若是后序遍历，则在此处执行访问操作
            // 第三次遍历结束，左右孩子、当前节点均被遍历完成，无需任何操作
            break;
        }
    }
}
```

针对上述过程，若精心设计入栈出栈的不同时机、变量的复用，即可避免使用额外的内存空间与额外的入栈出栈操作，从而得到极致化的非递归实现。

## 根据栈帧的先后顺序

在二叉树遍历的非递归实现中，关键之处在于，栈帧的先后顺序，决定前序遍历（this>left>right）、中序遍历（left>this>right）、后序遍历（left>right>this）的不同顺序。从原理上分析，从原理上分析，一个BTNode节点同时具有value数据、left左孩子、right右孩子，而在递归过程中，总是首先要遍历到一个BTNode节点，于是，总在栈的迭代循环的一开始，就从栈顶弹出一个栈帧，表示首先遍历到一个BTNode节点，此时不执行访问操作，而是为其设置一个已遍历到的标识，用于在下次遍历到的时候执行访问操作。

根据栈帧的先后顺序，并根据前序遍历（this>left>right）、中序遍历（left>this>right）、后序遍历（left>right>this）的不同顺序要求，再次将当前节点、左孩子、有孩子入栈，并在出栈时完成对具有标识节点的访问操作。前序遍历，当前节点应处于栈顶，故按照right>left>this的顺序入栈；中序遍历，当前节点的栈帧应处于左孩子和右孩子之间，故按照right>this>left的顺序入栈；后续遍历，当前节点的栈帧应该处于左孩子和右孩子之后，故按照this>right>left的顺序入栈。

```c++
void Traversal(BTNode *bt) {
    const int FIRST = 1, SECOND = 2;
    stack<pair<BTNode*, int>> stack;
    stack.push({ bt, FIRST });
    while (!stack.empty()) {
        auto frame = stack.top(); stack.pop();
        BTNode *node = frame.first;
        int count = frame.second;
        if (node == nullptr) continue;  // do nothing
        if (count == FIRST) {
            // 按照前序遍历、中序遍历、后序遍历的顺序要求，以相反的顺序入栈
            // 此处以中序遍历为示例
            stack.push({ node->right, FIRST });
            stack.push({ node, SECOND });
            stack.push({ node->left, FIRST });
        } else {
            // count == SECOND
            // 在此处执行访问操作
        }
    }
}
```

针对上述过程，若精心设计入栈出栈的不同时机、变量的复用，即可避免使用额外的内存空间与额外的入栈出栈操作，从而得到极致化的非递归实现。

# 算法设计思想与策略

互有交集，但又互不相同

暴力枚举，

分而治之，常基于递归实现，（分治与递归的区别），

回溯法，常基于深度优先搜索，（回溯与深度优先搜索的区别），

分支界限法，广度优先遍历

贪心算法，

动态规划，

一些典型应用：查找、排序、

---

递归（recursion）作为求解问题的一种策略，其核心思想即是对问题的分解与细化，根据某种规则，将规模较大的问题划分成若干个小的问题，通过解决较小的问题，来依次构造较大问题的解决方案。递归从最大的问题规模开始，逐步递归划分，直至最小的可以直接求解的问题规模，该过程会形成一个树状的递归空间。

在数学上，递归问题的两个基本条件是终止条件与递归公式。终止条件是最小规模的问题，决定递归在什么时间停止，对应着最小规模问题的解；递归公式是分解细化的策略，决定递归以何种方式进行，问题规模缩小以进入子递归，结束子递归后以构造更大规模的解决方案。

深度优先搜索（depth first search）是递归思想的一种典型应用，其目的是对递归的树状空间进行遍历，并执行可选的相关操作。

回溯法（back tracking method）是递归思想的另一种典型应用，但与深度优先搜索存在一些不同之处。深度优先搜索更倾向于对递归树空间进行遍历，并不修改树空间的结构。而回溯法则会在递归过程中，对递归树空间的结构进行相应的修改，以构造全局问题所需要的某个条件下的解，然后进入子递归；直到到达最深层的状态，满足全局问题的解的条件，于是记录该解，然后逐层退出递归；并在退出某一次子递归之后，恢复对递归树空间结构进行的修改，以进行另外的修改与递归，探索另外的解。

# 算法设计与分析

在计算机科学中，算法（Algorithm）是指解决问题的一种方法或一个过程，是由若干条指令组成的有穷序列，接受零个或多个输入，产生至少一个输出，指令序列具有确定性且无歧义，并且算法中的指令次数和时间是有限的。

在计算机算法理论中，最深刻的问题之一是，从计算的观点来看，要解决问题的内在复杂性如何，它是“易”计算的还是“难”计算的？人们通常将可在多项式时间内解决的问题看作“易”解问题，将需要指数函数时间解决的问题看作“难”问题。对于实际遇到的许多问题，人们至今无法确切了解其内在的计算复杂性，因此只能用分类的方法将计算复杂性大致相同的问题归类进行研究。

所有可以在多项式时间内求解的判定问题构成P类问题（Polynomial Problem，多项式问题），P类问题是确定性计算模型下的易解问题类，而NP类问题（Non-deterministic Polynomial Problem，非确定性多项式问题）是非确定性计算模型下的易验证问题类。非确定性算法将问题求解分为猜测和验证两个阶段；算法的猜测阶段是非确定性的，给出问题解的一个猜测；算法的验证阶段是确定性的，验证猜测阶段给出的解的正确性。

## 分治与递归

