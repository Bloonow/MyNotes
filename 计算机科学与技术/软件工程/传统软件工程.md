[toc]

# 软件生命周期与软件过程

## （一）软件生命周期

一个软件从开始立项起，到废弃不用止，统称为软件的生存周期（life cycle），一般被划分为计划、开发与运行3个时期。

软件生存周期的主要活动有：需求分析、软件分析、软件设计、编码、软件测试、运行维护。比较大型的软件在开始开发前，还需要进行一次可行性研究。

软件过程可理解为围绕软件开发所进行的一系列活动。

## （二）传统软件过程

### 1. 瀑布模型

瀑布开发模型是一种基于软件生存周期的线性开发模型，它与软件生存周期的特点是一致的。顺序性，只有等前一阶段的工作完成之后，后一阶段的工作才能开始。依赖性，前一阶段的输出文档是后一阶段的输入文档。

推迟实现的观点，所谓推迟实现，就是把待开发软件的逻辑设计与物理实现清楚地区别开来，即在需求分析和软件设计阶段只考虑系统的逻辑模型，等到编码阶段再来完成程序清单。保证质量的观点，每一阶段必须完成规定的文档；每一阶段都要对完成的文档进行复审。

存在的问题。只有当做出准确的需求分析时，才能够得到预期的结果。但遗憾是，未使用或接触过，想要对一个软件产品提出确切的需求，这几乎是不可能的。因此提出了”快速原型模式“。

### 2. 快速原型模型

先建立一个能够反映用户主要需求的原型，让用户实际看一下未来系统的概貌，以便判断哪些功能是符合需要的，哪些方面还需要改进。然后将原型反复改进，直至建立完全符合用户要求的新系统。

方法，原型系统只包括未来系统的主要功能及系统的重要接口，它不包括系统的细节，例如异常处理、对非有效输入的反应等，对系统的性能需求如硬件运行速度等也可推迟考虑。开发原型时应尽量使用能缩短开发周期的语言和工具。

## （三）软件演化模型

非线性的开发模型，复杂软件开始采用渐增式或迭代式的开发方法。演化模型（evolutionary model）遵循迭代的思想方法，使所开发的软件在迭代中逐步达到完善。常见的演化模型有增量模型与螺旋模型两种，一般适用于大型软件的开发。

### 1. 增量模型

增量模型（incremental model）是瀑布模型的顺序特征与快速原型法的迭代特征相结合的产物。把软件看作一系列相互联系的增量（increments），在开发过程的各次迭代中，每次完成其中的一个增量。其中任一个增量的开发流程均可按瀑布模型或快速原型法完成；一般情况下第一个增量通常是软件的核心部分。

### 2. 螺旋模型

螺旋模型（spiral model）是一种典型的迭代模型。每轮螺旋均包含计划、风险分析、建立原型、用户评审4种活动，周而复始，直到实现最终产品。

### 3. 构件集成模型

抛开在开发中具体使用的方法与工具，仅就开发活动的框架而言，上述各种软件开发模型对面向过程软件与面向对象软件的开发是同时适用的，面向对象开发模型均可借用面向过程开发模型的活动框架，不需要另起炉灶。而本节将要介绍的构件集成模型，则主要适用于面向对象的软件开发。

经过适当设计和实现的类，在某个领域中具有一定的通用性，可以在不同的计算机软件系统中复用，也可称为构件（component）。构件库为基于构件的软件开发模型提供了技术基础。

把相关的数据和方法封装成一个类，构件库如果存在就复用；如果不存在，则实现它并把它加到构件库中。即可得到待开发软件的第一个迭代，然后进入下一轮螺旋周期，继续进行构件集成的迭代。

## （四）形式化方法模型

软件开发方法可区分为形式化方法与非形式化方法两大分支。前者以形式化的程序变换技术为主要研究内容，多流行于学术界；后者旨在用工程方法生产出质量高、易维护的软件产品，多流行于工业界。

### 1. 转换模型

转换模型（transformational model）采用严格的数学方法来表示软件需求规格说明书，然后进行一系列自动或半自动的程序变换，最终将需求规格说明书转换为计算机系统能够接受的目标程序系统，并进行系统测试。

转换模型的常用技术实施转换模型的常用技术，目前主要有基于模型的需求规格说明书及其变换技术、基于代数结构的需求规格说明书及其变换技术、基于时序逻辑的需求规格说明书和验证技术以及基于可视形式化的技术等。但要得到一个形式化需求规格说明书，目前还有比较大的难度。

### 2. 净室模型

净室模型（cleanroom model）是一种形式化的增量开发模型。其基本思想是力求在分析和设计阶段就消除错误，确保正确，然后在无缺陷或洁净的状态下实现软件的制作。

净室开发把软件看成一系列的增量，每个增量是一个用形式化方式表示的盒（Box）。当需求收集结束后，就用盒结构来表示分析和设计模型，这种盒是在某个特定的抽象层次上对系统（或系统的某些方面）的一次封装。将形式化的盒结构设计转换为适当的程序设计语言表示的源代码，对增量进行集成。

## （五）统一过程和敏捷过程

### 1. 统一过程

统一过程描述了软件开发中各个环节应该做什么、怎么做、什么时候做以及为什么要做，描述了一组以某种顺序完成的活动，其结果是一组有关系统的文档，例如模型和其他一些描述，以及对最初问题的解决方案等。

统一过程在一个二维空间中描述软件开发活动，水平轴代表时间，将一个软件生存周期分为4个阶段（phase），即初始、细化、构造、迁移。每个阶段又可以分为一个或多个迭代（iteration），迭代是一个完整的开发循环，都会经历需求、分析、设计、实现等活动，它的结果是产品的一个可执行版本，是正在开发的最终产品的一个子集，从一个迭代到下一个迭代，不断递增成长，直到最后成为最终系统。

### 2. 敏捷过程

敏捷开发（agile development）是一种以人为核心、以迭代方式循序渐进开发的方法，其软件开发的过程称为敏捷过程。

在这一过程中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。简言之，就是把一个大项目分为多个相互联系但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可用状态。

还需指出，敏捷开发是一个持续地应用原则、模式以及实践来改进软件的结构和可读性的过程，而不是一个事件。它致力于保证系统设计在任何时间都尽可能简单、整洁及富有表现力。下面介绍的极限编程就是敏捷过程的一种方法。

### 3. 极限编程

极限编程（extreme programming，XP）建议采用循环迭代的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其他一系列的方法，使开发人员和客户都可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。

## （六）软件可行性研究

可行性研究（feasibility study）的目的，是弄清待开发的项目是不是可能实现和值得进行，通常由系统分析员完成，并需写出可行性论证报告。可行性论证其实是在高层次上进行的一次大大简化了的需求分析与设计，但它的目的不是去解决用户提出的问题，仅是确定这项开发是否值得进行，分析它存在哪些风险。

研究的内容对研究中可能提出的任何一种解决方案，都要从经济可行性、技术可行性、运行可行性、法律可行性等方面来研究其可行性。研究的步骤可为，对当前系统进行调查和研究、导出新系统的解决方案结束、提出推荐的方案、编写可行性论证报告。

风险识别从宏观上说，风险可区分为项目风险、技术风险和商业风险。将可能发生的风险区分为若干子类，常见的风险子类：产品规模风险、商业影响风险、与客户相关的风险、过程风险、技术风险、开发环境风险、人员结构和经验风险。

风险预测风险预测（riskforecast）又称为风险估计（riskestimation），一般包括两个方面的内容：风险发生的可能性，建立风险可能性尺度（如极罕见、罕见、普通、可能或极可能等）；风险发生后所产生的后果（如灾难性的、严重的、轻微的、可忽略的等）。

风险的驾驭与监控主要要靠管理者的经验来实施。风险驾驭与监控首先应该建立风险缓解、监控和管理计划，记录风险分析的全部工作，并且作为整个项目计划的一部分为项目管理人员所使用。这些驾驭风险的措施会增加项目成本，称之为风险成本，在考虑风险成本之后，再决定是否采用上述策略。

软件计划涉及实施项目的各个环节，计划的合理性和准确性往往关系着项目的成败。针对不同的工作目标，软件计划可分为以下7种主要类型：项目实施计划（通常包括软件目标、功能、进度、资源和费用等多个方面）、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件分发计划。

项目实施计划是一种管理文档，供软件开发单位使用。在开发过程中，开发单位的管理人员根据这一计划安排和检查开发工作，并可根据项目的进展情况定期进行必要的调整。实施计划一般不应写得太长、太复杂。只需把项目目标、开发周期以及所需资源和资金等写清楚即可。

# 结构化分析与设计

本章重点介绍基于瀑布模型的结构化分析与设计，将相关的技术（例如模块设计）集中在一章中，并精简了一些过时的技术。

## （一）概述

### 1. 结构化分析与设计的由来

结构化分析与设计最初是由结构化程序设计扩展而来的。结构化分析技术（structured analysis，SA）、结构化设计技术（structured design，SD）合称为结构化分析与设计方法，它是第一代软件工程时期最有代表性的应用系统开发方法。

### 2. SA与SD的流程

系统开发从需求分析开始，首先建立系统的需求模型；接着通过SD方法提供的映射规则，把分析模型转化为初始设计模型；然后再优化为系统的最终设计模型。

结构化分析SA有两项基本任务，即建立系统分析模型（analysis model），可用分层DFD图；编写软件需求规格说明书（software requirements specification，SRS）二者都是分析阶段必须完成的文档。

- SA模型包含描述软件需求的一组模型，通常有功能模型、数据模型、行为模型3种模型，分别表示待开发系统的功能需求、数据需求、行为需求。
- SRS是分析阶段编写的、以文字为主的文档（应该具有准确性、防止二义性、直观易改）。建议SRS文档的主要内容包括引言、信息描述、功能描述、行为描述、质量保证、接口描述以及其他需求等。
- 抽象与分解，是结构化分析的主要指导思想。当需要获得系统的细节时，就应该移向低层次的抽象，抽象的层次愈低，呈现的细节也会愈多。

结构化设计SD分为总体设计和详细设计。

- SD阶段把分析模型中的DFD图转换为最终SC图，在之后详细设计中，还需用适当的工具对各个模块采用的算法和数据结构进行足够细致的描述。
- 结构化设计产生的SC图一般需分为两步完成，即首先通过映射获得初始SC图；然后通过优化获得最终SC图。然后详细设计完成模块说明。
- 分解和细化，历来是重要的软件设计策略。细化是与抽象相反而又互补的一对概念。细化的实质就是分解，程序设计是一个渐进的过程，逐步细化就是自顶向下设计。

### 3. SA模型的组成与描述

1. 通过对现实环境的调查研究，获取当前系统的具体模型。把用户目前使用的系统称为当前系统。
2. 分析需求，建立系统分析模型，包括当前系统模型和目标系统模型。把用计算机实现的系统称为目标系统。
   1. 去掉上述模型中的非本质因素，提炼出当前系统的逻辑模型。
   2. 分析当前系统与目标系统的差别，建立目标系统的逻辑模型。目标系统是一个基于计算机的系统，一般说来，它的功能应该比当前的现行系统更强，不必也不应该完全模拟现行的系统。
3. 整理综合需求，编写系统需求规格说明书。
4. 验证需求，完善和补充对目标系统的描述。
   1. 通过目标系统的人机界面，和用户一起确认目标系统功能，主要是区分哪些功能交给计算机去做，哪些功能由人工完成。
   2. 复审需求规格说明书，补充迄今尚未考虑过的细节，例如确定系统的响应时间、增加出错处理等。

经过以上的修正和补充，即可得到改进后的目标系统逻辑模型。至此销售系统的分析模型即告完成，它主要用图形符号来表达，在SA中称为DFD图。

对于SA模型的组成，数据字典（datadictionary，DD）处于模型的核心，它是系统涉及的各种数据对象的总和。从DD出发可构建3种图：

- 实体联系图（entity-relation diagram，E-R图）用于描述数据对象间的关系。
- 数据流图（data flow diagram，DFD）主要作用是指明系统中的数据是如何流动和变换的。在DFD中出现的每个功能，可在加工规格说明（process specification，PSPEC）中进行描述，它们一起构成软件的功能模型。
- 状态变换图（status transform diagram，STD）用于表明系统的各种状态以及状态间的变换。关于软件控制方面的附加信息，还可用控制规格说明（control specification，CSPEC）来描述。

### 4. SD模型的组成与描述

SD模型是由SA模型映射而来的。SA模型的数据字典可转换为待开发系统的数据设计，数据流图可转换为体系结构设计与接口设计，加工规格说明可转换为模块内部的详细过程设计等等。

由下向上包含了数据设计、体系结构设计、接口设计与过程设计。体系结构设计是用来确定软件结构的，其描述工具为结构图（structure chart，SC），过程设计主要指模块内部的详细设计。

在SC图中，用矩形框来表示模块，带箭头的连线表示模块间的调用，并在调用线的两旁标出传入和传出模块的数据流。SC图允许使用的6种模块

- 传入、传出和变换模块用来组成变换结构中的各个相应部分。
- 源模块是不调用其他模块的传入模块，只用于传入部分的始端。
- 漏模块是不调用其他模块的传出模块，仅用于传出部分的末端。
- 控制模块是只调用其他模块，不受其他模块调用的模块。例如变换型结构的顶层模块，事务型结构的事务中心等，均属于这一类。

## （二）结构化系统分析

结构化分析的基本步骤是：自顶向下对系统进行功能分解，画出分层DFD图；由后向前定义系统的数据和加工，编制DD和PSPEC；最终写出SRS。

### 1. 画分层数据流图

从系统的基本功能模型（把整个系统看成一个加工）开始，逐层地对系统进行分解。每分解一次，系统的加工数量就增加一些，加工的功能也更具体一些。继续重复这种分解，直到所有的加工都足够简单为止。通常把这种不需再分解的加工称为基本加工，把上述逐步分解称为自顶向下、逐步细化（top-down stepwise refinement），最终为待开发的系统画出一组分层的数据流图，以代替一张含有系统全部加工的包罗万象的总数据流图。

分层DFD具有下列优点：

- 便于实现。采用逐步细化的扩展方法，可避免一次引入过多细节，有利于控制问题的复杂度。
- 便于使用。用一组图代替一张总图，使用户中的不同业务人员可各自选择与本身有关的图形，不必阅读全图。

### 2. 确定数据定义与加工策略

最低一层DFD图已包含了系统的全部数据和加工，一般应从数据的终点开始分析，因为终点的数据代表系统的输出，其要求是明确的，由这里开始，沿着DFD图一步步向数据源点回溯，较易看清楚数据流中每一个数据项的变化。继续回溯，得出加工策略和各个有关数据的定义。分析结束后，应为DFD的每个数据逐一写出定义，每个基本加工逐个进行加工规格说明，并汇编成数据字典。

分层DFD图产生了系统的全部数据和加工，通过对这些数据和加工的定义，常常会发现一些新问题，从而进行新的调查和思考，并可能导致对DFD的修改。画DFD，定义加工和数据，再画，再定义，如此循环，直至产生一个为用户和分析员一致同意的SRS文档。

### 3. 需求分析的复审

需求分析的文档完成后，应由用户和系统分析员共同进行复审，并吸收设计人员参加。复审的重点，是DFD、DD和加工规格说明等文档的完整性、易改性和易读性，尽量多地发现文档中存在的矛盾、冗余与遗漏。

## （三）结构化系统设计

### 1. SD概述

面向数据流设计。以SD方法为主要代表，数据流是考虑一切问题的出发点。在与之配套的SA方法中，通常用数据流图来表示软件的逻辑模型；在设计阶段，又按照数据流图的不同类型（变换型或事务型）将它们转换为相应的软件结构。SD方法把注意力集中在模块的合理划分上，其目标是得出软件的体系结构图。

从分析模型导出设计模型。设计是把用户的需求准确地转换为软件产品或系统的唯一方法，无论是传统的设计或面向对象的设计，都要从分析阶段得到的分析模型导出软件的设计模型。其中不少系统设计方法都提供了将分析描述直接转换为设计描述的映射（mapping）规则，使软件设计变得更加容易。

设计模型从底到上，数据设计可以由数据字典、实体联系图、数据流图导出；体系结构设计与接口设计可以由数据流图导出；过程设计可根据加工规格说明、控制规格说明、状态转换图来定义等等。

### 2. SD的步骤：从DFD图到SC图

从SA获得的DFD中，所有系统可归结为变换型结构和事务型结构两种类型。

- 变换型结构由传入路径、变换中心和传出路径3部分组成。
- 事务型结构由至少一条接受路径、一个事务中心与若干条动作路径组成。当外部信息沿着接受路径进入系统后，经过事务中心获得某一个特定值，就能据此启动某一条动作路径的操作。

为了有效地实现从DFD图到SC图的映射，结构化设计规定了下列4个步骤：

1. 复审DFD图，必要时可再次进行修改或细化。
2. 鉴别DFD图所表示的软件系统的结构特征，确定它所代表的软件结构是属于变换型还是事务型。
3. 按照SD方法规定的一组规则，把DFD图映射为初始SC图。变换型DFD图经过变换映射变为初始SC图，事务型DFD图经过事务映射变为初始SC图。
4. 按照优化设计的指导原则改进初始SC图，获得最终SC图。

### 3. 变换映射

变换映射主要步骤包括：

1. 在DFD图上区分传入、传出和变换中心3个部分，划分DFD图的边界。
2. 完成一级分解，建立初始SC图的框架。
3. 完成二级分解，细化分解SC图的各个分支。

实际上数据流在传入的过程中，也可能经历数据的变换。可以在中间模块B下增添个变换模块，如A to B，并在模块名称前加上Read、Get等字样。这一改变的实质是，除了处于物理输入端的源模块以外，让每一传入模块都调用两个下属模块，包括一个传入模块和一个变换模块。仿照与传入分支相似的分解方法，可得到传出分支的两种模块分解图。变换中心分支的情况繁简迥异，但建立初始的SC图时，仍可以采取一对一映射的简单转换方法。

### 4. 事务映射

事务映射主要步骤包括：

1. 在DFD图上确定事务中心、接受部分（包括接受路径）和发送部分（包括全部动作路径），划分边界。
2. 画出SC图框架，把DFD图的3个部分分别映射为事务控制模块、接受模块和动作发送模块。如果第一层的模块比较简单，也可以并入顶层。
3. 分解和细化接受分支和发送分支，完成初始的SC图。因为接受分支一般具有变换特性，可以按变换映射对它进行分解。重点是对动作（即发送）分支进行分解，典型结构分为4层，从顶到下依次为：
   1. 处理层P，相当于初始SC图的发送模块。
   2. 事务层T，每一动作路径可映射为一个事务模块。
   3. 操作层A、细节层D。在事务层以下可以再分解出操作层（actions层）及细节层（details层）。由于同一系统中的事务往往含有部分相同的操作，各操作又可能具有部分相同的细节，这两层的模块常能为它们的上层模块所共享，被多个上级模块调用。

### 5. 优化初始SC图的指导规则

1. **对模块划分的原则**

一般来说，模块的总行数应控制在10\~100行的范围内，最好为30\~60行，能容纳在一张打印纸内。过长的模块往往是分解不充分的表现，会增加阅读理解的难度；但小模块太多也会使块间联系变得复杂，增大系统在模块调用时传递信息所花费的开销。

在改进SC图时，有些模块在图上的位置可能要上升、下降或左右移动，从而变更模块调用关系。模块位置应否变更，应视对计算机处理是否方便而定，不必拘泥于它与DFD图上对应的加工是否位置一致。

2. **高扇入、低扇出的原则**

扇入（fan-in）、扇出（fan-out）是从电子学借用过来的词，在SC图中可用于显示模块的调用关系。

扇入高则上级模块多，能够增加模块的利用率；扇出低则表示下级模块少，可以减少模块调用和控制的复杂度。通常扇出数以3\~4为宜，最好不超过5\~7。如扇出过大，软件结构将呈煎饼形（pancaking），煎饼形一般是不可取的，因为它常常是高扇出的结果，此时可用增加中间层的方法使扇出减小。

设计良好的软件通常具有瓮形（oval-shaped）结构，两头小，中间大，这类软件在下部收拢，表明它在低层模块中使用了较多高扇入的共享模块。

## （四）模块设计

传统软件工程将软件设计分成两步走：总体（或结构）设计，用最终SC图表示；模块设计，用逐步细化的方法来实现。模块设计用于对系统中的每个模块给出足够详细的逻辑描述，故亦称详细设计。

### 1. 目的与任务

详细设计的目的，是为SC图中的每个模块确定采用的算法和块内数据结构，用选定的表达工具给出清晰的描述。表达工具必须具有描述过程细节的能力，而且能在编码阶段直接将它翻译为用程序设计语言书写的源程序。

这一阶段的主要任务，是编写软件的模块设计说明书。设计人员应：

1. 为每个模块确定采用的算法。选择某种适当的工具表达算法的过程，写出模块的详细过程性描述。
2. 确定每一模块使用的数据结构。
3. 确定模块接口的细节，包括对系统外部的接口和用户界面，对系统内部其他模块的接口，以及关于模块输入数据、输出数据及局部数据的全部细节。

### 2. 模块设计的原则与方法

在大多数情况下，应该遵守“清晰第一，效率第二”的设计风格。

任何程序的逻辑均可用顺序、选择和循环（DO-WHILE）3种控制结构或它们的组合来实现，每个控制结构只应有一个入口和一个出口的。补充说明：为了方便使用或者提髙程序效率，大多数软件开发项目还允许在详细设计中补充使用DO-UNTIL和DO-CASE两种控制结构。在许多情况下，当程序执行到满足某种条件时，需要立即从循环中转移出来。

逐步细化的实现方法，设计步骤归结为：

1. 由粗到细地对程序进行逐步的细化。每一步可选择其中的一条至数条，将它（们）分解成更多或更详细的程序步骤。
2. 在细化程序的过程时，同时对数据的描述进行细化。即过程和数据结构的细化要并行地进行，在适当的时候交叉穿插。
3. 每一步细化均使用相同的结构化语言，最后一步一般直接用伪代码来描述，以便编码时直接翻译为源程序。

逐步细化设计受到许多人的赞同，并不是偶然的。

它的主要优点是：

- 每一步只优先处理当前最需要细化的部分，其余部分则推迟到适当的时机再考虑。先后有序，主次分明，可避免全面开花，顾此失彼。
- 易于验证程序正确性，比形式化的程序正确性证明更易被非专业人员接受，因而也更加实用。用逐步细化方法设计的程序，由于相邻步之间变化甚小，不难验证它们的内容是否等效。所以这一方法的实质，是要求在每一步细化中确保实现前一步的要求，不要等程序写完后再来验证。

用结构化保证程序的清晰、易读，用逐步细化实现程序的正确、可靠，由此很自然地得出如下结论：模块的逻辑设计必须用结构程序设计的原理来指导。

常用的表达工具有流程图（flow diagram、N-S图、伪代码（pseudo code）、PDL语言等。