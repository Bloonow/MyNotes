> **数据结构教程（第5版） 清华大学出版社**

[toc]

# 一、绪论

## （一）什么是数据结构

通常以数据元素作为数据结构的基本单位，数据项（data item）是具有独立含义的数据的最小单位，也称字段或域；数据对象（data object）是指性质相同的数据元素的集合，它是数据的一个子集；数据结构（data structure）是指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合。

数据结构通常包括以下几个方面：

- 数据的逻辑结构（logical structure）：由数据元素之间的逻辑关系构成。
- 数据的存储结构（storage structure）：数据元素及其关系在计算机存储器中的存储表示，也称数据的物理结构（physical structure）。
- 数据的运算（operation）：施加在该数据上的操作。

**逻辑结构**表示可以用，图表表示；二元组表示，二元组表示如下：

B = ( D, R )，其中 B 是一种数据逻辑结构，它由数据元素的集合 D 以及D上的二元关系的集合 R 所组成，D = { di | 1 <= i <= n, n >= 0 }，R = { ri | 1 <= j <= m, m >= 0 }。R 中的一个关系 r 是序偶的集合，对于 r 中的任一序偶 <x,y>（x,y ∈ D），表示元素 x 和元素 y 之间是相邻的，即 x 在 y 之前，x 是该序偶的第一元素，y 是第二元素，而且 x 为 y 的直接前驱元素（predecessor），y 为 x 的直接后继元素（successor），简称前驱元素和后继元素；若某个元素没有前驱元素，则该元素为开始元素（first element），若某个元素没有后继元素，则该元素为终端元素（terminal element）。

逻辑结构的主要类型有集合（set）；线性结构（linear structure），数据元素之间为一对一的关系；树形结构，数据元素之间为一对多的关系；图形结构，数据元素之间为多对多的关系。

数据逻辑结构在计算机存储器中的存储表示称为数据的**存储结构**（也称为映像），也就是逻辑结构在计算机中的存储实现。主要有顺序存储结构（sequential storage structure）、链式存储结构（linked storage structure）、索引存储结构（indexed storage structure）、哈希（或散列）存储结构（hashed storage structure）。

**数据运算**是指对数据实施的操作，最常用的有检索、插入、删除、更新和排序等。

**数据类型**（data type）是一组性质相同的值的集合和定义在此集合上的一组操作的总称，是某种程序设计语言中已实现的数据结构。

抽象数据类型（Abstract Data Type，ADT）指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑结构和逻辑结构上的运算，而不考虑计算机的具体存储结构和运算的具体实现算法。一个抽象数据类型可用 (D, S, P) 三元组表示，其中D是数据对象，S是D上的关系，P是D中数据的基本运算集，抽象数据类型的基本描述格式如下：

```c++
ADT 抽象数据类型名 {
	数据对象：数据对象的声明
	数据关系：数据关系的声明
	基本运算：基本运算的声明
}
```

- 其中，基本运算的声明格式为，基本运算名(参数表)：运算功能描述。

## （二）算法描述及其分析

**算法**（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列。算法具有有穷性、确定性、可行性、有输入、有输出。算法的设计目标有正确性、可使用性、可读性、健壮性、高效率与低存储量需求。

算法分析就是分析算法占用计算机资源的多少，算法时间性能分析有两种即事后统计法，和事前估计法。

算法时间复杂度分析，如下：

1. 计算算法的频度T(n)，一个算法是由控制结构（顺序、分支和循环三种）和原操作（值固有数据类型的操作）构成的。算法时间分析即求出算法所有原操作的执行次数（也称频度），它是问题规模 n 的函数，用 T(n) 表示。
2. T(n) 用 "O" 表示，算法的时间复杂度（time complexity）就是用 T(n) 的数量级来表示，记作 T(n) = O(f(n))
   在上述表达式中的O是Order的简写，意指数量级，其含义是为 T(n) 找到一个上界 f(n)，其严格的数学定义是 T(n) 的数量级表示为 O(f(n))，是指存在着正常量 c 和 n0（为一个足够大的正整数），使得`Lim(n-->n0){ |T(n)| / |f(n)| } = c != 0`成立。所以算法的时间复杂度也称为渐进时间复杂度，它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，因此算法时间复杂度分析实际上是一种时间增长趋势分析。根据其趋势不同，分为多项式时间复杂度（polynomial time complexity）和指数时间复杂度（exponential time complexity）等。其常见排序如`O(1) < O(log2(n)) < O(n) < O(n*log2(n)) < O(n^2) < O(n^3) < O(2^n) < O(n!)`。
3. 简化的时间复杂度分析，即仅仅考虑算法中的基本操作（指算法中最深层循环内的原操作）的执行次数。
4. 时间复杂度的求和、求积定理，假设 T1(n) 和 T2(n) 分别是程序段 P1、P2 的执行时间，并且 T1(n) = O(f(n))，T2(n) = O(g(n))。求和定理：先执行 P1，再执行 P2，总执行时间是：`T1(n) + T2(n) = O(MAX{ f(n), g(n) })`。求积定理：程序嵌套执行，总执行时间是：`T1(n) * T2(n) = O ( f(n) * g(n) )`。

算法的最好、最坏和平均时间复杂度。设一个算法的输入规模为 n，Dn 是所有输入（实例）的集合，任意输入 I ∈ Dn，P(I) 是 I 出现的频率，有 ∑(I∈Dn){ P(I) } = 1。T(I) 是算法再输入 I 下所执行的基本操作的次数，则算法的平均时间复杂度定义为：`E(n) = ∑(I∈Dn){ P(I) * T(I) }`。算法的最好时间复杂度是指在最好情况下的时间复杂度，即`B(n) = MIN(I∈Dn){ T(n) }`。算法的最坏时间复杂度是指在最坏情况下的时间复杂度，即`W(n) = MAX(I∈Dn){ T(n) }`。

递归算法时间复杂度分析，在递归算法中首先写出对应的递推式，然后求解递推式得出算法的执行时间或空间。

算法空间复杂度分析，对算法进行存储空间分析时只考察临时变量所占的空间，不计形参占用的空间。算法空间复杂度（space complexity）是对一个算法在运行过程中临时占用的存储空间大小的度量，一般也作为问题规模 n 的函数，以数量级的形式给出，记作S(n) = O(g(n))。若所需临时空间相对于问题规模来说是常数，则称此算法为原地工作算法或就地工作算法。

递归算法空间复杂度分析，对于递归算法，为了实现递归过程用到一个递归栈，所以需要根据递归深度得到算法的空间复杂度。

# 二、线性表

## （一）线性表（linear list）及其逻辑结构

元素个数叫线性表的长度，表头元素、表尾元素。

线性表的抽象数据类型，描述如下：

```c++
ADT List {
	数据对象:
		D = { ai | 1 <= i <= n, ai为ElemType类型 }     ElemType是自定义类型标识符
	数据关系:
		R = { <ai, a(i+1)> | ai、a(i+1) ∈ D, i = 1,...,n-1 }
	基本运算:
		InitList(&L)
		DestroyList(&L)
		ListEmpty(L)
		ListLength(L)
		DispList(L)
		GetElem(L,i,&e)
		LocateElem(L,e)
		ListInsert(&L,i,e)
		ListDelete(&L,i,&e)
}
```

## （二）线性表的顺序存储结构

### 1. 顺序表（sequential list）实现

数据类型定义

```c++
const int MaxSize = 50;		// 估计一个线性表不会超过50个元素
typedef int ElemType;		// 元素类型

// 声明线性表的顺序存储类型
typedef struct {
	ElemType data[MaxSize];	// 存放线性表中的元素
	int length;     		// 存放线性表的长度
} SqList;     				// 顺序表类型
```

建立线性表，由数组元素a[0...n-1]创建顺序表L的操作

```c++
void CreateList(SqList*& L, ElemType a[], int n) {
	int i = 0, k = 0;		// k表示L中的元素的个数，初始值为0
	L = (SqList*)malloc(sizeof(SqList));	// 分配存放线性表的空间
    // i扫描数组a的元素
	while (i < n) {
		L->data[k] = a[i];	// 将元素a[i]放到L中
		++k;
		++i;
	}
	L->length = k;			// 设置L的长度k
}
```

初始化线性表 InitList(&L)

```c++
void InitList(SqList*& L) {
	L = (SqList*)malloc(sizeof(SqList));	// 分配存放线性表的空间
	L->length = 0;							// 置空线性表的长度为0
}
```

销毁线性表 DestroyList(&L) O(1)

```c++
void DestroyList(SqList*& L) {
	free(L);		// 释放L所指的顺序表空间
}
```

判断线性表是否为空表 ListEmpty(L) O(1)

```c++
bool ListEmpty(SqList* L) {
	return L->length == 0;
}
```

求线性表的长度 ListLength(L) O(1)

```c++
int ListLength(SqList* L) {
	return L->length;
}
```

输出线性表 DispList(L) O(n)

```c++
void DispList(SqList* L) {
	// 扫描线性表输出各元素值
	for (int i = 0; i < L->length; ++i) {
		printf("%d ", L->data[i]);
	}
	printf("\n");
}
```

求线性表中的某个数据元素的值 GetElem(L, i, &e) O(1)

```c++
bool GetElem(SqList* L, int i, ElemType& e) {
	if (i < 1 || i > L->length) {
		return false;	// 参数i错误时返回false
	}
	e = L->data[i - 1];	// 取元素值
	return true;		// 成功找到元素时返回true
}
```

按元素值查找 LocateElem(L, e) O(n)

```c++
int LocateElem(SqList* L, ElemType e) {
	int i = 0;
	// 查找元素e
	while (i < L->length && L->data[i] != e) {
		++i;
	}

	if (i >= L->length) {
		return 0;		// 未找到时返回0
	} else {
		return i + 1;	// 找到后返回其逻辑序号
	}
}
```

插入数据元素 ListInsert(&L, i, e) O(n)

```c++
bool ListInsert(SqList*& L, int i, ElemType e) {
	if (i < 1 || i > L->length + 1) {
		return false;	// 参数i错误时返回false
	}
	--i;     			// 将顺序表逻辑序号转化为物理序号
	for (int j = L->length; j > i; --j) {
		L->data[j] = L->data[j - 1];	// 将data[i]及后面的元素后移一个位置
	}
	L->data[i] = e;		// 插入元素e
	++L->length;		// 顺序表长度加1
	return true;		// 成功插入返回true
}
```

删除数据元素 ListDelete(&L, i, &e) O(n)

```c++
bool ListDelete(SqList*& L, int i, ElemType& e) {
	if (i < 1 || i > L->length) {
		return false;	// 参数i错误时返回false
	}
	--i;				// 将顺序表逻辑序号转化为物理序号
	e = L->data[i];
	for (int j = i; j < L->length - 1; ++j) {
		L->data[j] = L->data[j + 1];	// 将data[i]之后的元素前移一个位置
	}
	--L->length;		// 顺序表长度减1
	return true;		// 成功插入返回true
}
```

### 2. 顺序表的应用示例

例2.3 假设一个线性表采用顺序表表示，设计一个算法，删除其中所有值等于x的元素。要求算法的时间复杂度为O(n)，空间复杂度为O(1)。

解法一：扫描顺序表，重建L只含不等于x的元素，从左到右扫描L中的所有元素，当等于x时跳过它；否则将其放在k的位置，++k。

```c++
void delnode1(SqList*& L, ElemType x) {
	int k = 0, i;		// k记录不等于x的元素的个数，即要插入到L中元素的个数
	for (i = 0; i < L->length; ++i) {
		// 若当前元素不为x，将其插入到L中
		if (L->data[i] != x) {
			L->data[k] = L->data[i];
			++k;		// 插入一个元素时，元素的个数加1
		}
	}
	L->length = k;		// 顺序表L的长度等于k
}
```

解法二：从左到右扫描L，用k记录L中当前等于x的个数，边扫描边统计，等于x时k加一；否则将不为x的元素向前移k个位置。

```c++
void delnode2(SqList*& L, ElemType x) {
	int k = 0, i = 0;		// k记录当前等于x的元素的个数
	while (i < L->length) {
		// 当前元素为x时k加一
		if (L->data[i] == x) {
			++k;
		} else {
		// 当前元素不为x时，将其前移k个位置
		L->data[i - k] = L->data[i];
		}
		++i;
	}
	L->length -= k;			// 顺序表长度减k
}
```

例2.4 有一个顺序表L，以第一个元素为分界线（基准），将小于它的移到该基准前面，大于它的移到该基准后面。基本思路是：以第一个元素为基准，从右向左找一个小于等于基准的元素x，从左向右找一个大于基准的元素y，将两者交换，直到全部找完。时间复杂度为O(n)，空间复杂度为O(1)。

解法一：都找到，将大的跟小的交换，最后交换基准和重合处的元素。

```c++
void partition1(SqList*& L) {
	int i = 0, j = L->length - 1;
	ElemType pivot = L->data[0];	// 以data[0]为基准
	ElemType temp;					// 元素交换时用的临时变量
	// 从区间两端交替向中间扫描，直到i=j为止
	while (i < j) {
		// 从右向左扫描，找到一个小于等于pivot的元素
		while (i < j && L->data[j] > pivot) {
			--j;
		}
		// 从左向右扫描，找到一个大于pivot的元素
		while (i < j && L->data[i] <= pivot) {
			++i;
		}
		// 将大的跟小的交换
		if (i < j) {
			temp = L->data[i];
			L->data[i] = L->data[j];
			L->data[j] = temp;
		}
	}
	// 将重合处跟基准交换
	temp = L->data[0];
	L->data[0] = L->data[i];
	L->data[i] = temp;
}
```

解法二：找到便立即交换（i跟j），最后用基准赋给重合处。

```c++
void partition2(SqList*& L) {
	int i = 0, j = L->length - 1;
	ElemType pivot = L->data[0];	// 以data[0]为基准
	while (i < j) {
		while (i < j && L->data[j] > pivot) {
			--j;	// 从右向左扫描，找到一个小于等于pivot的元素data[j]
		}
		L->data[i] = L->data[j];	// 将data[j]放到data[i]处
		while (i < j && L->data[i] <= pivot) {
			++i;	// 从左向右扫描，找到一个大于pivot的元素data[i]
		}
		L->data[j] = L->data[i];	// 将data[i]放到data[j]处
	}
	L->data[i] = pivot;		// 将基准放到重合处
}
```

例2.5 将顺序表L中的所有奇数移动到偶数前面，时间复杂度为O(n)，空间复杂度为O(1)。

解法一：类似于例2.4解法一的思路。

```c++
void move1(SqList*& L) {
	int i = 0, j = L->length - 1;
	ElemType temp;
	while (i < j) {
		while (i < j && L->data[j] % 2 == 0) {
			--j;	// 从右向左，找一个奇数
		}
		while (i < j && L->data[i] % 2 != 0) {
			++i;	// 从左向右，找一个偶数
		}
		// 交换两个所找到的元素
		if (i < j) {
			temp = L->data[i];
			L->data[i] = L->data[j];
			L->data[j] = temp;
		}
	}
}
```

解法二：扫描遍历顺序表L，重建（有交换元素在里面）顺序表data[0...i]表示奇数区间（i指向奇数区间最后一个元素，初始为-1时表示为空），用j从左向右遍历所有元素，若j指向奇数，则将i加一，j和i上的元素交换，over。

```c++
void move2(SqList*& L) {
	int i = -1, j;
	ElemType temp;
	for (j = 0; j < L->length; ++j) {
		// 当j指向奇数时
		if (L->data[j] % 2 != 0) {
			++i;	// 奇数区间元素个数加一
			// 若i和j不指向同一元素，则将他们交换
			if (i != j) {
				temp = L->data[i];
				L->data[i] = L->data[j];
				L->data[j] = temp;
			}
		}
	}
}
```

自实现快排，辅助将顺序表递增排序。

```c++
void Qsort(ElemType a[], int firstIndex, int lastIndex) {
	if (firstIndex >= lastIndex) {
		return;
	}
	int left = firstIndex, right = lastIndex;
	ElemType pivot = a[firstIndex];
	while (left < right) {
		while (left < right && a[right] > pivot) {
			right--;
		}
		a[left] = a[right];
		while (left < right && a[left] <= pivot) {
			left++;
		}
		a[right] = a[left];
	}
	a[left] = pivot;
	Qsort(a, firstIndex, left - 1);
	Qsort(a, left + 1, lastIndex);
}

void Sort(SqList*& L) {
	Qsort(L->data, 0, L->length - 1);
}
```

## （三）线性表的链式存储结构

### 1. 单链表（singly linked list）

数据类型定义

```c++
// 元素类型
typedef int ElemType;

// 每个结点用LinkNode表示
typedef struct LNode {
	ElemType data;
	struct LNode* next;
} LinkNode;
```

建立单链表 头插法，用数组a[]做最初元素（最后链表与数组顺序相反）

```c++
void CreateListF(LinkNode*& L, ElemType a[], int n) {
	LinkNode* s;
	L = (LinkNode*)malloc(sizeof(LinkNode));
	L->next = NULL;     // 创建头结点，其next域置为null
	// 循环建立数据结点s
	for (int i = 0; i < n; ++i) {
		s = (LinkNode*)malloc(sizeof(LinkNode));
		s->data = a[i];     	// 创建数据结点s
		s->next = L->next;		// 将s插入到首结点之前，头结点之后
		L->next = s;
	}
}
```

建立单链表 尾插法，用数组a[]做最初元素，还需要一个尾指针r，最后将其next域置为null

```c++
void CreateListR(LinkNode*& L, ElemType a[], int n) {
	LinkNode *s, *r;
	L = (LinkNode*)malloc(sizeof(LinkNode));     // 创建头结点
	r = L;     // r始终指向尾结点，初始时头结点即尾结点
	// 循环建立数据结点
	for (int i = 0; i < n; ++i) {
		s = (LinkNode*)malloc(sizeof(LinkNode));
		s->data = a[i];		// 创建数据结点s
		r->next = s;     	// 将结点s插入到尾结点r之后
		r = s;				// 尾结点r更新为最后一个
	}
	r->next = NULL;			// 尾结点next域置为null
}
```

初始化线性表 InitList(&L) O(1)

```c++
void InitList(LinkNode*& L) {
	L = (LinkNode*)malloc(sizeof(LinkNode));
	L->next = NULL;
}
```

销毁线性表 DestroyList(&L) O(n)，须遍历线性表，逐一释放每个结点空间

```c++
void DestroyList(LinkNode*& L) {
	LinkNode *pre = L, *p = L->next;     // pre指向结点p的前驱节点
	// 扫描单链表L
	while (p != NULL) {
		free(pre);     	// 释放pre结点
		pre = p;     	// pre、p同步后移一个结点
		p = p->next;
	}
	free(pre);     		// 循环结束时p为null，pre指向尾结点，释放之
}
```

判断线性表是否为空链表 ListEmpty(L) O(1)

```c++
bool ListEmpty(LinkNode* L) {
	return L->next == NULL;
}
```

求线性表的长度 ListLength(L) O(n)

```c++
int ListLength(LinkNode* L) {
	int n = 0;
	LinkNode* p = L;     // p初始指向头结点，n为0，即头结点的序号为0
	while (p->next != NULL) {
		n++;
		p = p->next;
	}
	return n;     		// 循环结束，p指向尾结点，其序号n为结点个数
}
```

输出线性表 DispList(L) O(n)

```c++
void DispList(LinkNode* L) {
	LinkNode* p = L->next;	// p指向首结点
	// p不为null，输出结点p的data域
	while (p != NULL) {
		printf("%d ", p->data);
		p = p->next;		// p移向下一个结点
	}
	printf("\n");
}
```

求线性表中的某个数据元素值 GetElem(L, i, &e) O(n)

```c++
bool GetElem(LinkNode* L, int i, ElemType& e) {
	if (i <= 0) {
		return false;	// i错误返回false
	}
	int j = 0;
	LinkNode* p = L;	// p初始指向头结点，j置为0（即头结点的序号为0）
	// 找到第i个结点，或者遍历到尾（没有第i个结点，即单链表长度小于i）
	while (j < i && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;     // 不存在第i个结点（i超出单链表长度），返回false
	} else {
		e = p->data;	  // 存在第i个结点，赋给e，返回true
	return true;
	}
}
```

按元素值查找 LocateElem(L, e) O(n)

```c++
int LocateElem(LinkNode* L, ElemType e) {
	int i = 1;
	LinkNode* p = L->next;     // p初始指向首结点，i置为1（即首结点序号为1）
	// 查找data值为e的结点，其序号为i
	while (p != NULL && p->data != e) {
		p = p->next;
		++i;
	}
	if (p == NULL) {
		return 0;     // 不存在值为e的结点，返回0
	} else {
		return i;     // 存在值为e的结点，返回其逻辑序号
	}
}
```

插入数据元素 ListInsert(&L, i, e) O(n)

```c++
bool ListInsert(LinkNode*& L, int i, ElemType e) {
	if (i <= 0) {
		return false;     // i错误返回false
	}
	int j = 0;
	LinkNode *p = L, *s;     // p初始指向头结点，j置为0（即头结点序号为0）
	// 查找第i个结点的前驱节点，即第i-1个结点，用p指向
	while (j < i - 1 && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;     // i-1超出单链表长度，返回false
	} else {
	// 找到第i-1个结点p，插入新结点，返回true
		s = (LinkNode*)malloc(sizeof(LinkNode));
		s->data = e;     // 创建新结点s，其data域为e
		s->next = p->next;     // 将新结点插入到p结点之后（即i-1之后，i之前）
		p->next = s;
		return true;
	}
}
```

删除数据元素 ListDelete(&L, i, &e) O(n)

```c++
bool ListDelete(LinkNode*& L, int i, ElemType &e) {
	if (i <= 0) {
		return false;     // i错误返回false
	}
	int j = 0;
	LinkNode *p = L, *q;     // p初始指向头结点，j置为0（即头结点序号为0）
	// 查找第i个结点的前驱节点，即第i-1个结点，用p指向
	while (j < i - 1 && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;     // i-1超出单链表长度，返回false
	} else {
	// 找到第i-1个结点
	q = p->next;     // q指向第i个结点
		if (q == NULL) {
			// 若第i个结点为null，即第i-1个结点为尾结点, 返回false
			// 是因为之前while中判断语句的短路特性，当i正好是尾结点时
			// while是由于j == i-1而跳出的循环，此时前驱节点(i-1)p指向尾结点
			// 这种情况下，再令q = p->next时，q是NULL，故需要判断
			return false;
		}
		e = q->data;     	// 删除的结点元素作为返回值返回
		p->next = q->next;  // 从单链表中删除q结点，即第i个结点
		free(q);     		// 释放空间
		return true;
	}
}
```

自实现：向单链表尾加入结点 pushElem(&L, e) O(n)

```c++
void pushElem(LinkNode*& L, ElemType e) {
	LinkNode *p = L, *s;
	while (p->next != NULL) {
		p = p->next;
	}
	s = (LinkNode*)malloc(sizeof(LinkNode));
	s->next = NULL;
	s->data = e;
	p->next = s;
}
```

### 2. 单链表的应用示例

例2.6 将带有头结点的单链表L={a1,b1,a2,b2,...,an,bn}（偶数个元素结点），拆成两个带头结点的L1和L2，要求L1使用L的头结点，L1={a1,a2,a3,...,an}  L2={bn,b(n-1),...,b2,b1}。解题思路：重建L1和L2，由其顺序知L1用尾插法，L2用头插法，时间复杂度为O(n)

```c++
void split(LinkNode*& L, LinkNode*& L1, LinkNode*& L2) {
	LinkNode *p = L->next, *q, *r1;     // p初始指向第一个数据结点
	L1 = L;      // L1利用原来的L的头结点
	r1 = L1;     // r1始终指向L1的尾结点，初始时头结点即尾结点
	L2 = (LinkNode*)malloc(sizeof(LinkNode));     // 创建L2的头结点
	L2->next = NULL;     // 置L2的指针域为NULL
	while (p != NULL) {
		r1->next = p;     // 采用尾插法将p结点（data为ai）插入到L1中
		r1 = p;
		p = p->next;      // 将p移动到下一结点（data为bi）
		// 用q记录当前p的后继结点（ data为a(i+1) )，因为头插法会改变p结点的next指针域
        q = p->next;
		p->next = L2->next;    // 采用头插法将p结点（data为bi）插入到L2中
		L2->next = p;
		p = q;     		  // p结点重新指向a(i+1)结点
	}
	r1->next = NULL;      // 将L1的尾结点的next指针域置为NULL
}
```

例2.7 删除一个单链表L中元素最大的结点（假设这样的结点唯一），插入或删除操作离不开前驱节点pre和当前结点p（一般用p表示）。解题思路：类似数组操作中找最大的值，遍历，用max存储当前最大，时间复杂度为O(n)

```c++
void delMaxNode(LinkNode*& L) {
	LinkNode *p = L->next, *pre = L, *maxp = p, *maxpre = pre;
	// 用p扫描整个单链表，pre始终指向其前驱结点
	while (p != NULL) {
		// 若找到一个更大的结点
		if (maxp->data < p->data) {
			maxp = p;     // 更新maxp和maxpre
			maxpre = pre;
		}
		pre = p;    	  // p、pre同步向后移一个结点
		p = p->next;
	}
	maxpre->next = maxp->next;     // 删除maxp结点并释放其空间
	free(maxp);
}
```

例2.8 将单链表L（至少有一个数据元素结点），递增排序。解题思路：重建L，从原单链表每取一个，遍历新的L，判断应该插入的位置，插入之，时间复杂度为O(n^2)

```c++
bool sort(LinkNode*& L) {
	if (L->next == NULL) {
		return false;     // 若L无数据结点，返回false
	}
	LinkNode *p, *pre, *q;
	p = L->next->next;     	// p指向L的第2个数据结点
	L->next->next = NULL;   // 构造一个只含一个数据结点的有序单链表（一个数据结点一定有序）
	while (p != NULL) {
		q = p->next;     	// q保存p结点后继结点的指针
		pre = L;
		// 注意while里的判断表达式，根据短路定理，&&两边不能颠倒
		// 因为pre->next为空时就要跳出，就不用判断pre->next->data了
		// 若反过来，需要先判断pre->next->data
		// 而当pre->next为空时，先判断时要访问pre->next->data会出错（NULL没有data域）
		while (pre->next != NULL && pre->next->data < p->data) {
			pre = pre->next;   // 在有序单链表中寻找插入p所指结点的前驱结点的位置（pre所指向）
		}
		// 跳出while循环有两种情况：
		// 1）：pre结点小于p，pre->next大于p
		// (因为新单链表是有序递增的，故第一次因pre->next大于等于p而跳出循环时，pre小于p）
		// 2）：pre指向尾结点，pre->next为null
		p->next = pre->next;     // 在pre所指结点之后插入p所指结点
		pre->next = p;
		p = q;     // 扫描原单链表余下的结点
	}
	return true;
}
```

### 3. 双链表（double linked list）

数据类型定义

```c++
// 元素类型
typedef int ElemType;

typedef struct DNode {
	ElemType data;
	struct DNode* prior;    // 前驱结点
	struct DNode* next;     // 后继结点
} DLinkNode;     // 双链表的结点类型
```

建立双链表 头插法

```c++
void CreateListF(DLinkNode*& L, ElemType a[], int n) {
	DLinkNode* s;
	L = (DLinkNode*)malloc(sizeof(DLinkNode));
	L->prior = L->next = NULL;
	for (int i = 0; i < n; ++i) {
		s = (DLinkNode*)malloc(sizeof(DLinkNode));
		s->data = a[i];
		s->next = L->next;     // 将s结点插入到头结点之后
		// 判断p->next是否为NULL，若p->next为NULL，则对其进行->prior运算会抛错
		// 此处是判断L的下一个结点是否为空，即插入第一个结点的情况
		if (L->next != NULL) {
			L->next->prior = s;
		}
		s->prior = L;     // 此处两个语句可替换顺序，不影响结果
		L->next = s;
	}
}
```

建立双链表 尾插法

```c++
void CreateListR(DLinkNode*& L, ElemType a[], int n) {
	L = (DLinkNode*)malloc(sizeof(DLinkNode));
	L->prior = L->next = NULL;
	DLinkNode* r = L;     // r始终指向尾结点，开始时头即是尾
	DLinkNode* s;
	for (int i = 0; i < n; ++i) {
		s = (DLinkNode*)malloc(sizeof(DLinkNode));
		s->data = a[i];
		r->next = s;
		s->prior = r;
		r = s;
	}
	r->next = NULL;
}
```

在双链表中，有些运算（初始化，销毁，判断是否为空，求长度，输出，求某个元素值，按元素值查找）是与单链表中相应的算法相同的，有区别的是插入和删除结点的算法

初始化双链表 InitList(&L) O(1)

```c++
void InitList(DLinkNode*& L) {
	L = (DLinkNode*)malloc(sizeof(DLinkNode));
	L->prior = L->next = NULL;
}
```

销毁双链表 DestroyList(&L) O(n)

```c++
void DestroyList(DLinkNode*& L) {
	DLinkNode *pre = L, *p = L->next;
	while (p != NULL) {
		free(pre);
		pre = p;
		p = p->next;
	}
	free(pre);
}
```

判断双链表是否为空 ListEmpty(L) O(1)

```c++
bool ListEmpty(DLinkNode* L) {
	return L->next == NULL;
}
```

求双链表的长度 ListLength(L) O(n)

```c++
int ListLength(DLinkNode* L) {
	int n = 0;
	DLinkNode* p = L;
	while (p->next != NULL) {
		++n;
		p = p->next;
	}
	return n;
}
```

输出双链表 DispList(L) O(n)

```c++
void DispList(DLinkNode* L) {
	DLinkNode* p = L->next;
	while (p != NULL) {
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}
```

求双链表中第i个元素的值 GetElem(L,i,&e) O(n)

```c++
bool GetElem(DLinkNode* L, int i, ElemType& e) {
	if (i <= 0) {
		return false;
	}
	int j = 0;
	DLinkNode* p = L;
	while (j < i && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;
	} else {
		e = p->data;
		return true;
	}
}
```

按元素值查找位置 LocateElem(L,e) O(n)

```c++
int LocateElem(DLinkNode* L, ElemType e) {
	DLinkNode* p = L->next;
	int i = 1;
	while (p != NULL && p->data != e) {
		++i;
		p = p->next;
	}
	if (p == NULL) {
		return 0;
	} else {
		return i;
	}
}
```

在双链表第i个位置上插入元素 ListInsert(&L,i,e) O(n)

```c++
bool ListInsert(DLinkNode*& L, int i, ElemType e) {
	if (i <= 0) {
		return false;
	}
	int j = 0;
	DLinkNode* p = L;
	// 从0（头结点）开始，寻找第i-1个结点
	while (j < i - 1 && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;
	} else {
		DLinkNode* s = (DLinkNode*)malloc(sizeof(DLinkNode));
		s->data = e;
		s->next = p->next;
		// 若p存在后继结点，则修改其前驱指针
		if (p->next != NULL) {
			p->next->prior = s;
		}
		s->prior = p;
		p->next = s;
		return true;
	}
}
```

在双链表中删除第i个结点 ListDelete(&L,i,&e) O(n)

```c++
bool ListDelete(DLinkNode*& L, int i, ElemType& e) {
	if (i <= 0) {
		return false;
	}
	int j = 0;
	DLinkNode *p = L;
	while (j < i - 1 && p != NULL) {
		++j;
		p = p->next;
	}
	if (p == NULL) {
		return false;
	} else {
		// 要删除第i个结点，p是所找到的第i-1个结点
		// q指向要删掉的第i个结点，若为空返回false
		// 不为空，删除之（注意判断第i+1个结点是否为空，从而确定怎么更新指针域信息）
		DLinkNode* q = p->next;
		if (q == NULL) {
			return false;
		}
		e = q->data;
		p->next = q->next;
		if (q->next != NULL) {
			q->next->prior = p;
		}
		free(q);
		return true;
	}
}
```

### 4. 双链表的应用示例

例2.9 将带有头结点的双链表L逆置 O(n)。解题思路：使用头插法，重建L

```c++
void reverse(DLinkNode*& L) {
	DLinkNode *p = L->next, *q;
	L->next = NULL;
	while (p != NULL) {
		q = p->next;
		p->next = L->next;
		if (L->next != NULL) {
			L->next->prior = p;
		}
		L->next = p;
		p->prior = L;
		p = q;
	}
}
```

例2.10 带有头结点的双链表，使其递增有序排列 O(n)。解题思路同例2.8 只是插入结点的操作有些不同

```c++
void sort(DLinkNode*& L) {
	if (L->next == NULL) {
		return;
	}
	DLinkNode* p = L->next->next, *q, *pre;
	L->next->next = NULL;
	while (p != NULL) {
		q = p->next;
		pre = L;
		while (pre->next != NULL && pre->next->data < p->data) {
			pre = pre->next;
		}
		p->next = pre->next;
		if (pre->next != NULL) {
			pre->next->prior = p;
		}
		pre->next = p;
		p->prior = pre;
		p = q;
	}
}
```

### 5. 循环链表（circular linked list）

循环链表是另一种形式的链式存储结构，有单循环链表和双循环链表两种类型。循环链表和非循环链表的结点类型LinkNode和DLinkNode相同，单循环链表的尾next指向头；双循环链表尾next指向头，头prior指向尾。判断表尾结点p的条件是 p->next == L ，而不是 p->next == NULL。

数据类型的声明

```c++
// 元素类型
typedef int ElemType;

typedef struct LNode {
	ElemType data;
	struct LNode* next;
} LinkNode;

typedef struct DNode {
	ElemType data;
	struct DNode* prior;
	struct DNode* next;
} DLinkNode;
```

### 6. 静态链表（static linked list）

存储模式是内存中顺序存储，即数组。使用伪指针curNext（int类型，存储数组索引），其值为后驱元素的数组索引。

数据结构声明

```c++
const int MaxSize = 50;

// 元素类型
typedef int ElemType;

typedef struct SNode {
	ElemType data[MaxSize];
	int curNext;
} StaticNode;
```

## （四）有序表（ordered list）

有序表是一种特殊的线性表，它的元素按顺序排列，递增或递减，算法基本和一般线性表相同，有差别的只是插入算法 ListInset。有序表（逻辑结构）可以用顺序表、链表（存储结构）实现。

这里的实现基于递增有序表，且只实现了与一般线性表不同的算法，使用时请先根据其他的sort算法，将一般线性表递增排序，然后可用这里的算法。

数据类型定义

```c++
// 元素类型
typedef int ElemType;

using dst::_2_2::SqList;
using dst::_2_3::_2_3_2::LinkNode;
```

有序顺序表插入算法 ListInsert(&L,e) O(n)

```c++
void ListInsert(SqList*& L, ElemType e) {
	int i = 0, j;
	// 查找第一个比e大的元素i处
	while (i < L->length && L->data[i] < e) {
		++i;
	}
	// 将从i处的元素开始都向后移一位
	for (j = ListLength(L); j > i; --j) {
		L->data[j] = L->data[j - 1];
	}
	// 将e插入i上
	L->data[i] = e;
	++L->length;
}
```

有序单链表的插入算法 ListInsert(&L,e) O(n)

```c++
void ListInsert(LinkNode*& L, ElemType e) {
	LinkNode* pre = L;
	while (pre->next != NULL && pre->next->data < e) {
		pre = pre->next;
	}
	LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
	s->data = e;
	s->next = pre->next;
	pre->next = s;
}
```

例2.14 有序表归并算法，有两个有序表LA和LB，假设每个有序表和两个有序表间不存在重复元素，不破坏LA和LB，将其合并成一个有序表LC。解题思路：比较当前元素，小的放入LC，再从较小元素所在表取下元素，重复顺序表

```c++
void UnionList(SqList* LA, SqList* LB, SqList*& LC) {
	int i = 0, j = 0, k = 0;     // i、j 分别为LA、LB下标，k为LC中元素个数
	LC = (SqList*)malloc(sizeof(SqList));
	while (i < LA->length && j < LB->length) {
		if (LA->data[i] < LB->data[j]) {
			LC->data[k] = LA->data[i];
			++i;
			++k;
		} else {
			// LA->data[i] > LB->data[j]，前提假设不存在重复
			LC->data[k] = LB->data[j];
			++j;
			++k;
		}
	}
	// LA未扫描完，将其余元素接入到LC末尾
	while (i < LA->length) {
		LC->data[k] = LA->data[i];
		++i;
		++k;
	}
	// LB未扫描完，将其余元素接入到LC末尾
	while (j < LB->length) {
		LC->data[k] = LB->data[j];
		++j;
		++k;
	}
	LC->length = k;
}
```

例2.14 有序表归并算法，有两个有序表LA和LB，假设每个有序表和两个有序表间不存在重复元素，不破坏LA和LB，将其合并成一个有序表LC。解题思路：比较当前元素，小的放入LC，再从较小元素所在表取下元素，重复单链表

```c++
void UnionList(LinkNode* LA, LinkNode* LB, LinkNode*& LC) {
	LinkNode *pa = LA->next, *pb = LB->next, *s, *r;
	LC = (LinkNode*)malloc(sizeof(LinkNode));
	r = LC;     // 为保持原递增顺序不变，LC采用尾插法，初始时尾r和头LC重回
	while (pa != NULL && pb != NULL) {
		if (pa->data < pb->data) {
			// 新开辟空间，避免破坏原有序表
			s = (LinkNode*)malloc(sizeof(LinkNode));
			s->data = pa->data;
			r->next = s;
			r = s;
			pa = pa->next;
		} else {
			s = (LinkNode*)malloc(sizeof(LinkNode));
			s->data = pb->data;
			r->next = s;
			r = s;
			pb = pb->next;
		}
	}
	// 为避免破环原表，不能直接接过去
	while (pa != NULL) {
		s = (LinkNode*)malloc(sizeof(LinkNode));
		s->data = pa->data;
		r->next = s;
		r = s;
		pa = pa->next;
	}
	while (pb != NULL) {
		s = (LinkNode*)malloc(sizeof(LinkNode));
		s->data = pb->data;
		r->next = s;
		r = s;
		pb = pb->next;
	}
	r->next = NULL;
}
```


# 三、栈和队列

## （一）栈（stack）

### aq 泛型栈

```c++
template<typename T, size_t MaxSize = 50>
struct Stack {
	T* data;
	int top;
	Stack() {
		data = new T[MaxSize];
	}
	~Stack() {
		delete[] data;
	}
};

template<typename T, size_t MaxSize>
void InitStack(Stack<T, MaxSize>*& st) {
	st = new Stack<T, MaxSize>();
	st->top = -1;
}

template<typename T, size_t MaxSize>
void DestroyStack(Stack<T, MaxSize>*& st) {
	delete st;
}

template<typename T, size_t MaxSize>
bool StackEmpty(Stack<T, MaxSize>* st) {
	return st->top == -1;
}

template<typename T, size_t MaxSize>
bool Push(Stack<T, MaxSize>*& st, T e) {
	if (st->top == MaxSize - 1) {
		return false;
	}
	++st->top;
	st->data[st->top] = e;
	return true;
}

template<typename T, size_t MaxSize>
bool Pop(Stack<T, MaxSize>*& st, T& e) {
	if (st->top == -1) {
		return false;
	}
	e = st->data[st->top];
	--st->top;
	return true;
}

template<typename T, size_t MaxSize>
bool Pop(Stack<T, MaxSize>*& st) {
	if (st->top == -1) {
	return false;
	}
	--st->top;
	return true;
}

template<typename T, size_t MaxSize>
bool GetTop(Stack<T, MaxSize>* st, T& e) {
	if (st->top == -1) {
		return false;
	}
	e = st->data[st->top];
	return true;
}
```

### 1. 栈的定义

栈顶（top）、栈底（bottom）、进栈或入栈（push）、出栈或退栈（pop）。后进先出（Last In First Out，LIFO）

栈抽象数据类型的定义如下

```c++
ADT Stack {
	数据对象:
		D = { ai | 1 <= i <= n, n >= 0, ai为ElemType类型 } // ElemType 是自定义类型标识符
	数据关系:
		R = { <ai,a(i+1)> | ai, a(i+1) ∈ D, i = 1,...,n-1 }
	基本运算:
        InitStack(&s)
        DestroyStack(&s)
        StackEmpty(s)
        Push(&s,e)
        Pop(&s,&e)
        GetTop(s,&e)
}
```

n个不同的元素通过一个栈产生的出栈序列有C(n)(2n)/(n+1)种

### 2. 栈的顺序存储结构及其基本运算的实现

顺序栈（sequential stack），栈空条件：顶指针为-1； 栈满条件：顶指针为数组最大下标

数据类型定义

```c++
// 元素类型
typedef char ElemType;

// 顺序栈最大数据元素数量，即栈深
const int MaxSize = 50;

typedef struct {
	ElemType data[MaxSize];     // 存放栈中的数据元素
	int top;     // 栈顶指针，即存放栈顶元素在data数组中的下标
} SqStack;     	 // 顺序栈类型
```

初始化栈 InitStack(&s) O(1)

```c++
void InitStack(SqStack*& s) {
	s = (SqStack*)malloc(sizeof(SqStack));
	s->top = -1;     栈顶指针置为-1
}
```

销毁栈 DestroyStack(&s) O(1)

```c++
void DestroyStack(SqStack*& s) {
	free(s);
}
```

判断栈是否为空 StackEmpty(s)

```c++
bool StackEmpty(SqStack* s) {
	return (s->top == -1);
}
```

进栈 Push(&s,e) O(1)

```c++
bool Push(SqStack*& s, ElemType e) {
	// 栈满，返回false
	if (s->top == MaxSize - 1) {
		return false;
	}
	++s->top;
	s->data[s->top] = e;
	return true;
}
```

出栈 Pop(&s,&e) O(1)

```c++
bool Pop(SqStack*& s, ElemType& e) {
	// 栈空，返回false
	if (s->top == -1) {
		return false;
	}
	e = s->data[s->top];
	--s->top;
	return true;
}
```

取栈顶元素 GetTop(s,&e) O(1)

```c++
bool GetTop(SqStack* s, ElemType& e) {
	// 栈空，返回false
	if (s->top == -1) {
		return false;
	}
	e = s->data[s->top];
	return true;
}
```

例3.4 利用顺序栈判断一个字符串是否为对称串

```c++
bool symmetry(ElemType str[]) {
	int i;
	ElemType e;
	SqStack* st;
	InitStack(st);     // 初始化栈
	// 将str中所有元素进栈
	for (i = 0; str[i] != '\0'; ++i) {
		Push(st, str[i]);
	}
	for (i = 0; str[i] != '\0'; ++i) {
		Pop(st, e);
		// 若e与当前串字符不同表示不是对称串，返回false
		if (str[i] != e) {
			DestroyStack(st);
			return false;
		}
	}
	DestroyStack(st);
	return true;     // 遍历完，未发现不同，即对称，返回true
}
```

共享栈（用一个数组来实现两个栈）

```c++
typedef struct {
	ElemType data[MaxSize];
	int top1, top2;
} DStack;
```

### 3. 栈的链式存储结构及其基本运算的实现

链栈（linked stack），栈顶操作都是在单链表头进行操作（进栈用头插法）。栈空条件：s->next为NULL

数据类型定义

```c++
// 元素类型
typedef char ElemType;

typedef struct linknode {
	ElemType data;     // 数据域
	struct linknode* next;     // 指针域
} LinkStNode;     // 链栈结点类型
```

初始化栈 InitStack(&s) O(1)

```c++
void InitStack(LinkStNode*& s) {
	s = (LinkStNode*)malloc(sizeof(LinkStNode));
	s->next = NULL;
}
```

销毁栈 DestroyStack(&s) O(1)

```c++
void DestroyStack(LinkStNode*& s) {
	LinkStNode *pre = s, *p = s->next;     // pre指向头结点，p指向首结点
	// 循环到p为空
	while (p != NULL) {
		free(pre);     // 释放pre结点
		pre = p;       // pre、p同步后移
		p = p->next;
	}
	free(pre);     // 此时pre指向尾结点，释放之
}
```

判断栈是否为空 StackEmpty(s)

```c++
bool StackEmpty(LinkStNode* s) {
	return (s->next == NULL);
}
```

进栈 Push(&s,e) O(1)

```c++
void Push(LinkStNode*& s, ElemType e) {
	LinkStNode* p = (LinkStNode*)malloc(sizeof(LinkStNode));
	p->data = e;
	p->next = s->next;     // 将p插入作为首结点
	s->next = p;
}
```

出栈 Pop(&s,&e) O(1)

```c++
bool Pop(LinkStNode*& s, ElemType& e) {
	// 栈空，返回false
	if (s->next == NULL) {
		return false;
	}
	LinkStNode* p = s->next;     // p指向首结点
	e = p->data;     		// 提取首结点的值
	s->next = p->next;      // 删除首结点，并释放其空间
	free(p);
	return true;
}
```

取栈顶元素 GetTop(s,&e) O(1)

```c++
bool GetTop(LinkStNode* s, ElemType& e) {
	// 栈空，返回false
	if (s->next == NULL) {
		return false;
	}
	e = s->next->data;     // 提取首结点的值
	return true;
}
```

例3.5 判断输入的表达式中括号是否配对。解题思路：从左到右扫描表达式，遇到 ( 进栈；遇到 ) 时，若栈顶为 ( ，一起出栈，否则返回false

```c++
bool Match(char exp[], int length) {
	int i = 0;
	char e;
	bool match = true;
	LinkStNode* st;
	InitStack(st);
	// 扫描exp中所有字符
	while (i < length && match) {
		// 当前字符为 ( ，将其进栈
		if (exp[i] == '(') {
			Push(st, exp[i]);
		} else if (exp[i] == ')') {
			// 当前字符为 )
			if (GetTop(st, e) == true) {
				// 成功提取栈顶元素，即栈非空
				if (e != '(') {
					match = false;     // 栈顶元素不为 ( 时，表示不匹配
				} else {
					Pop(st, e);     // 栈顶元素为 ( ,出栈
				}
			} else {
				match = false;      // 无法取栈中元素表示不匹配
			}
		}
		++i;
	}
	// 栈非空表示不匹配
	if (!StackEmpty(st)) {
		match = false;
	}
	DestroyStack(st);
	return match;
}
```

### 4. 栈的应用

#### (1) 简单表达式求值

将算术表达式转换成后缀表达式：（利用操作符栈），原理：先执行的运算符先出栈

1. 从左到右扫描算术表达式，遇到操作数直接保存到后缀表达式中，每个数字后加一个 # 以分隔
2. 遇到左括号 ( ，表示一个子表达式开始，左括号直接压入栈顶
3. 继续扫描，如果遇到运算符op为右括号 ) ，表示子表达式结束，依次出栈op放入后缀表达式，直到栈顶为左括号 ( ，将左括号出栈
4. 继续扫描，当op是其他运算符，而栈顶是左括号 ( 或栈空，直接入栈
5. 其他情况，如果遇到运算符op，优先级高于栈顶元素，则压入栈
6. 否则依次出栈放入后缀表达式中，直到满足op优先级高于栈顶运算符，然后op进栈

对后缀表达式求值：（利用操作数栈），从左到右扫描后缀表达式，遇到操作数直接压入栈顶，遇到操作符op，从栈中一次弹出两个数right和left，执行left op right，结果压入栈顶，重复。

将算术表达式转换成后缀表达式（form exp to postexp），伪代码描述：

```
while (从exp中读取字符ch, ch != '\0') {
	ch 为数字: 将后续所有数字依次存放的postexp中，并以#标识数字串结束;
	ch 为左括号'(': 将左括号压入栈顶
	ch 为右括号')': 将opStack中出栈时遇到的第一个左括号'('以前的运算符依次出栈并放到postexp中，然后左括号出栈
	ch 为'+'或'-': 出栈运算符并放到postexp中，直到栈顶为'('或栈空，然后ch进栈
	ch 为'*'或'/': 出栈运算符并放到postexp中，直到栈顶为'('、'+'、'-'为栈空，然后ch进栈 
}
若exp扫描完毕，将opStack中所有运算符依次出栈，放到postexp中
```

```c++
void trans(char* exp, char postexp[]) {
	char e;
	Stack<char>* opStack;     // 定义运算符栈指针
	InitStack(opStack);       // 初始化运算符栈
	int i = 0;     			  // i作为后缀表达式postexp的下标
	// 算术表达式exp未扫描完时循环
	while (*exp != '\0') {
		switch (*exp) {
		case '(':     // 判定为左括号 (
			Push(opStack, '(');     // 左括号进栈
			exp++;
			break;
		case ')':     // 判定为右括号 )
			Pop(opStack, e);      // 出栈元素e
			// 出栈元素e不为 ( 时循环
			while (e != '(') {
				postexp[i++] = e;     // 将e放入到后缀表达式
				Pop(opStack, e);
			}
			exp++;
			break;
		case '+':     // 判断为加号或减号 + -
		case '-':
			// 栈不为空循环
			while (!StackEmpty(opStack)) {
				GetTop(opStack, e);     // 取栈顶元素e
				if (e != '(') {
					// e不是左括号，放入postext中，并出栈
					postexp[i++] = e;
					Pop(opStack, e);
				} else {
					break;     // e为左括号时退出循环
				}
			}
			Push(opStack, *exp);     将 '+'或'-'进栈
			exp++;
			break;
		case '*':
		case '/':
			while (!StackEmpty(opStack)) {
				GetTop(opStack, e);
				// 将栈顶的 * 或 / 出栈，放入postexp
				if (e == '*' || e == '/') {
					postexp[i++] = e;
					Pop(opStack, e);
				} else {
					break;     // 栈顶不为 * 或 / 时退出循环
				}
			}
			Push(opStack, *exp);
			exp++;
			break;
		default:     // 处理数字字符
			// 判断为数字字符
			while (*exp >= '0' && *exp <= '9') {
				postexp[i++] = *exp;
				exp++;
			}
			postexp[i++] = '#';     // 用#标识一个数字串结束
		}
	}
	// 栈不为空时循环，取出元素e，放入postexp中
	while (!StackEmpty(opStack)) {
		Pop(opStack, e);
		postexp[i++] = e;
	}
	postexp[i++] = '\0';     // 给postexp表达式加上结束标识符
	DestroyStack(opStack);   // 销毁栈
}
```

后缀表达式求值，依次扫描，遇到操作数压入栈顶，遇到操作符op弹出两个数，计算，压入栈顶，重复。

```c++
bool compvalue(char* postexp, float& result) {
	float right, left, value, temp;
	Stack<float>* opNum;
	InitStack(opNum);
	// postexp未扫描完时循环
	while (*postexp != '\0') {
		// 判定为操作符，计算，入栈
		switch (*postexp) {
		case '+':
			Pop(opNum, right);
			Pop(opNum, left);
			value = left + right;
			Push(opNum, value);
			break;
		case '-':
			Pop(opNum, right);
			Pop(opNum, left);
			value = left - right;
			Push(opNum, value);
			break;
		case '*':
			Pop(opNum, right);
			Pop(opNum, left);
			value = left * right;
			Push(opNum, value);
			break;
		case '/':
			Pop(opNum, right);
			Pop(opNum, left);
			if (right == 0) {
				return false;
			}
			value = left / right;
			Push(opNum, value);
			break;
		default:     // 处理数字字符
			temp = 0;
			// 将连续的数字转换成对应的数值存放到temp中
			while (*postexp >= '0' && *postexp <= '9' && *postexp != '#') {
				temp = 10 * temp + (*postexp - '0');
				postexp++;
			}
			Push(opNum, temp);     将数值temp进栈
			break;
		}
		postexp++;
	}
	GetTop(opNum, result);
	DestroyStack(opNum);
	return true;
}
```

#### (2) 求解迷宫问题（深度优先搜索）

给定一个 M x N 的迷宫，求一条从指定入口到出口的迷宫路径（非最短路径），用二维数组表示迷宫，1不可走，0可走，-1为相邻来的路径不可走。一个方块(i,j)从上方开始顺时针编号 0 1 2 3 表示 上 右 下 左 四个方向，当前位置进栈，判断是否可走，可走进栈，不可走退栈，重复直到出口。

迷宫例子

```c++
const int M = 8;
const int N = 8;
int mg[M + 2][N + 2] = {
	{1,1,1,1,1,1,1,1,1,1}, {1,0,0,1,0,0,0,1,0,1}, 
    {1,0,0,1,0,0,0,1,0,1}, {1,0,0,0,0,1,1,0,0,1},
	{1,0,1,1,1,0,0,0,0,1}, {1,0,0,0,1,0,0,0,0,1}, 
    {1,0,1,0,0,0,1,0,0,1}, {1,0,1,1,1,0,1,1,0,1},
	{1,1,0,0,0,0,0,0,0,1}, {1,1,1,1,1,1,1,1,1,1}
};
```

数据结构定义

```c++
typedef struct {
	int i;     // 方块行号
	int j;     // 方块列号
	int dire;  // 下一相邻可走方块号 0 1 2 3
} Box;     // 方块类型

using dst::_3_1::aq_3_1::Stack;
typedef Stack<Box> StType;     // 引用泛型类
const int MaxSize = 50;    	   // 代表从入口到出口的长度，即方块的个数
```

求解迷宫中从入口(xi,yi)到出口(xe,ye)的一条迷宫路径的伪代码过程如下：

```
将入口(xi,yi)进栈（其初始方块位置设置为-1）;
mg[xi][yi] = -1;
while (栈不空) {
	取栈顶方块(i,j,di);
	if ((i,j)时出口(xe,ye)) {
		输出栈中的全部方块构成的一条迷宫路径;
		return true;
	}
	查找(i,j,di)的下一个相邻的可走方块;
	if (找到一个相邻可走方块) {
		该方块为(i1,j1),对应方位d;
		将栈顶方块的di设置为d;
		(i1,j1,-1)进栈;
		mg[i1][j1] = -1;
	}
	if (没有找到(i,j,di)的任何相邻的可走方块) {
		将(i,j,di)出栈;
		mg[i][j] = 0;
	}
}
return false;
```

```c++
bool mgpath(int xi, int yi, int xe, int ye) {
	// 求解路径为(xi,yi) -> (xe,ye)
	Box e;
	int i, j, di, i1, j1;
	bool find;
	StType* st;     // 定义并初始化栈
	InitStack(st);
	e.i = xi; e.j = yi; e.dire = -1;     // 设置e为入口
	Push(st, e);
	mg[xi][yi] = -1;     // 将入口的迷宫值置为-1，避免重复走到该方块
	while (!StackEmpty(st)) {
		GetTop(st, e);
		i = e.i; j = e.j; di = e.dire;
		// 找到了出口，输出路径
		if (i == xe && j == ye) {
			int k = 0;
			Box path[MaxSize];
			while (!StackEmpty(st)) {
				Pop(st, e);
				path[k++] = e;
			}
			while (k >= 1) {
				--k;
				printf("\t(%d, %d) ", path[k].i, path[k].j);
				if ((k + 2) % 5 == 0) {
					printf("\n");
				}
			}
			printf("\n");
			DestroyStack(st);
			return true;
		}
    	find = false;
		// 寻找方块(i,j)的下一个相邻可走方块(i1,j1)
		while (di < 4 && !find) {
			++di;
			switch (di) {
			case 0:
				i1 = i - 1; j1 = j; break;
			case 1:
				i1 = i; j1 = j + 1; break;
			case 2:
				i1 = i + 1; j1 = j; break;
			case 3:
				i1 = i; j1 = j - 1; break;
			}
        	// 找到一个相邻可走方块，设find为true
			if (mg[i1][j1] == 0) {
				find = true;
			}
		}
		if (find) {
			// 找到修改栈顶元素信息
			st->data[st->top].dire = di;
			e.i = i1; e.j = j1; e.dire = -1;
			Push(st, e);     // 将相邻可走方块进栈
			mg[i1][j1] = -1;     // 设为-1，避免重新走上
		} else {
			// 没有路径可走，退栈
			Pop(st, e);
			mg[e.i][e.j] = 0;
		}
	}
	DestroyStack(st);
	return false;
}
```

## （二）队列（queue）

### aq 泛型队列

实现基于顺序队列

```c++
template<typename T, size_t MaxSize = 50>
struct Queue {
	T* data;
	int front;
	int rear;
	Queue() {
		data = new T[MaxSize];
	}
	~Queue() {
		delete[] data;
	}
};

template<typename T, size_t MaxSize>
void InitQueue(Queue<T, MaxSize>*& q) {
	q = new Queue<T, MaxSize>();
	q->front = q->rear = -1;
}

template<typename T, size_t MaxSize>
void DestroyQueue(Queue<T, MaxSize>*& q) {
	delete q;
}

template<typename T, size_t MaxSize>
bool QueueEmpty(Queue<T, MaxSize>* q) {
	return q->rear == q->front;
}

template<typename T, size_t MaxSize>
bool enQueue(Queue<T, MaxSize>*& q, T e) {
	if (q->rear == MaxSize - 1) {
		return false;
	}
	++q->rear;
	q->data[q->rear] = e;
	return true;
}

template<typename T, size_t MaxSize>
bool deQueue(Queue<T, MaxSize>*& q, T& e) {
	if (q->front == q->rear) {
		return false;
	}
	++q->front;
	e = q->data[q->front];
	return true;
}
```

### 1. 队列的定义

队头或队首（front）、队尾（rear）、进队或入队（enqueue）、出队或离队（dequeue）。先进先出（First In First Out，FIFO）

队列抽象数据类型的定义如下

```c++
ADT Queue {
	数据对象:
		D = { ai | 1 <= i <= n, n >= 0, ai为ElemType类型 } // ElemType 是自定义类型标识符
	数据关系:
		R = { <ai,a(i+1)> | ai, a(i+1) ∈ D, i = 1,...,n-1 }
	基本运算:
		InitQueue(&q)
		DestroyQueue(&q)
		QueueEmpty(q)
		enQueue(&q,e)
		deQueue(&q,&e)
}
```

### 2. 队列的顺序存储结构及其基本运算的实现

#### (1) 顺序队列

顺序队（sequential queue），队空：front == rear， 队满：rear == MaxSize - 1，会出现判断为队满，但实际队为空的情况，即假溢出（false overflow）。顺序空间存储，出队元素不被覆盖，最多MaxSize-1个元素

数据类型定义

```c++
const int MaxSize = 50;
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];     // 存放队中元素
	int front;     // 队头, 指向头元素的前一个
	int rear;      // 队尾，指向尾元素
} SqQueue;     	   // 顺序队类型
```

初始化队列 InitQueue(&q) O(1)

```c++
void InitQueue(SqQueue*& q) {
	q = (SqQueue*)malloc(sizeof(SqQueue));
	q->front = q->rear = -1;
}
```

销毁队列 DestroyQueue(&q) O(1)

```c++
void DestroyQueue(SqQueue*& q) {
	free(q);
}
```

判断队列是否为空 QueueEmpty(q) O(1)

```c++
bool QueueEmpty(SqQueue* q) {
	return (q->front == q->rear);
}
```

进队列 enQueue(&q, e) O(1)

```c++
bool enQueue(SqQueue*& q, ElemType e) {
	if (q->rear == MaxSize - 1) {
		return false;     // 队满返回false
	}
	++q->rear;
	q->data[q->rear] = e;
	return true;
}
```

出队列 deQueue(&q, &e) O(1)

```c++
bool deQueue(SqQueue*& q, ElemType& e) {
	if (q->front == q->rear) {
		return false;     // 队空返回false，此处空为伪空
	}
	++q->front;     // front指向头元素的前一位置
	e = q->data[q->front];
	return true;
}
```

#### (2) 环形队列

环形队列或循环队列（circular queue），逻辑上看成一个环，注意取余运算，队空：front == rear， 队满：(rear + 1) % MaxSize = front。重复利用空间，出队元素可能被覆盖, 最多MaxSize-1个元素

数据类型定义

```c++
const int MaxSize = 50;
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];     // 存放队中元素
	int front;     // 队头, 指向头元素的前一个
	int rear;      // 队尾，指向尾元素
} SqQueue;     // 顺序队类型
```

初始化队列 InitQueue(&q) O(1)

```c++
void InitQueue(SqQueue*& q) {
	q = (SqQueue*)malloc(sizeof(SqQueue));
	q->front = q->rear = 0;
}
```

销毁队列 DestroyQueue(&q) O(1)

```c++
void DestroyQueue(SqQueue*& q) {
	free(q);
}
```

判断队列是否为空 QueueEmpty(q) O(1)

```c++
bool QueueEmpty(SqQueue* q) {
	return (q->front == q->rear);
}
```

进队列 enQueue(&q, e) O(1)

```c++
bool enQueue(SqQueue*& q, ElemType e) {
	if ((q->rear + 1) % MaxSize == q->front) {
		return false;     // 队满返回false
	}
	q->rear = (q->rear + 1) % MaxSize;
	q->data[q->rear] = e;
	return true;
}
```

出队列 deQueue(&q, &e) O(1)

```c++
bool deQueue(SqQueue*& q, ElemType& e) {
	if (q->front == q->rear) {
        return false;     // 队空返回false，此处空为伪空
	}
	q->front = (q->front + 1) % MaxSize;     // front指向头元素的前一位置
	e = q->data[q->front];
	return true;
}
```

#### (3) 用元素个数代替尾指针

例3.7 用元素个数代替尾指针，可存MaxSize个元素，队尾指针计算公式：rear = (front + count) % MaxSize，队空：count == 0， 队满：count == MaxSize

数据类型定义

```c++
const int MaxSize = 50;
typedef int ElemType;

typedef struct {
	ElemType data[MaxSize];
	int front;     // 队头指针，指向头元素的前一个元素
	int count;     // 元素个数
} QuType;     // 环形队列的类型
```

初始化

```c++
void InitQueue(QuType*& qu) {
	qu = (QuType*)malloc(sizeof(QuType));
	qu->front = 0;     // 队头指针设为0
	qu->count = 0;
}
```

销毁队列

```c++
void DestroyQueue(QuType*& qu) {
	free(qu);
}
```

队列是否为空

```c++
bool QueueEmpty(QuType* qu) {
	return (qu->count == 0);
}
```

进队

```c++
bool EnQueue(QuType*& qu, ElemType x) {
	if (qu->count == MaxSize) {
		return false;     // 队满，返回false
	}
	int rear = (qu->front + qu->count) % MaxSize;     // 计算尾指针
	rear = (rear + 1) % MaxSize;
	qu->data[rear] = x;
	++qu->count;
	return true;
}
```

出队

```c++
bool DeQueue(QuType*& qu, ElemType& x) {
	if (qu->count == 0) {
		return false;     // 队空，返回false
	}
	qu->front = (qu->front + 1) % MaxSize;
	x = qu->data[qu->front];
	--qu->count;
	return true;
}
```

### 3. 队列的链式存储结构及其基本运算的实现

#### (1) 第一种实现

头结点包括两个指针：front和rear，数据结点：数据和下一个结点的指针next，队空条件：rear == NULL 或 front == NULL 两种都可，注意判断队空或只有一个元素时的特殊情况

数据类型定义

```c++
// 元素类型
typedef int ElemType;

// 数据结点类型
typedef struct qnode {
	ElemType data;     		// 存放元素
	struct qnode* next;     // 下一个结点指针
} DataNode;

// 头结点类型
typedef struct {
	DataNode* front;     // 指向队列首结点
	DataNode* rear;      // 指向队列尾结点
} LinkQuNode;
```

初始化队列 O(1)

```c++
void InitQueue(LinkQuNode*& q) {
	q = (LinkQuNode*)malloc(sizeof(LinkQuNode));
	q->front = q->rear = NULL;
}
```

销毁队列 O(n)

```c++
void DestroyQueue(LinkQuNode*& q) {
	DataNode* pre = q->front, *p;     // pre指向队首结点
	if (pre != NULL) {
		p = pre->next;     // p指向pre的后继结点
		// p不为空循环
		while (p != NULL) {
			free(pre);     // 释放pre结点
			pre = p;
			p = p->next;   // p和pre同步后移
		}
		free(pre);    // p为空时跳出循环，此时pre指向最后一个结点，释放之
	}
	free(q);     // 最后释放链队的头结点
}
```

判断队列是否为空 O(1)

```c++
bool QueueEmpty(LinkQuNode* q) {
	return (q->rear == NULL);
}
```

进队 O(1)，先创建一个新结点存放数据，进队该结点；若原队列为空，则front和rear都指向新结点；原队列非空，则尾结点的next指向新结点，更新尾结点

```c++
void enQueue(LinkQuNode*& q, ElemType e) {
	DataNode* p = (DataNode*)malloc(sizeof(DataNode));
	p->data = e;
	p->next = NULL;     // 创建新结点并完成赋值操作
	if (q->rear == NULL) {
		q->rear = q->front = p;     // 原队列为空，则头和尾都指向p
	} else {
		q->rear->next = p;     // 原队列非空，在最后插入p（进队）
		q->rear = p;     // 更新尾结点
	}
}
```

出队列 O(1)

```c++
bool deQueue(LinkQuNode*& q, ElemType &e) {
	if (q->rear == NULL) {
		return false;     // 队空，返回false
	}
	DataNode* t = q->front;     // t指向首结点
	if (q->front == q->rear) {
		q->front = q->rear = NULL;     // 原队列就一个结点，则出队后队列为空
	} else {
		q->front = t->next;     // 原队列有两个及以上元素，出队后，更新队首元素
	}
	e = t->data;     // 取出原队列的队首元素的数据
	free(t);
	return true;
}
```

#### (2) 第二种实现

例3.8 不带头结点，只有尾结点，只有数据结点LinkNode，没有头结点，队尾结点的next指向首结点（循环链队）。队空条件：rear == NULL

数据类型定义

```c++
// 元素类型
typedef int ElemType;

// 结点类型
typedef struct LNode {
	ElemType data;
	struct LNode* next;
} LinkNode;
```

初始化算法 O(1)

```c++
void InitQueue(LinkNode*& rear) {
	rear = NULL;
}
```

销毁队列 O(n)

```c++
void DestroyQueue(LinkNode*& rear) {
	if (rear == NULL) {
		return;     // 空队列直接返回
	}
	LinkNode* pre = rear->next, *p;
	if (pre != rear) {
		p = pre->next;
		while (p != rear) {
			free(pre);
			pre = p;
			p = pre->next;
		}
		free(pre);
	}
	free(rear);
}
```

判断队列是否为空 O(1)

```c++
bool queueEmpty(LinkNode* rear) {
	return (rear == NULL);
}
```

进队 O(1)

```c++
void enQueue(LinkNode*& rear, ElemType e) {
	LinkNode *p = (LinkNode*)malloc(sizeof(LinkNode));
	p->data = e;
	if (rear == NULL) {
		p->next = p;     // 原队列为空，改为循环链表
		rear = p;     	 // rear指向新结点
	} else {
		原队列非空
		p->next = rear->next;     // p的next指向首结点
		rear->next = p;     // 当前尾结点的next指向p，即改为循环链队
		rear = p;     		// 尾结点更新尾p
	}
}
```

出队 O(1)

```c++
bool deQueue(LinkNode*& rear, ElemType& e) {
	if (rear == NULL) {
		return false;     // 队空返回false
	}
	if (rear->next == rear) {
		e = rear->data;
		free(rear);
		rear = NULL;      // 原队列只有个一个结点，出队后为空
	} else {
		LinkNode* t = rear->next;     // t指向首结点
		e = t->data;
		rear->next = t->next;     // 原队列有两个或两个以上的结点，去掉首结点
		free(t);
	}
	return true;
}
```

### 4. 队列的应用举例

如果先存入的元素先处理，则采用队列，注意之后是否还需用到出队元素，来选择队列的物理存储实现（原数据是否能覆盖）

#### (1) 求解报数问题

n个人站一排，从左到右依次为1~n，从左到右报数“1 2 1 2 1 2....”，报到1的出列，报到2的立即去到最右边，直到队伍为空，输出出列顺序。接题思路，出队，为1直接出列，为2从最后再进队，不会再用到出队元素，采用循环队列

```c++
// 引用循环队列
using dst::_3_2::_3_2_2::_3_2_2_2::SqQueue;
using dst::_3_2::_3_2_2::_3_2_2_2::ElemType;

// 对应算法如下：
void number(int n) {
	ElemType e;
	SqQueue* q;
	InitQueue(q);
	// 构建初始序列
	for (int i = 1; i <= n; ++i) {
		enQueue(q, i);
	}
	printf("报数出列顺序： ");
	while (!QueueEmpty(q)) {
		deQueue(q, e);     	// 出列一个元素e，报1
		printf("%d ", e);   // 输出其编号
		if (!QueueEmpty(q)) {
			// 队列不为空，再出队一个元素，其报数为2，让其从队尾进队
			deQueue(q, e);
			enQueue(q, e);
		}
	}
	printf("\n");
	DestroyQueue(q);
}
```

#### (2) 求解迷宫问题 （广度优先搜索）

给定一个 M x N 的迷宫，求一条从指定入口到出口的迷宫路径（非最短路径）。用二维数组表示迷宫，1不可走，0可走，-1为相邻来的路径不可走。一个方块(i,j)从上方开始顺时针编号 0 1 2 3 表示 上 右 下 左 四个方向，当前位置(i,j)的相邻可走方块依次进队，出队重复，直到出口。由于会再次用到出队元素，故使用顺序队列

定义数据类型

```c++
// 迷宫例子
const int M = 8;
const int N = 8;
int mg[M + 2][N + 2] = {
	{1,1,1,1,1,1,1,1,1,1}, {1,0,0,1,0,0,0,1,0,1}, 
    {1,0,0,1,0,0,0,1,0,1}, {1,0,0,0,0,1,1,0,0,1},
	{1,0,1,1,1,0,0,0,0,1}, {1,0,0,0,1,0,0,0,0,1}, 
    {1,0,1,0,0,0,1,0,0,1}, {1,0,1,1,1,0,1,1,0,1},
	{1,1,0,0,0,0,0,0,0,1}, {1,1,1,1,1,1,1,1,1,1}
};

// 方块类型
typedef struct {
	int i;
	int j;
	int pre;     // 本路径上前一个方块在队列中的下标
} Box;

// 引用泛型队列
using dst::_3_2::aq_3_2::Queue;
typedef Queue<Box, 100> QuType;
const int MaxSize = 100;
```

辅助方法：输出路径，反向找到最短路径，将该路径上的方块的pre置为-1

```c++
void printPath(QuType* qu, int front) {
	int k = front, j, ns = 0;
	printf("\n");
	do {
		j = k;
		k = qu->data[k].pre;
		qu->data[j].pre = -1;
	} while (k != 0);
	printf("一条迷宫路径如下：\n");
	k = 0;
	// 正向搜索pre为-1的方块，即构成正向的路径
	while (k < MaxSize) {
		if (qu->data[k].pre == -1) {
			++ns;
			printf("\t(%d,%d)", qu->data[k].i, qu->data[k].j);
			if (ns % 5 == 0) {
				printf("\n");
			}
		}
		++k;
	}
	printf("\n");
}
```

算法的伪代码描述如下：

```
将入口(xi,yi)的pre置为-1，并进队;
mg[xi][yi] = -1;
while (队列qu不为空) {
	出队一个方块e，其在队列中的位置是front;
	if (方块e是出口) {
		输出一条迷宫路径;
		return true;
	}
	for (对于方块e的所有相邻的可走方块e1) {
		设置e1的pre为front;
		将方块e1进队;
		将方块e1的迷宫数组的值置为-1;
	}
}
return false;     没有路径，返回false
```

```c++
bool mgpath(int xi, int yi, int xe, int ye) {
	Box e;
	int i, j, dire, i1, j1;
	QuType* qu;     // 声明顺序队列指针qu
	InitQueue(qu);
	e.i = xi; e.j = yi; e.pre = -1;
	enQueue(qu, e);     	// (xi, yi)进队
	mg[xi][yi] = -1;    	// 将其在二维数组中的值置为-1，避免重复搜索
	while (!QueueEmpty(qu)) {
		deQueue(qu, e);
		i = e.i; j = e.j;
		if (i == xe && j == ye) {
			// 找到出口，输出路径
			printPath(qu, qu->front);
			DestroyQueue(qu);
			return true;
		}
		// 扫描当前方块四周的方块，将可走的入队
		for (dire = 0; dire < 4; ++dire) {
			switch (dire) {
			case 0:
				i1 = i - 1; j1 = j; break;
			case 1:
				i1 = i; j1 = j + 1; break;
			case 2:
				i1 = i + 1; j1 = j; break;
			case 3:
				i1 = i; j1 = j - 1; break;
			}
			if (mg[i1][j1] == 0) {
				// 如果相邻方块可走，设置其属性，进队
				// pre指向上一方块在队列的顺序数组中的下标（由于出队，上一方块在队首，但front值为其在实现的数组中的下标位置）
				e.i = i1; e.j = j1; e.pre = qu->front;
				enQueue(qu, e);
				mg[i1][j1] = -1;     // 置为-1避免重复搜索
			}
		}
	}
	DestroyQueue(qu);
	return false;
}
```

3.2.5 双端队列（deque，double-ended queue）
两端都可以进行进队和出队的操作
输入受限的双端队列 和 输出受限的双端队列


# 四、串

## （一）串（sting）的基本概念

串的抽象数据类型描述如下

```c++
ADT String {
	数据对象:
		D = { ai | 1 <= i <= n, n >= 0, ai 为 char 类型 }
	数据关系:
		R = { <ai,a(i+1)> | ai、a(i+1) ∈ D, i = 1,...,n - 1 }
	基本运算:
		// 除引用外，参数串均未变化，即不破坏参数串
		StrAssign(&s, cstr)
        DestroyStr(&s)
        StrCopy(&s,t)
        StrEqual(s,t)
        StrLength(s)
        Concat(s,t)
        SubStr(s,i,len)
        InsStr(s1,i,s2)
        DelStr(s,i,len)
        RepStr(s,i,len,t)
        DispStr(s)
}
```

## （二）串的存储结构

### 1. 串的顺序存储结构

数据类型定义

```c++
// 串的最大长度
const int MaxSize = 50;

// 顺序串类型
typedef struct {
	char data[MaxSize];     // 数据数组
	int length;     // 长度信息
} SqString;
```

生成串 StrAssign(&s,cstr)，将一个C/C++字符串常量cstr（以'\0'字符标识结尾）赋给顺序串s，参数s为引用

```c++
void StrAssign(SqString& s, char cstr[]) {
	int i = 0;
	for (i = 0; cstr[i] != '\0'; ++i) {
		s.data[i] = cstr[i];
	}
	s.length = i;     // 设置串s的长度
}
```

销毁串 DestroyStr(&s)

```c++
void DestroyStr(SqString& s) {}
```

复制 StrCopy(&s,t)

```c++
void StrCopy(SqString& s, SqString t) {
	for (int i = 0; i < t.length; ++i) {
		s.data[i] = t.data[i];
	}
	s.length = t.length;
}
```

判断是否相等 StrEqual(s,t)

```c++
bool StrEqual(SqString s, SqString t) {
	if (s.length != t.length) {
		return false;     // 长度不相等直接返回false
	}
	for (int i = 0; i < s.length; ++i) {
		if (s.data[i] != t.data[i]) {
			return false;     // 有一个不相等时就返回false
		}
	}
	return true;     // 长度相等，且对应字符都相等，返回true
}
```

求串长 StrLength(s)

```c++
int StrLength(SqString s) {
	return s.length;
}
```

连接 Concat(s,t)，返回由两个串s和t连接在一起形成的结果串，不破环原串。没有检查两个串的长度超出最大长度的情况

```c++
SqString ConCat(SqString s, SqString t) {
    SqString str;
    str.length = s.length + t.length;
    for (int i = 0; i < s.length; ++i) {
    	str.data[i] = s.data[i];
    }
    for (int i = 0; i < t.length; ++i) {
    	str.data[s.length + i] = t.data[i];
    }
    return str;
}
```

求子串 SubStr(s, i, len)，返回串s中从第i个字符开始的长度为len的子串，参数不正确时返回空串

```c++
SqString SubStr(SqString s, int i, int len) {
    SqString str;
    str.length = 0;
    if (i <= 0 || i > s.length || len < 0 || i + len - 1 > s.length) {
    	return str;     // 参数不正确时返回空串
    }
    // 注意逻辑序号和数组序号间转换
    for (int k = i - 1; k < i + len - 1; ++k) {
    	str.data[k - i + 1] = s.data[k];
    }
    str.length = len;
    return str;
}
```

子串的插入 InsStr(s1,i,s2)，将s2插入到s1，不破坏原串，创建新串，依次赋值，中间接子串

```c++
SqString InsStr(SqString s1, int i, SqString s2) {
    SqString str;
    str.length = 0;
    // i 为 s1.length 时，表示在 s1 最后插入串 s2，即连接, 可操作，不返回空串
    if (i <= 0 || i > s1.length + 1) {
    	return str;     // 参数不正确时返回空串
    }
    for (int j = 0; j < i - 1; ++j) {
    	str.data[j] = s1.data[j];
    }
    for (int j = 0; j < s2.length; ++j) {
    	str.data[j + i - 1] = s2.data[j];
    }
    for (int j = i - 1; j < s1.length; ++j) {
    	str.data[j + s2.length] = s1.data[j];
    }
    str.length = s1.length + s2.length;
    return str;
}
```

子串的删除 DelStr(s,i,len)，不破换原串，创建新串，依次赋值，若删则跳过

```c++
SqString DelStr(SqString s, int i, int len) {
    SqString str;
    str.length = 0;
    if (i <= 0 || i > s.length || len < 0 || i + len - 1 > s.length) {
    	return str;     // 参数不正确时返回空串
    }
    for (int k = 0; k < i - 1; ++k) {
    	str.data[k] = s.data[k];
    }
    // k从逻辑序号为 第i+len-1（即子序列的最后一个）位置开始，其值正好为下一个元素的数组索引
    for (int k = i + len - 1; k < s.length; ++k) {
    	str.data[k - len] = s.data[k];
    }
    str.length = s.length - len;
    return str;
}
```

子串的替换 RepStr(s,i,len,t)，用t替换s中的子串，不破换原串，创建新串，依次赋值，若替则赋t的值

```c++
SqString RepStr(SqString s, int i, int len, SqString t) {
    SqString str;
    str.length = 0;
    if (i <= 0 || i > s.length || len < 0 || i + len - 1 > s.length) {
    	return str;     // 参数不正确时返回空串
    }
    for (int k = 0; k < i - 1; ++k) {
    	str.data[k] = s.data[k];
    }
    for (int k = 0; k < t.length; ++k) {
    	str.data[k + i - 1] = t.data[k];
    }
    for (int k = i + len - 1; k < s.length; ++k) {
    	str.data[k - len + t.length] = s.data[k];
    }
    str.length = s.length - len + t.length;
    return str;
}
```

输出串 DispStr(s)

```c++
void DispStr(SqString s) {
    if (s.length > 0) {
    	for (int i = 0; i < s.length; ++i) {
    		printf("%c", s.data[i]);
    	}
    	printf("\n");
    }
}
```

例4.1 假设串采用顺序串存储，设计一个算法Strcmp(s,t)按字典顺序比较两个串的大小

```c++
int Strcmp(SqString s, SqString t) {
    int comlen = 0;
    // 求s和t的共同长度
    if (s.length < t.length) {
    	comlen = s.length;
    } else {
    	comlen = t.length;
    }
    // 在共同长度内逐字比较，不同则返回相应值
    for (int i = 0; i < comlen; ++i) {
    	if (s.data[i] > t.data[i]) {
    		return 1;
    	} else if (s.data[i] < t.data[i]) {
    		return -1;
    	}
    }
    // 执行到此处，表明两个字符串在共同长度内相同
    if (s.length == t.length) {
    	return 0;     // 两个字符长度相同，共同字符串相同，返回0
    } else if (s.length > t.length) {
    	return 1;     // 共同长度内相同，但s更长，返回1
    } else {
    	return -1;
    }
}
```

例4.2 假设串采用顺序串存储，设计一个算法求串s中出现的第一个最长的连续相同字符构成的平台

```c++
void LongestString(SqString s, int& index, int& maxlen) {
    index = 0;     // index保存最长平台在s中的开始位置
    maxlen = 1;    // maxlen保存其长度
    int i = 1, start, length;     // length保存局部平台的长度
    while (i < s.length) {
    	start = i - 1;     // start 保存当前查找子串的开始位置
    	length = 1;
    	while (i < s.length && s.data[i] == s.data[i - 1]) {
    		++i;
    		++length;
    	}
    	// 若当前查找平台更长，更新
    	if (maxlen < length) {
    		maxlen = length;
    		index = start;
    	}
    	++i;
    }
}
```

### 2. 串的链式存储结构

数据类型定义

```c++
// 结点类型
typedef struct snode {
	char data;     // 存放字符
	struct snode* next;     // 下一个结点
} LinkStrNode;
```

生成串 StrAssign(&s,cstr)，将一个C/C++字符串常量cstr（以'\0'字符标识结尾）赋给顺序串s，参数s为指针引用，采用尾插法

```c++
void StrAssign(LinkStrNode*& s, char cstr[]) {
    s = (LinkStrNode*)malloc(sizeof(LinkStrNode));     // 初始化串s
    LinkStrNode *p, *r = s;     // r 为尾指针
    for (int i = 0; cstr[i] != '\0'; ++i) {
    	p = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    	p->data = cstr[i];
    	r->next = p;
    	r = p;     // r始终指向尾结点
    }
    r->next = NULL;     // 尾结点的next置为空
}
```

销毁串 DestroyStr(&s)

```c++
void DestroyStr(LinkStrNode*& s) {
    LinkStrNode *pre = s, *p = s->next;
    while (p != NULL) {
    	free(pre);
    	pre = p;
    	p = pre->next;
    }
    free(pre);
}
```

复制 StrCopy(&s,t)

```c++
void StrCopy(LinkStrNode*& s, LinkStrNode* t) {
    s = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    LinkStrNode *p = t->next, *r = s, *q;
    while (p != NULL) {
    	q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    	q->data = p->data;
    	r->next = q;
    	r = q;
    	p = p->next;
    }
    r->next = NULL;
}
```

判断是否相等 StrEqual(s,t)

```c++
bool StrEqual(LinkStrNode* s, LinkStrNode* t) {
    LinkStrNode *p = s->next, *q = t->next;
    while (p != NULL && q != NULL && p->data == q->data) {
    	p = p->next;
    	q = q->next;
    }
    if (p == NULL && q == NULL) {
    	return true;
    } else {
    	return false;
    }
}
```

求串长 StrLength(s)

```c++
int StrLength(LinkStrNode* s) {
    int i = 0;
    LinkStrNode* p = s->next;
    while (p != NULL) {
    	++i;
    	p = p->next;
    }
    return i;
}
```

连接 Concat(s,t)，返回由两个串s和t连接在一起形成的结果串，不破环原串

```c++
LinkStrNode* ConCat(LinkStrNode* s, LinkStrNode* t) {
    LinkStrNode* str = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    LinkStrNode *p = s->next, *r = str, *q;
    while (p != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next = q;
        r = q;
        p = p->next;
    }
    p = t->next;     //换串，再连一遍
    while (p != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next = q;
        r = q;
        p = p->next;
    }
    r->next = NULL;
    return str;
}
```

求子串 SubStr(s, i, len)，返回串s中从第i个字符开始的长度为len的子串，参数不正确时返回空串

```c++
LinkStrNode* SubStr(LinkStrNode* s, int i, int len) {
    LinkStrNode* str = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    str->next = NULL;
    if (i <= 0 || i > StrLength(s) || len < 0 || i + len - 1 > StrLength(s)) {
    	return str;     // 参数不正确时返回空串
    }
    LinkStrNode *r = str, *p = s->next, *q;
    // 让p指向s中的第i个结点
    for (int k = 1; k < i; ++k) {
    	p = p->next;
    }
    for (int k = 1; k <= len; ++k) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next = q;
        r = q;
        p = p->next;
    }
    r->next = NULL;
    return str;
}
```

子串的插入 InsStr(s1,i,s2)，将s2插入到s1，不破坏原串，创建新串，依次赋值，中间接子串

```c++
LinkStrNode* InsStr(LinkStrNode* s1, int i, LinkStrNode* s2) {
    LinkStrNode* str = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    str->next = NULL;
    if (i <= 0 || i > StrLength(s1) + 1) {
    	return str;
    }
    LinkStrNode *p1 = s1->next, *p2 = s2->next, *r = str, *q;
    for (int k = 1; k < i; ++k) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p1->data;
        r->next = q;
        r = q;
        p1 = p1->next;
    }
    while (p2 != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p2->data;
        r->next = q;
        r = q;
        p2 = p2->next;
    }
    while (p1 != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p1->data;
        r->next = q;
        r = q;
        p1 = p1->next;
    }
    r->next = NULL;
    return str;
}
```

子串的删除 DelStr(s,i,len)，不破换原串，创建新串，依次赋值，若删则跳过

```c++
LinkStrNode* DelStr(LinkStrNode* s, int i, int len) {
    LinkStrNode* str = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    str->next = NULL;
    if (i <= 0 || i > StrLength(s) || len < 0 || i + len - 1 > StrLength(s)) {
    	return str;     // 参数不正确时返回空串
    }
    LinkStrNode *p = s->next, *r = str, *q;
    for (int k = 1; k < i; ++k) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next = q;
        r = q;
        p = p->next;
    }
    for (int k = 0; k < len; ++k) {
    	p = p->next;
    }
    while (p != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p->data;
        r->next = q;
        r = q;
        p = p->next;
    }
    r->next = NULL;
    return str;
}
```

子串的替换 RepStr(s,i,len,t)，用t替换s的子串，不破换原串，创建新串，依次赋值，若替则赋t的值

```c++
LinkStrNode* RepStr(LinkStrNode* s, int i, int len, LinkStrNode* t) {
    LinkStrNode* str = (LinkStrNode*)malloc(sizeof(LinkStrNode));
    str->next = NULL;
    if (i <= 0 || i > StrLength(s) || len < 0 || i + len - 1 > StrLength(s)) {
    	return str;     // 参数不正确时返回空串
    }
    LinkStrNode *p1 = s->next, *p2 = t->next, *r = str, *q;
    for (int k = 1; k < i; ++k) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p1->data;
        r->next = q;
        r = q;
        p1 = p1->next;
    }
    for (int k = 0; k < len; ++k) {
        p1 = p1->next;
    }
    while (p2 != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p2->data;
        r->next = q;
        r = q;
        p2 = p2->next;
    }
    while (p1 != NULL) {
        q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
        q->data = p1->data;
        r->next = q;
        r = q;
        p1 = p1->next;
    }
    r->next = NULL;
    return str;
}
```

输出串 DispStr(s)

```c++
void DispStr(LinkStrNode* s) {
    LinkStrNode* p = s->next;
    while (p != NULL) {
        printf("%c", p->data);
        p = p->next;
    }
    printf("\n");
}
```

例4.3 链串中，将"ab"改为"xyz"

```c++
void Repl(LinkStrNode*& s) {
    LinkStrNode *p = s->next, *q;
    bool find = false;
    while (p != NULL && p->next != NULL && !find) {
        if (p->data == 'a' && p->next->data == 'b') {
            p->data = 'x';
            p->next->data = 'z';
            q = (LinkStrNode*)malloc(sizeof(LinkStrNode));
            q->data = 'y';
            q->next = p->next;
            p->next = q;
            find = true;
        } else {
        	p = p->next;
        }
    }
}
```

## （三）串的模式匹配（pattern matching）

目标串（target string）、模式串（pattern string），模式匹配成功是指在目标串s中找到了一个模式串t，返或t的第一个元素在s中出现的物理下标

### 1. Brute-Force（暴力）算法

O(m × n)

```c++
// 引入字符串类型，顺序存储
using dst::_4_2::_4_2_1::SqString;

// 算法如下：
int BF(SqString s, SqString t) {
    int i = 0, j = 0;
    // 两个串都没有扫描完时循环
    while (i < s.length && j < t.length) {
        if (s.data[i] == t.data[j]) {
            ++i;     // 当比较的两个字符相等
            ++j;     // i j 都后移一位，来比较下一个
        } else {
            i = i - (j - 1);     // 当比较的两个字符不同，s串回溯到与t串开头处平行的地方
            j = 0;     // t串回到开头处
        }
    }
	if (j >= t.length) {
		return i - t.length;     // j超出t的边界，表示t是s的子串，返回t在s中的物理索引位置
    } else {
        return -1;     // 返回-1，表示模式匹配失败
    }
}
```

### 2. KMP算法

O(m + n)，从模式串t中，提取出加速匹配的有用信息，以消除主串的指针回溯。对于t串中的一个字符tj，tj的前一个字符向前最多k个，t从开头向后最多k个，即，tj之前的串两端，各有k个元素（k < j)，他们完全相同。

用 back[j] = k 来表示，t串每个位置j上都有一个k的信息，构成一个back[]回退数组：

- back[j] = -1, j 为 0 时
- back[j] = k, j之前，两端存在k个元素相同
- back[j] = 0, 其他情况

匹配时遇到不相等的ij处时，利用back[]信息消除主串的回溯，而使用模式串右滑。时间复杂度为 O(m + n)，当所有back[]值都为0时，退化成BF算法

数据类型定义

```c++
// 引入字符串类型（sequential string），最大长度
using dst::_4_2::_4_2_1::SqString;
using dst::_4_2::_4_2_1::MaxSize;
```

由模式串来求back[]回退数组
1. back[0] = -1, back[1] = 0
2. 如果 back[j] = k, 表示有 "t0 t1 ... t(k-1)" == "t(j-k) t(j-k+1) ... t(j-1)"
  1. tk == tj，即 "t0 t1 ... t(k-1) tk" == "t(j-k) t(j-k+1) ... t(j-1) tj", 显然 back[j + 1] = k + 1
  2. tk != tj，说明tj（包含tj）之前不存在长度为back[j] + 1的子串和开头字符起的子串相同，那么是否存在一个短一些的子串
  3. 此时令 k = back[k] 回退，下一步将 tj 与 tk 比较，可以此类推直到找到更短的子串
  4. 或直接到开头，不存在更短子串（此时，back[j+1] = 0)

```c++
void getBack(SqString t, int back[]) {
    int j = 0, k = -1;     // j扫描目标串t， k来记录t[j]之前与t开头相同的字符的个数
    back[0] = -1;
    // 扫描一遍，求目标串t所有位置的back值
    while (j < t.length - 1) {
        // k为-1表示t回退到开头处，或字符相等
        if (k == -1 || t.data[j] == t.data[k]) {
            ++j;     // j 和 k 依次移动到下一个字符
            ++k;
            back[j] = k;
        } else {
            k = back[k];     // k 回退
        }
    }
}
```

KMP算法的匹配过程如下：

```c++
i = 0, j = 0;
while (s和t都没扫描完) {
	if (j == -1 或 i j 所指字符相等) {
		i j 分别增加一;
	} else {
		i不变，j回退到back[j]，即模式串右滑;
	}
}
if (j超界) {
	返回 i-t 的长度;
} else {
	返回 -1;
}
```

```c++
int KMPIndex(SqString s, SqString t) {
    int back[MaxSize];
    getBack(t, back);
    int i = 0, j = 0;
    while (i < s.length && j < t.length) {
        if (j == -1 || s.data[i] == t.data[j]) {
            ++i;
            ++j;
        } else {
            j = back[j];
        }
	}
	if (j >= t.length) {
        return i - t.length;
	} else {
        return -1;
    }
}
```

### 3. 改进的KMP算法 O(m + n)

上一节中所得到的 back[] 数组存在缺陷，当目标串中的字符 si != tj 时，如果 tj == t(back[j]) == tk 时，si 也一定不等于 tk， 此时将 j 回退为 back[j] = k 也无法匹配；用 backval[] 来修正 back[]，在上述情况下（tj == t(back[j]) == tk），直接使 backval[j] = back[back[j]]。其他情况，与之前一样，backval[0] = -1, backval[j] = back[j]

由目标串t求出backval[]回退数组

```c++
void getBackVal(SqString t, int backval[]) {
    int j = 0, k = -1;
    backval[0] = -1;
    while (j < t.length) {
        if (k == -1 || t.data[j] == t.data[k]) {
            ++j;
            ++k;
    		if (t.data[j] != t.data[k]) {
    			backval[j] = k;
    		} else {
    			backval[j] = backval[k];     // backval[k] 即 backval[backval[j]]
    		}
    	} else {
    		k = backval[k];
    	}
    }
}
```

改进后的KMP算法

```c++
int KMPIndexVal(SqString s, SqString t) {
    int backval[MaxSize];
    getBackVal(t, backval);
    int i = 0, j = 0;
    while (i < s.length && j < t.length) {
    	if (j == -1 || s.data[i] == t.data[j]) {
    		++i;
    		++j;
    	} else {
    		j = backval[j];
    	}
    }
    if (j >= t.length) {
    	return i - t.length;
    } else {
    	return -1;
    }
}
```

# 五、递归

## （一）什么是递归（recursion）

直接递归（direct recursion）、间接递归（indirect recursion）；尾递归（tail recursion）；递归出口（recursive exit）、递归体（recursive body）；递归链（链长即深度）、递归树（树高即深度）；递归与数学归纳法

## （二）栈和递归

栈帧（stack frame），递归转换成非递归：借助栈保存状态，注意转换成栈后的入退栈顺序

## （三）递归算法的设计

### 1. 汉诺塔（Hanoi Tower）

描述：从上到下，从小到大，从1到n，在塔座X上，移动到Z上，要求大的必须在小的下面，可借助Y，最终顺序不变。解题思路：

1. 将X塔上的n-1个借助Z移动到Y上 Hanoi(n-1, x, z, y)

2. 将X上最后一个最大的移到Z上 Move(n, x, z)
3. 再将Y上的n-1个借助X塔移动到Z塔上 Hanoi(n-1, y, x, z)

重复上述步骤，直到 n == 1，即剩下最后一个。如果一共有n个盘片，则需要2^n-1次移动

递归算法实现汉诺塔

```C++
// 移动一个塔盘函数
void Move(int no, char from, char dest) {
	printf("第 %d 个盘片： %c  ==>  %c \n", no, from, dest);
}

// 递归算法实现汉诺塔
void Hanoi(int n, char from, char help, char dest) {
    if (n == 1) {
    	Move(n, from, dest);     // 只有一个盘片，能够直接移动到目标塔座
    } else {
        Hanoi(n - 1, from, dest, help);
        Move(n, from, dest);
        Hanoi(n - 1, help, from, dest);
    }
}
```

非递归算法实现汉诺塔，用栈帧存储调用信息，借助泛型栈，栈深开到100，最多能处理约30左右个盘片，将 Hanoi(n, form, help, dest)进栈，栈非空是循环。出栈一个元素，若可直接移动，则指向Move，否则，分解成n-1的信息，按如下顺序进栈：Hanoi(n-1, help, from, dest)、Move(n, from, dest)、Hanoi(n-1, from, dest, help)

```C++
// 栈帧存储函数参数调用信息
typedef struct {
    int n;     // 盘片个数
    char from, help, dest;     // 3个塔座
    bool canMove;     // 能否直接移动
} ParamInfo;

// 泛型栈
typedef dep::Stack<ParamInfo, 100> StackType;

// 移动一个塔盘函数
void Move(int no, char from, char dest) {
	printf("第 %d 个盘片： %c  ==>  %c \n", no, from, dest);
}

// 非递归算法实现汉诺塔
void Hanoi(int n, char from, char help, char dest) {
    if (n <= 0) {
    	return;     // 参数错误时直接返回
    }
    StackType* stateStack;
    InitStack(stateStack);
    ParamInfo e, toDest, toMove, toHelp;     // 存储函数参数调用信息
    e.n = n; e.from = from; e.help = help; e.dest = dest; e.canMove = false;
    Push(stateStack, e);     // 移动n个盘片的信息进栈
    // 栈不为空循环
    while (!StackEmpty(stateStack)) {
    	Pop(stateStack, e);     // 从栈顶出栈一个函数调用参数信息
    	// 若不能直接移动，即非最底的，分解
    	if (e.canMove == false) {
    		toDest.n = e.n - 1; toDest.from = e.help; toDest.help = e.from; toDest.dest = e.dest;
   			if (toDest.n == 1) {
    			toDest.canMove = true;     // 为最后一个盘片时，可以直接移动
    		} else {
    			toDest.canMove = false;
    		}
    		Push(stateStack, toDest);     // 进栈 Hanoi(n-1, help, from, dest)
    		toMove.n = e.n; toMove.from = e.from; toMove.help = e.help; toMove.dest = e.dest; toMove.canMove = true;
    		Push(stateStack, toMove);     // 进栈 Move(n, from, dest)
    		toHelp.n = e.n - 1; toHelp.from = e.from; toHelp.help = e.dest; toHelp.dest = e.help;
    		if (toHelp.n == 1) {
    			toHelp.canMove = true;    // 为最后一个盘片时，可以直接移动
    		} else {
    			toHelp.canMove = false;
    		}
    		Push(stateStack, toHelp);     // 进栈 Hanoi(n-1, form, dest, help)
    	} else {
    		// 能直接移动
    		Move(e.n, e.from, e.dest);
    	}
    }
    DestroyStack(stateStack);     // 销毁栈
}
```


# 六、数组和广义表

## （一）数组（array）

数组的抽象数据类型描述如下：

```c++
ADT Array {
    数据对象:
    	D = { aj1,j2,...,jd | ji = 1,...,bi, i = 1, 2,...,d }     // 第i维的长度为bi
    数据关系:
        R = { r1, r2,..., rd }
        ri = { <aj1...ji...jd, aj1...(ji+1)...jd> | 1 <= jk <= bk 且 k != i, 1 <= ji <= bi - 1, i = 2,...,d }
    基本运算:
        InitArray(&A);
        DestroyArray(&A);
        Value(A, index1, index2, ..., indexd);
        Assign(A, e, index1, index2, ..., indexd);
}
```

以下公式据采用逻辑序号，Loc表示取地址运算， 每个元素占用 k 各存储单元。物理序号（C/C++中）等于逻辑序号减一，即将 i-1 换成 i 即表示物理序号：

- 维数组的存储结构：Loc(ai) = Loc(a1) + (i - 1) * k
- 二维数组(M x N)的按行优先存放：Loc(ai,j) = Loc(a1,1) + [ (i - 1) * n + (j - 1) ] * k
- 二维数组(M x N)的按列优先存放：Loc(ai,j) = Loc(a1,1) + [ (j - 1) * m + (i - 1) } * k

特殊矩阵的压缩存储，对称矩阵，上下三角矩阵，对角矩阵。用一个一维线性表（一维数组）B[0,1,...,k,...] 存储需要存储的二维矩阵中的元素

对称矩阵中 k 与 i j 的关系：

- k = i * (i + 1) / 2 + j, i >= j 下三角
- k = j * (j + 1) / 2 + i, i < j 上三角

三角矩阵中 k 与 i j 的关系：

- k = i * (2n - i + 1) / 2 + j - i, i <= j 上三角中
- k = n * (n + 1) / 2, i > j

三角矩阵中 k 与 i j 的关系：

- k = i * (i + 1) / 2 + j, i >= j 下三角
- k = n * (n + 1) / 2, i < j

## （二）稀疏矩阵（sparse matrix）

非零元素的个数远小于元素总个数的矩阵

稀疏矩阵的压缩，只存储其非零元素，由于其非零元素分布没由规律，故还需存储非零元素的位置信息

### 1. 稀疏矩阵的三元组表示

用一个三元组（3-tuples）来表示一个非零元素，一个稀疏矩阵中所有的非零元素按线性关系存在一张线性表中。三元组顺序表（list of 3-tuples），采用以行为主序排序

数据类型定义

```c++
// 元素类型
typedef int ElemType;

// 稀疏矩阵的行数和列数
const int M = 20;
const int N = 20;

// 稀疏矩阵中非零元素最多的个数
constexpr int MaxSize = int((M * N) / 10);

// 三元组类型
typedef struct {
    int r;     // 行号
    int c;     // 列号
    ElemType d;     // 元素值
} TupNode;

// 三元组顺序表类型
typedef struct {
    int rows;     // 行数
    int cols;     // 列数
    int nums;     // 非零元素个数
    TupNode data[MaxSize];
} TSMatrix;
```

从一个二维稀疏矩阵创建其三元组表示

```c++
void CreateMat(TSMatrix& t, ElemType A[M][N]) {
    t.rows = M; t.cols = N; t.nums = 0;
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            // 只存储非零元素
            if (A[i][j] != 0) {
                t.data[t.nums].r = i;
                t.data[t.nums].c = j;
                t.data[t.nums].d = A[i][j];
                ++t.nums;
            }
        }
    }
}
```

三元组元素的赋值（x != 0），先在三元组顺序表中找到适当位置k，在顺序表中位置为k的元素是在 矩阵\[i][j]（含） 之后的第一个在顺序表中的元素；如果顺序表中k元素正好矩阵中[i][j]元素，对应一个非零元素，将其d数据域修改为x；如果顺序表中k元素在[i][j]之后，表明[i][j]位置上为零，先赋值为x，再将顺序表中k之后元素后移一位，x插入到k位置

```c++
bool SetValue(TSMatrix& t, ElemType x, int i, int j) {
    if (i >= t.rows || j >= t.cols) {
    	return false;     // 参数 i j 越界错误，返回false
    }
    int k = 0;
    while (k < t.nums && t.data[k].r < i) {
    	++k;     // 寻找大于等于i行的非零元素，在顺序表中的位置k
    }
    while (k < t.nums && t.data[k].c == i && t.data[k].c < j) {
   		++k;     // 若第i行有非零元素，寻找大于等于第j行的非零元素，在顺序表中的位置k
    }
    if (t.data[k].r == i && t.data[k].c == j) {
    	t.data[k].d = x;     // 若顺序表中位置k的元素正好就是 矩阵ij 对应的元素，赋值
    } else {
        // ij 上为零元素，要在顺序表中插入，先移动后面的元素，再赋值
        for (int k1 = t.nums - 1; k1 >= k; --k1) {
            t.data[k1 + 1].r = t.data[k1].r;
            t.data[k1 + 1].c = t.data[k1].c;
            t.data[k1 + 1].d = t.data[k1].d;
        }
        t.data[k].r = i; t.data[k].c = j; t.data[k].d = x;
        ++t.nums;     // 非零元素的计数器加一
    }
    return true;
}
```

将指定位置的元素赋给变量

```c++
bool Assign(TSMatrix t, ElemType &x, int i, int j) {
    if (i >= t.rows || j >= t.cols) {
    	return false;     // 参数 i j 越界错误，返回false
    }
    int k = 0;
    while (k < t.nums && t.data[k].r < i) {
    	++k;     // 寻找大于等于i行的非零元素，在顺序表中的位置k
    }
    while (k < t.nums && t.data[k].c == i && t.data[k].c < j) {
    	++k;     // 若第i行有非零元素，寻找大于等于第j行的非零元素，在顺序表中的位置k
    }
    if (t.data[k].r == i && t.data[k].c == j) {
    	x = t.data[k].d;     // 若顺序表中位置k的元素正好就是 矩阵ij 对应的元素，赋值
    } else {
        x = 0;     // 指定位置ij不在顺序表中，即为零元素
    }
    return true;
}
```

输出三元组顺序表

```c++
void DispMat(TSMatrix t) {
    if (t.nums <= 0) {
    	return;     // 没有非零元素，即顺序表为空
    }
    printf("\t%d\t%d\t%d\n", t.rows, t.cols, t.nums);
    printf("\t----------------------------------\n");
    for (int k = 0; k < t.nums; ++k) {
    	printf("\t%d\t%d\t%d\n", t.data[k].r, t.data[k].c, t.data[k].d);
    }
}
```

稀疏矩阵转置 O(t.cols X t.rows)，用tb来存储转置矩阵B的三元组顺序表，赋值重建tb

```c++
void TranTat(TSMatrix t, TSMatrix& tb) {
    if (t.nums <= 0) {
    	return;     // 没有非零元素，即顺序表为空
    }
    tb.rows = t.cols; tb.cols = t.rows; tb.nums = t.nums;
    int k1 = 0;     // k1记录目前tb中元素的个数
    // 按列遍历原矩阵
    for (int v = 0; v < t.cols; ++v) {
        // 依次遍历顺序表中的非零元素，判断其位置是否是第v列
        for (int k = 0; k < t.nums; ++k) {
            if (t.data[k].c == v) {
                tb.data[k1].r = t.data[k].c;
                tb.data[k1].c = t.data[k].r;
                tb.data[k1].d = t.data[k].d;
                ++k1;
            }
        }
    }
}
```

### 2. 稀疏矩阵的十字链表示

每行一个行头结点，每列一个列头结点，还有一个总头结点，每个元素结点同时存储在行和列两个循环单链表中

数据结构定义

```c++
// 稀疏矩阵的行数列数
const int M = 20;
const int N = 20;
constexpr int Max = M > N ? M : N;

typedef int ElemType;

// 数据结点组成：行、列、值、右指针域、下指针域
// 行列结点组成：行、列、link域、右指针域、下指针域
// 分析发现两个数据结构相似，故采用共用体
typedef struct mtxn {
    int row;     // 行号或行数
    int col;     // 列号或列数
    struct mtxn *right, *down;     // 右、下指针
    union {
        ElemType value;
        struct mtxn* link;
    } tag;
} MatNode;
```

例6.2 双层集合 

```c++
typedef struct dnode {
    int data;
    struct dnode* next;
} DType;

typedef struct hnode {
    DType* next;
    struct hnode* link;
} HType;
```

## （三）广义表（generalized table）

广义表是线性表的推广，是有限个元素的序列，括号表示法，元素类型：原子（atom），子表（subgeneralized table）。长度为最外层包含元素的个数，深度为嵌套的层数

广义表的抽象数据类型定义如下：

```c++
ADT GList {
    数据对象:
    	D = { ei | 1 <= i <= n, n >= 0, ei ∈ AtomSet 或 ei ∈ GList, AtomSet为某个数据对象 }
    基本关系:
    	R = { <e(i-1), ei> | e(i-1)、ei ∈ D, 2 <= i <= n }
    基本运算:
        CreateGL(s);
        DestroyGL(&g);
        GLLength(g);
        GLDepth(g);
        DispGL(g);
```

数据结构定义

```c++
typedef char ElemType;

// 广义表的存储结构
typedef struct lnode {
    int tag;     // 结点类型标识，0为原子结点，1为子表结点
    union {
        ElemType data;     // 存放原子值
        struct lnode* sublist;     // 指向子表的指针
    } val;
    struct lnode* link;     // 指向下一个元素
} GLNode;     // 广义表的结点类型
```

广义表的运算，为使算法方便，在广义表的逻辑表示中用“(#)”表示空表，若元素为结点，则其是其子表的头结点

求广义表的长度

```c++
int GLLength(GLNode* g) {
    int n = 0;     // 累计元素个数，初始为0
    GLNode* g1 = g->val.sublist;     // g1指向广义表的第一个元素
    while (g1 != NULL) {
        ++n;     // 元素个数加一
        g1 = g1->link;     // 扫描所有元素结点
    }
    return n;
}
```

求广义表的深度，原子深度为0，空表深度为1，其他情况深度为 max{ f(subg) } + 1

```c++
int GLDepth(GLNode* g) {
    if (g->tag == 0) {
    	return 0;     // 原子类型，返回0
    }
    GLNode* g1 = g->val.sublist;
    if (g1 == NULL) {
    	return 1;     // 空表，返回1
    }
    int maxd = 0;
    // 遍历表中的每个元素
    while (g1 != NULL) {
        // 当元素为子表的时候，判断目前最大深度，并更新
        if (g1->tag == 1) {
        	int dep = GLDepth(g1);
        	if (dep > maxd) {
        		maxd = dep;
        	}
        }
        g1 = g1->link;
    }
    return maxd + 1;
}
```

输出广义表

```c++
void DispGL(GLNode* g) {
    if (g != NULL) {
        // 元素为原子类型
        if (g->tag == 0) {
        	printf("%c", g->val.data);
        } else {
        	// 元素类型为子表
        	printf("(");
        	if (g->val.sublist == NULL) {
        		printf("#");     // 为空表
        	} else {
        	DispGL(g->val.sublist);    // 非空表，递归输出子表
        }
        printf(")");
    }
    if (g->link != NULL) {
        printf(",");
        DispGL(g->link);
    }
    /*g = g->link;*/
    }
}
```

建立广义表的链式存储结构，假设广义表的逻辑结构采用括号表示，每个原子的值被限定为单个英文字母

```c++
GLNode* CreateGL(char*& s) {
    GLNode* g;
    char ch = *s++;     // 取一个字符
    // s未扫描完时
    if (ch != '\0') {
    	g = (GLNode*)malloc(sizeof(GLNode));     // 创建一个新结点
    	if (ch == '(') {
    		g->tag = 1;     // 字符为 ( ，标志子表开头
    		g->val.sublist = CreateGL(s);     // 递归构造子表，将其赋给当前结点的sublist，当前的结点作为子表的头结点
    	} else if (ch == ')') {
    		g = NULL;
    	} else if (ch == '#') {
    		g = NULL;
    	} else {
            g->tag = 0;     // 元素为原子字符
            g->val.data = ch;
    	}
    } else {
    	g = NULL;     // 字符扫描完毕，g置为空
    }
    ch = *s++;     // 取下一个未处理的字符
    if (g != NULL) {
        if (ch == ',') {
            g->link = CreateGL(s);     // 构造兄弟结点
            } else {
            g->link = NULL;
        }
    }
    return g;
}
```

销毁广义表

```c++
void DestroyGL(GLNode*& g) {
    GLNode *g1, *g2;
    g1 = g->val.sublist;     // g1指向广义表的第一个元素
    // 遍历所有元素
    while (g1 != NULL) {
        // 若为原子结点
        if (g1->tag == 0) {
        	g2 = g1->link;     // g2临时保存兄弟结点
        	free(g1);     // 释放g1所指的原子结点
        	g1 = g2;      // g1指向后继兄弟结点
        } else {
            // 若为子表
            g2 = g1->link;
            DestroyGL(g1);     // 递归释放g1所指的子表空间
            g1 = g2;
        }
    }
    free(g);
}
```

例6.3 对于采用链式存储结构的广义表，设计一个算法求原子元素个数

解法一：

```c++
int Count1(GLNode* g) {
    GLNode* g1 = g->val.sublist;
    int count = 0;
    while (g1 != NULL) {
    	if (g1->tag == 0) {
    		++count;
    	} else {
    		count += Count1(g1);
   		}
    	g1 = g1->link;
    }
    return count;
}
```

解法二：

```c++
int Count2(GLNode* g) {
    int count = 0;
    if (g != NULL) {
        if (g->tag == 0) {
        	++count;
        } else {
        	count += Count2(g->val.sublist);
        }
        count += Count2(g->link);
    }
    return count;
}
```

# 七、树和二叉树

## （一）树（tree）的基本概念

### 1. 树的定义

根节点简称根（root）、子树（subtree），树的抽象数据类型描述如下：

```c++
ADT Tree {
    数据对象:
    	D = { ai | 1 <= i <= n, n >= 0, ai 为 ElemType 类型 } // ElemType 是自定义类型标识符
    数据关系:
    	R = { <ai,aj> | ai, aj ∈ D, 1 <= i, j <= n, 其中有且只有一个结点没有前驱结点，其余每个结点只有一个前驱结点，但可以有零个或多个后继结点 }
    基本运算:
        InitTree(&t);
        DestroyTree(&t);
        TreeHeight(t);
        Parent(t,p);
        Brother(t,p);
        Sons(t,p);
        ...
}
```

### 2. 树的逻辑表示法

树形表示法（tree representation）、文氏图表示法（venn diagram representation）、凹入表示法（concave representation）、括号表示法（brakcket representation）

### 3. 树的基本术语

- 结点的度（degree of node）：某个结点的子树的个数
- 树的度（degree of tree）：所有结点中最大值，度为m的树称为m次树（m-tree）
- 分支结点（branch）：树中不为零的结点称为非终端结点，又叫分支结点
- 叶子结点（leaf）：度数为零的结点,度数为1的结点称为单分支结点，度数为2的结点称为双分支结点，以此类推
- 路径（path）：从结点ki到结点kj，每一个结点都是在序列中的前一个结点的后继结点，则称为一条路径
- 路径长度（path length）：是该路径上所有线段的权重之和，在此处考虑简单情况，权重为1
- 孩子结点（children）、双亲结点（parents）、兄弟结点（sibling）、子孙结点（descendant）、祖先结点（ancestor）
- 结点层次（level）或结点深度（depth）
- 树的高度（height of tree）或树的深度（depth of tree）
- 有序树（ordered tree）：各结点的子树是按照一定的次序从左向右安排的，且相对次序是不能随意改变的，否则为无序树（unordered tree）
- 森林（forest）：多个互不相交的树的集合称为森林

### 4. 树的性质

（证明时考虑边界极限情况）

- 性质1：树中的结点数 = 所有结点度数之和 + 1
- 性质2：度数为m的树中，第i层上最多有 m^(i-1) 个结点（i >= 1）
- 性质3：高度为h的m次树最多有 (m^h - 1) / (m - 1) 个结点
- 性质4：具有n个结点的m次树的最小高度为 ⌈log m( n(m-1) + 1)⌉

### 5. 树的基本运算

- 寻找特点结点
- 插入或删除某个结点
- 树的遍历（traversal）：先根遍历（preorder traversal）、后根遍历（postorder traversal）、层次遍历（level traversal）

### 6. 树的存储结构

```c++
typedef int ElemType;     // 数据类型
```

双亲存储结构（parent storage structure），是一种顺序存储结构，用连续的空间存储所有点，每个结点中有个指向双亲结点在顺序表中位置的伪指针

```c++
const int MaxSize = 50;
typedef struct {
    ElemType data;     // 存放结点的值
    int parent;     // 存放双亲结点的位置
} PTree[MaxSize];     // PTree 为双亲存储结构类型
```

孩子链存储结构（child chain storage structure），每个结点不仅包括值，还有指向所有孩子的指针

```c++
const int MaxSons = 3;
typedef struct node {
    ElemType data;     // 存放结点的值
    struct node* sons[MaxSons];     // 指向孩子结点
} TSonNode;     // 孩子链存储结构中的结点类型
```

孩子兄弟链存储结构（child brother chain storage structure），每个结点三个域，数据元素域，第一个孩子指针域，该结点下一个兄弟指针域，类似广义表

```c++
typedef struct tnode {
	ElemType data;     // 结点的值
    struct tnode* hp;     // 指向兄弟，horizon
    struct tnode* vp;     // 指向孩子结点，vertical
} TSBNode;
```

例 7.3 以孩子链作为树的存储结构，设计一个递归算法求树t的高度，f(t) = 0, t == NULL，f(t) = Max { f(p) } + 1, 其他情况，p指向t的孩子

```c++
int TreeHeight1(TSonNode* t) {
    if (t == NULL) {
    	return 0;     // 空树返回高度0
    } else {
        TSonNode* p;
        int maxh = 0;
        for (int i = 0; i < MaxSons; ++i) {
            p = t->sons[i];     // p指向t的第i+1个孩子
            if (p != NULL) {
            	int h = TreeHeight1(p);     // 递归求子树高
            	if (maxh < h) {
            		maxh = h;     // 更新当前树的最大高度
    			}
    		}
    	}
    	return maxh + 1;
    }
}
```

例 7.4 以孩子兄弟链作为树的存储结构，设计一个求树高度的递归算法

```c++
int TreeHeight2(TSBNode* t) {
    if (t == NULL) {
    	return 0;     // 空树返回高度0
    }
    int maxh = 0;
    TSBNode* p = t->vp;    // p指向第1个孩子结点
    while (p != NULL) {
    	int h = TreeHeight2(p);     // 求p子树的高度
    	if (maxh < h) {
    		maxh = h;
    	}
    	p = p->hp;     // 扫描处理t的其他子树
    }
    return maxh + 1;
}
```

## （二）二叉树（binary tree）的概念和性质

### 1. 二叉树的定义

左子树（left subtree）、右子树（right subtree）

- 满二叉树（full binary tree）：所有层都铺满结点
- 完全二叉树（complete binary tree）：只有最下层最右侧（从右到左）可以却，其他均铺满。满二叉树是完全二叉树的特殊情况
- 层序编号（level coding）：从1开始，对完全二叉树，按层数从小到大，同一层从左到右依次排号

### 2. 二叉树的性质

- 性质1：叶子结点数 = 双分支结点数 + 1，n0 = n2 + 1，证明用：结点总数 n = n0 + n1 + n2，度之和 = n - 1 = n1 + 2 * n2
- 性质2：第i层上最多有 2^(i-1) 个结点（i >= 1）
- 性质3：高度为h的二叉树最多有 2^h - 1 个结点（h >= 1）
- 性质4：完全二叉树中的层序编号为 i 的结点（1 <= i <= n, n >= 1, n为结点个数）有以下性质：
  - 若 i <= ⌊n/2⌋，则i为分支结点，否则为叶子结点
  - 若 n 为奇数，则每个分支结点都有左右两个孩子；若 n 为偶数，则有且仅有一个编号为 ⌊n/2⌋ 的分支结点只有左孩子结点
  - 如果有的话，编号为 i 的结点，左孩子是 2i，右孩子是 2i + 1
  - 除根结点外，i 的双亲结点为 ⌊n/2⌋
  - 有 n 个结点的完全二叉树高度为 ⌈log2 (n + 1)⌉ 或 ⌊log2 n⌋ + 1

### 3. 二叉树与树，森林之间的转换

森林、树转换为二叉树：

1. 树中所有兄弟结点连一条线（森林中不同树的根结点可看成兄弟关系）
2. 对树中的每个结点只保留它与长子（最左侧儿子）的连线，删除与其他孩子之间的连线
3. 调整角度，让树的结构层次分明

得到的二叉树的左分支是原来的孩子关系，右分支是兄弟关系，即：左孩子右兄弟

二叉树还原为树、森林：

1. 对于每个双亲结点，跟其左孩子结点的，所有的右孩子、右孩子的右孩子，依次都连接起来
2. 删除原来所有双亲结点的右孩子、右孩子的右孩子的之间的连线
3. 调整角度，让树的结构层次分明

## （三）二叉树的存储结构

### 1. 二叉树的顺序存储结构

借助完全二叉树的层次编号来实现，以方便寻找孩子结点和双亲结点，为与逻辑编号对应，不使用数组中索引为0的位置，置为空标识，对于非完全二叉树，借用空元素将其补成完全二叉树，空用 # 标识

```c++
const int MaxSize = 50;
typedef ElemType SqBinTree[MaxSize];
```

### 2. 二叉树的链式存储结构

一个结点： lchild  data  rchild，通常检查为二叉链（binary linked list），二叉链中通过根结点指针 b 来唯一标识整个存储结构，称为二叉树b

```c++
typedef char ElemType;

// 二叉链中结点类型BTNode的声明如下：
typedef struct node {
    ElemType data;     // 数据元素
    struct node* lchild;     // 指向左孩子结点
    struct node* rchild;     // 指向右孩子结点
} BTNode;
```

## （四）二叉树的基本运算及其实现

### 1. 二叉树的基本运算概述

```c++
CreateBTree(b,str);
DestroyBTree(&b);
FindNode(b,x);
LchildNode(p);
RchildNode(p);
BTHeight(b);
DispBTree(b);
```

### 2. 二叉树基本运算算法实现

```c++
// 引用二叉树的链式存储结构
using _7_3::_7_3_2::BTNode;
using _7_3::_7_3_2::ElemType;

// 泛型栈
template<typename T, size_t MaxSize = 50>
struct Stack;
```

创建二叉树 CreateBTree(\*b, \*str) ，从括号表示法创建，如 "A(B(D(,G)),C(E,F))"，采用栈协助，用ch遍历字符串str，用k代表当前结点与栈顶结点的关系（1为左孩子，2为右孩子），若：

- ch 为 ( ：表示它前面刚创建的结点p存在孩子结点，将该双亲结点进栈，然后开始处理左孩子，置k为1
- ch 为 , ：表示开始处理当前栈顶结点（双亲结点）的右孩子结点，置k为2
- ch 为 ) ：表示以栈顶为根结点的子树创建完毕，将其退栈
- 其他情况 ：只能是单个字符，创建一个结点p处理该值，然后根据k的值处理它与栈顶结点之间的关系

```c++
void CreateBTree(BTNode*& b, char* str) {
    dep::Stack<BTNode*> *st;
    InitStack(st);
    BTNode* p = (BTNode*)malloc(sizeof(BTNode));
    b = NULL;    // 初始时将二叉链置为NULL
    int j = 0, k;
    char ch = str[j];
    // 循环扫描str中的每个字符
    while (ch != '\0') {
        switch (ch) {
        case '(':
            // 开始处理左孩子结点，当前双亲结点进栈
            Push(st, p);
            k = 1;
            break;
        case ',':
            // 开始处理右孩子结点
            k = 2;
            break;
        case ')':
            // 栈顶结点的子树处理完毕
            Pop(st);
            break;
        default:
            p = (BTNode*)malloc(sizeof(BTNode));     // 创建一个结点，由p指向它
            p->data = ch;     // 存放结点值
            p->lchild = p->rchild = NULL;     // 左右孩子置为空
            // 若b为空，则表示尚未建立根结点
            if (b == NULL) {
            	b = p;     // p所指的结点作为根结点
            } else {
            	// 已创建根结点
                BTNode* t;
                GetTop(st, t);     // 取栈顶结点所表示的双亲结点
                switch (k) {
                case 1:
                	t->lchild = p;     // 新建结点p作为栈顶结点的左孩子
                	break;
                case 2:
                	t->rchild = p;     // 新建结点作为栈顶结点的右孩子
                	break;
            	}
        	}
    	}
    	++j;     // 继续扫描str
    	ch = str[j];
    }
}
```

创建二叉树 CreateBTree(\*b, \*str) ，从括号表示法创建，如 "A(B(D(,G)),C(E,F))"，树中的结点类型为T

```c++
template<typename T>
void CreateBTree(T*& b, char* str) {
    dep::Stack<T*> *st;
    InitStack(st);
    T* p = (T*)malloc(sizeof(T));
    b = NULL;     // 初始时将二叉链置为NULL
    int j = 0, k;
    char ch = str[j];
    // 循环扫描str中的每个字符
    while (ch != '\0') {
        switch (ch) {
        case '(':
        	// 开始处理左孩子结点，当前双亲结点进栈
            Push(st, p);
            k = 1;
            break;
        case ',':
            // 开始处理右孩子结点
            k = 2;
            break;
        case ')':
            // 栈顶结点的子树处理完毕
            Pop(st);
            break;
        default:
            p = (T*)malloc(sizeof(T));     // 创建一个结点，由p指向它
            p->data = ch;     // 存放结点值
            p->lchild = p->rchild = NULL;     // 左右孩子置为空
            // 若b为空，则表示尚未建立根结点
            if (b == NULL) {
            	b = p;     // p所指的结点作为根结点
            } else {
                // 已创建根结点
                T* t;
                GetTop(st, t);     // 取栈顶结点所表示的双亲结点
                switch (k) {
                case 1:
                    t->lchild = p;     // 新建结点p作为栈顶结点的左孩子
                    break;
                case 2:
                    t->rchild = p;     // 新建结点作为栈顶结点的右孩子
                    break;
                }
            }
        }
        ++j;     // 继续扫描str
        ch = str[j];
    }
}
```

销毁二叉树 DestroyBTree(&b)'

```c++
void DstroyBTree(BTNode*& b) {
    if (b != NULL) {
        DstroyBTree(b->lchild);
        DstroyBTree(b->rchild);
        free(b);
    }
}
```

查找结点 FindNode(b,x)

```c++
BTNode* FindNode(BTNode* b, ElemType x) {
    if (b == NULL) {
    	return NULL;
    } else if (b->data == x) {
    	return b;
    } else {
   		BTNode* p = FindNode(b->lchild, x);
    	if (p != NULL) {
    		return p;
    	} else {
    		return FindNode(b->rchild, x);
    	}
    }
}
```

找左孩子结点 LchildNode(b)

```c++
BTNode* LchildNode(BTNode* b) {
	return b->lchild;
}
```

找右孩子结点 RchildNode

```c++
BTNode* RchildNode(BTNode* b) {
	return b->rchild;
}
```

求高度 BTHeight(b)

```c++
int BTHeight(BTNode* b) {
    if (b == NULL) {
    	return 0;
    } else {
    	int left = BTHeight(b->lchild);
    	int right = BTHeight(b->rchild);
    	return left > right ? left + 1 : right + 1;
    }
}
```

输出二叉树 DispBTree(b)

```c++
void DispBTree(BTNode* b) {
    if (b != NULL) {
    	// 当前结点非空，输出其表示的值
    	printf("%c", b->data);
    	// 至少有一个孩子结点时
    	if (b->lchild != NULL || b->rchild != NULL) {
    		printf("(");
    		DispBTree(b->lchild);     // 递归处理左子树
    		if (b->rchild != NULL) {
    			// 如果有右孩子结点，先输出 ,
    			printf(",");
    		}
    		DispBTree(b->rchild);     // 递归处理右孩子结点
   			printf(")");
    	}
    }
}
```

## （五）二叉树的遍历

规定子树的遍历方法总是先左后右，有：先序遍历（preorder traversal）、中序遍历（inorder traversal）、后序遍历（postorder traversal），又叫，先根遍历，中根遍历，后根遍历

- 先序遍历：访问根结点 -> 先序遍历左子树 -> 先序遍历右子树
- 中序遍历：中序遍历左子树 -> 访问根结点 -> 中序遍历右子树
- 后序遍历：后序遍历左子树 -> 后序遍历右子树 -> 访问根节点

还有一个层次遍历（level traversal）：非递归的，一层一层的访问所有结点

### 1. 先序、中序、后序遍历的递归算法

引用二叉树类型

```c++
using _7_3::_7_3_2::BTNode;
using _7_3::_7_3_2::ElemType;
```

先序遍历递归算法

```c++
void PreOrder(BTNode* b) {
    if (b != NULL) {
        printf("%c", b->data);
        PreOrder(b->lchild);
        PreOrder(b->rchild);
    }
}
```

中序遍历递归算法

```c++
void InOrder(BTNode* b) {
    if (b != NULL) {
        InOrder(b->lchild);
        printf("%c", b->data);
        InOrder(b->rchild);
    }
}
```

后序遍历递归算法

```c++
void PostOrder(BTNode* b) {
    if (b != NULL) {
        PostOrder(b->lchild);
        PostOrder(b->rchild);
        printf("%c", b->data);
    }
}
```

例 7.11 二叉树采用二叉链存储，求所有结点个数

```c++
int Nodes(BTNode* b) {
    if (b == NULL) {
    	return 0;
    } else {
    	return Nodes(b->lchild) + Nodes(b->rchild) + 1;
    }
}
```

例 7.12 二叉树采用二叉链存储，输出所有叶子结点

```c++
void DispLeaf(BTNode* b) {
    if (b != NULL) {
        if (b->lchild == NULL && b->rchild == NULL) {
        	printf("%c ", b->data);
        }
        DispLeaf(b->lchild);
        DispLeaf(b->rchild);
    }
}
```

例 7.13 二叉树采用二叉链存储，求值为x的结点在树中的深度，调用时，h = 1

```c++
int Level(BTNode* b, ElemType x, int h) {
    // h 表示 结点 b 在树中的第几层，从外部调用时初始值应置为1
    if (b == NULL) {
    	return 0;
    } else if (b->data == x) {
    	return h;
    } else {
    	int lev = Level(b->lchild, x, h + 1);     // 在左子树中查找
    	// lev不为零，表示在左子树中找到了
    	if (lev != 0) {
    		return lev;
    	} else {
    		// 没在左子树中找到，返回在右子树中查找的结果
    		return Level(b->rchild, x, h + 1);
    	}
    }
}
```

例 7.14 二叉树采用二叉链存储，求二叉树中第 k 层的结点的个数。h 表示 b 所指结点的层次（根结点为1），n为引用型参数，求第k层结点的个数

```c++
void Lnodenum(BTNode* b, int h, int k, int& n) {
    if (b == NULL) {
        n = 0;
        return;     // 空树直接返回
    } else {
        if (h == k) {
        	// 当前访问的结点正好在第k层，则第k层的结点个数加一
        	++n;
        } else if (h < k) {
        	Lnodenum(b->lchild, h + 1, k, n);
        	Lnodenum(b->rchild, h + 1, k, n);
        }
    }
}
```

例 7.15 以二叉链存储的二叉树，判断两个二叉树是否相似。都是空，或根、左子树、右子树都相似

```c++
bool Like(BTNode* b1, BTNode* b2) {
    if (b1 == NULL && b2 == NULL) {
    	return true;
    } else if (b1 == NULL || b2 == NULL) {
    	return false;
    } else {
    	return Like(b1->lchild, b2->lchild) && Like(b1->rchild, b2->rchild);
    }
}
```

例 7.16 二叉树采用二叉链存储，输出值为x的结点的所有祖先

```c++
bool ancestor(BTNode* b, ElemType x) {
    if (b == NULL) {
    	return false;
    } else if (b->lchild != NULL && b->lchild->data == x ||
        b->rchild != NULL && b->rchild->data == x) {
        printf("%c ", b->data);
        return true;
    } else if (ancestor(b->lchild, x) || ancestor(b->rchild, x)) {
        printf("%c ", b->data);
        return true;
    } else {
    	return false;
    }
}
```

### 2. 先序、中序、后序遍历的非递归算法

进栈保存现场状态，根据遍历顺序，来进栈以摆好顺序；还要注意是出栈时访问还是进栈时访问

```c++
// 引用二叉树的链式存储结构
using _7_3::_7_3_2::BTNode;
using _7_3::_7_3_2::ElemType;

// 泛型栈
template<typename T, size_t MaxSize = 50>
struct Stack;
```

先序遍历的非递归算法1，此算法较为简单。根据栈的先进后出特性，并结合根左右的遍历顺序，调整为 先访问，进右孩子，进左孩子

```c++
void PreOrder1(BTNode* b) {
    // 根结点不为空
    if (b != NULL) {
    	dep::Stack<BTNode*>* st;
    	InitStack(st);
    	BTNode* p;
    	Push(st, b);
    	while (!StackEmpty(st)) {
            Pop(st, p);
            printf("%c ", p->data);
            if (p->rchild != NULL) {
            	Push(st, p->rchild);
            }
            if (p->lchild != NULL) {
            	Push(st, p->lchild);
            }
		}
		DestroyStack(st);
    }
    printf("\n");
}
```

先序遍历的非递归算法2，根，左，右

先遍历根结点b及其所有左下结点（用栈保存访问过的结点，因为二叉链中无法用孩子找到双亲），直到栈顶结点没有左孩子，或左孩子已经遍历过；之后转向右孩子右子树，处理方法如上述过程类似，伪代码如下：

```c++
p = b;
while (栈不为空 或 p != NULL) {
	while (p不为空) {
		访问p;
		将p进栈;
		p = p->lchild;
	}
	// 此时栈顶结点（已访问）没有左孩子，或左孩子已经遍历过
	if (栈不空) {
		出栈p;
		p = p->rchild;
	}
}
```

```c++
void PreOrder2(BTNode* b) {
    dep::Stack<BTNode*>* st;
    InitStack(st);
    BTNode* p = b;
    while (!StackEmpty(st) || p != NULL) {
        // 访问p结点及其所有左下结点并进栈
        while (p != NULL) {
            printf("%c ", p->data);
            Push(st, p);      // 结点p进栈，栈顶更新
            p = p->lchild;
        }
        if (!StackEmpty(st)) {
            Pop(st, p);      // 出栈栈顶，p转向原栈顶的右孩子
            p = p->rchild;     // 右孩子若为空，则上一个 while 直接跳过，再次退栈Pop
        }
    }
    printf("\n");
    DestroyStack(st);
}
```

中序遍历的非递归算法，由先序遍历的非递归算法2修改而来，将 进栈时遍历 改为 出栈时遍历

```c++
p = b;
while (栈不空 或 p != NULL) {
    while (结点p不为空) {
    	将p进栈;
    	p = p->lchild;
    }
    // 此时栈顶结点（未访问）没有左孩子，或左孩子以遍历完
    if (栈不空) {
        出栈p;
        访问p;
        p = p->rchild;
    }
}
```

```c++
void InOrder(BTNode* b) {
    dep::Stack<BTNode*>* st;
    InitStack(st);
    BTNode* p = b;
    while (!StackEmpty(st) || p != NULL) {
        while (p != NULL) {
            Push(st, p);
            p = p->lchild;
        }
        if (!StackEmpty(st)) {
            Pop(st, p);     // 出栈，栈顶更新
            printf("%c ", p->data);
            p = p->rchild;     // 处理原栈顶结点的右孩子
        }
    }
    printf("\n");
    DestroyStack(st);
}
```

后序遍历的非递归算法，由中序遍历的非递归算法修改而来，左子树为空或已遍历，再遍历完右子树，才能访问结点p。伪代码如下：

```c++
p = b;
do {
    while (结点p不为空) {
        // 将结点p进栈;
        p = p->lchild;
    }
    正在处理栈顶结点 = true;     // 否则代表刚转为右孩子结点
    r = NULL;     // 用r指向刚遍历的结点（初始为NULL），用以判断结点p的右孩子是否访问过或为空（p->rchild == r)
    // 此时栈顶结点（尚未访问）没有左孩子，或左孩子已经遍历过，该处理右孩子
	while (栈不为空 且 正在处理栈顶结点) {
        取栈顶结点为p（不退栈）;
        if (p->rchild == r) {
        	右子树已遍历过
        	访问节点p;
        	Pop(st, r);     // 退栈，r更新为原栈顶结点（最后处理的结点）
        } else {
        	p = p->rchild;
        	正在处理栈顶结点 = false;
        }
    }
} while (栈不空);
```

该后序遍历的非递归算法，当访问某个结点时，栈中保存的正好是该结点的所有祖先结点

```c++
void PostOrder(BTNode* b) {
    dep::Stack<BTNode*>* st;
    InitStack(st);
    BTNode* p = b;
    bool isHandlingTop;
    BTNode* r;     // 表示最后访问的结点
    do {
   		while (p != NULL) {
    		Push(st, p);
    		p = p->lchild;
    	}
    	isHandlingTop = true;
    	r = NULL;
    	while (!StackEmpty(st) && isHandlingTop) {
    		GetTop(st, p);
    		// 右孩子已遍历，或为空
    		if (p->rchild == r) {
    			// 访问当前栈顶，退栈，更新最后遍历结点
    			printf("%c ", p->data);
    			Pop(st, r);
    		} else {
   				// 此分支p的右孩子不为空，故一定会执行前一个while，找其左下
    			p = p->rchild;
    			isHandlingTop = false;
    		}
    	}
    } while (!StackEmpty(st));
    printf("\n");
    DestroyStack(st);
}
```

后序遍历的非递归算法还有另一种实现方式，如下。

```c++
void PostOrder2(BTNode* T) {
    InitStack(S);
    p = T;
    r = NULL;
    while (p != NULL || !Empty(S)) {
        if (p != NULL) {
            push(S, p);
            p = p->lchild;
        } else {
            // 已经到了最左下位置，向右
            GetTop(S, p);
            if (p->rchild != NULL && p->rchild != r) {
                p = p->rchild;	// 如果右子树存在且未被访问过，转向右子树
            } else {
                // 右子树不存在或被访问过，此时应访问栈中的祖先结点
                Pop(S, p);
                visit(p->data);
                r = p;			// 更新最后访问的结点
                p = NULL;		// 结点访问完毕，下次应访问栈中的祖先结点或祖先结点的右结点
            }
        }
    }
}
```

例7.17 二叉树采用二叉链存储，输出每个叶子结点到根结点的路径，采用后序遍历的非递归算法实现

```c++
void AllPath1(BTNode* b) {
    dep::Stack<BTNode*>* st;
    InitStack(st);
    BTNode* p = b;
    bool isHandlingTop;
    BTNode* r;
    do {
        while (p != NULL) {
            Push(st, p);
            p = p->lchild;
        }
        isHandlingTop = true;
        r = NULL;
        while (!StackEmpty(st) && isHandlingTop) {
        	GetTop(st, p);
        	if (p->rchild == r) {
    			// 访问结点p，即若为叶子结点，输出路径
    			if (p->lchild == NULL && p->rchild == NULL) {
    				dep::Stack<BTNode*>* stTemp;
                    InitStack(stTemp);
                    BTNode* nodeTemp;
                    Pop(st, nodeTemp);
                    printf("%c", nodeTemp->data);
                    Push(stTemp, nodeTemp);
                    while (!StackEmpty(st)) {
                        Pop(st, nodeTemp);
                        printf("->%c", nodeTemp->data);
                        Push(stTemp, nodeTemp);
                    }
   	 				printf("\n");
                    while (!StackEmpty(stTemp)) {
                        Pop(stTemp, nodeTemp);
                        Push(st, nodeTemp);
                    }
    			}
    			// 访问完成
    			Pop(st, r);
    		} else {
    			p = p->rchild;
    			isHandlingTop = false;
    		}
    	}
    } while (!StackEmpty(st));
}
```

### 3. 层次遍历算法

```c++
using dst::_7_3::_7_3_2::BTNode;     引用二叉链

// 泛型队列
template<typename T, size_t MaxSize = 50>
struct Queue;
```

层次遍历较为简单，先将根结点进队，队不为空时循环，若有左孩子则进队，有右孩子则进队，如此操作直到队空

```c++
void LevelOrder(BTNode* b) {
    dep::Queue<BTNode*>* qu;
    InitQueue(qu);
    enQueue(qu, b);
    BTNode* p;
    while (!QueueEmpty(qu)) {
    	deQueue(qu, p);
    	printf("%c ", p->data);
    	if (p->lchild != NULL) {
    		enQueue(qu, p->lchild);
    	}
    	if (p->rchild != NULL) {
    		enQueue(qu, p->rchild);
    	}
    }
    printf("\n");
    DestroyQueue(qu);
}
```

例 7.18 采用层次遍历法设计例7.17的算法

```c++
void AllPath2(BTNode* b) {
    typedef struct snode {
    	BTNode* pt;     // 存放树中当前结点的指针
    	int parent;     // 存放双亲结点在队列中的位置
    } NodeType;     // （非环形）队列中结点的元素类型

    BTNode* p;     // 树中的结点
    dep::Queue<NodeType>* qu;     // 队列
    InitQueue(qu);
    NodeType qelem;     // 队列中的结点
    qelem.pt = b;       // 创建根结点对应的队列元素
    qelem.parent = -1;     // 根结点的双亲位置标为-1
    enQueue(qu, qelem);
    while (!QueueEmpty(qu)) {
        deQueue(qu, qelem);
        // 访问
        p = qelem.pt;
    	if (p->lchild == NULL && p->rchild == NULL) {
    		// p为叶子结点，输出其到根结点的路径
            int k = qu->front;
            while (qu->data[k].parent != -1) {
                printf("%c->", qu->data[k].pt->data);
                k = qu->data[k].parent;
            }
    		printf("%c\n", qu->data[k].pt->data);
    	}
    	// 访问结束
    	// 判断左右孩子是否为空，将其进队
    	if (p->lchild != NULL) {
            qelem.pt = p->lchild;
            qelem.parent = qu->front;
            enQueue(qu, qelem);
    	}
        if (p->rchild != NULL) {
            qelem.pt = p->rchild;
            qelem.parent = qu->front;
            enQueue(qu, qelem);
        }
    }
    DestroyQueue(qu);
}
```

## （六）二叉树的构造

有n个结点的二叉树有 C(n)(2n) / (n+1) 种，假设每个结点值为单个字符，且所有结点的值均不相同，由中序序列 和 先序序列 或 后序序列 可唯一确定一二叉树（先序和后序不能唯一确定）

```c++
using dst::_7_3::_7_3_2::BTNode;     // 引用二叉链
```

**定理**：任何n(n>=0)个不同结点的二叉树，都可由它的中序序列和先序序列唯一确定

根据先序序列确定二叉树的根结点（第一个），在中序序列中找到这个根结点，则中序序列中其左边的为左子树，右边的为右子树；进而可以确定左右子树的序列（左子树和右子树分别多少个结点 l，r），再从先序序列和中序序列中找到l，r个结点，递归构造左右子树

```c++
// @param pre存放先序序列，in存放中序序列，n为二叉树的结点数
// @return 构造的二叉树的根结点指针
BTNode* CreateBTreeWithPreInOrder(char* pre, char* in, int n) {
    if (n <= 0) {
    	return NULL;
    }
    BTNode* b = (BTNode*)malloc(sizeof(BTNode));
    b->data = *pre;
    char* p;
    for (p = in; p < in + n; ++p) {
        // 在中序序列中找到根结点的位置，用p指向
        if (*p == *pre) {
        	break;
        }
    }
    int index = static_cast<int>(p - in);     // 确定根结点在中序序列中的物理下标
    // 递归构造左右子树，pre的第一个为根结点，已遍历过，故 +1 将之跳过
    b->lchild = CreateBTreeWithPreInOrder(pre + 1, in, index);     // 去掉在中序序列中的根结点，其左子树序列中正好index个结点
    b->rchild = CreateBTreeWithPreInOrder(pre + index + 1, p + 1, n - index - 1);
    return b;
}
```

**定理**：任何n(n>0)个不同的二叉树都可由它的中序序列和后序序列唯一确定

同理，利用后序序列来找到根结点（最后一个），其他操作同定理7.1

```c++
// @param post存放后序序列，in存放中序序列，n为二叉树的结点树
// @return 构造的二叉树的根结点指针
BTNode* CreateBTreeWithPostInOrder(char* post, char* in, int n) {
    if (n <= 0) {
    	return NULL;
    }
    char r = *(post + n - 1);     // 找到根结点的值
    BTNode* b = (BTNode*)malloc(sizeof(BTNode));
    b->data = r;
    char* p;
    for (p = in; p < in + n; ++p) {
    	// p指向在中序序列中的根结点的位置
    	if (*p == r) {
    		break;
    	}
    }
    int index = static_cast<int>(p - in);
    // 后序的第一个没用掉，故不用 post + 1
    b->lchild = CreateBTreeWithPostInOrder(post, in, index);
    b->rchild = CreateBTreeWithPostInOrder(post + index, in + index + 1, n - index - 1);      // in + index + 1 == p + 1
    return b;
}
```

## （七）线索二叉树（threaded binary-tree）

当某结点的左右指针为空时，根据遍历方式，将其空结点分别指向前驱和后继结点，这些指针称为线索（thread）。遍历二叉树的结果是一个结点的线性序列，线索化以提高遍历效率

数据结构定义

```c++
// 为线索化，给结点加两个成员，ltag和rtag，0表示指向孩子，1表示指向线索
typedef char ElemType;
typedef struct node {
    ElemType data;
    int ltag, rtag;
    struct node* lchild;
    struct node* rchild;
} TBTNode;     // 线索二叉树中的结点类型
```

在某遍历方式中：若开始结点p无左孩子，则左指针线索化，左指针仍为空；若最后结点q没有右孩子，则右指针线索化，右指针仍为空；其他结点r，若无左孩子，左指针线索化指向前驱结点；若无右孩子，则右指针线索化指向后继结点。

为使线索化简单，在线索二叉树中再增加一个头结点head，其data域为空；lchild指向无线索化时的根结点，ltag = 0，若二叉树为空，lchild指向自身；rchild指向按某种方式遍历的最后一个结点，rtag = 1。

线索化，用pre表示p的前驱结点，p表示pre的后继结点；若p的左指针为空，则线索化指向pre；若pre的右指针为空，则线索化指向p；处理结束后，p指向NULL，pre指向最后一个结点。

中序线索化

```c++
void InThread(TBTNode*& p, TBTNode*& pre) {
    if (p != NULL) {
    	InThread(p->lchild, pre);     // 左子树线索化
    	// 线索化p结点
    	if (p->lchild == NULL) {
            p->lchild = pre;     // 左孩子不存在，进行前驱结点线索化，建立当前结点的前驱线索结点
            p->ltag = 1;
        } else {
        	p->ltag = 0;     // p的左孩子存在
        }
    	if (pre->rchild == NULL) {
            pre->rchild = p;
            pre->rtag = 1;
    	} else {
    		pre->rtag = 0;
    	}
    	pre = p;     // p结点线索化完毕，更新pre前驱结点
    	InThread(p->rchild, pre);
    }
}
```

建立中序线索化二叉树，参数为根结点，返回头结点

```c++
TBTNode* CreateInThreadBTree(TBTNode* b) {
    TBTNode* head = (TBTNode*)malloc(sizeof(TBTNode));
    head->ltag = 0;
    head->rtag = 1;
    head->rchild = b;
    if (b == NULL) {
        head->lchild = head;
    } else {
        head->lchild = b;
        TBTNode* pre = head;
        InThread(b, pre);
        pre->rchild = head;     // 最后处理的结点的右孩子指向头结点
        pre->rtag = 1;
        head->rchild = pre;     // 头结点右线索化
    }
    return head;
}
```

遍历线索二叉树：从开始结点出发，反复访问后继结点（没有有线索则转向右孩子）直到头结点，算法的伪代码：

```c++
p指向根结点;
while (p != head) {
找到开始结点p;
访问结点p;
while(p有右线索) {
一直访问下去;
}
p转向右孩子结点;
}
其找到开始结点：中序遍历的开始结点时最左下结点，while(p->ltag == 0) { p = p->lchile; }
```

```c++
void ThInOrder(TBTNode* head) {
    TBTNode* p = head->lchild;     // p指向根结点
    while (p != head) {
    	while (p->ltag == 0) {
    		p = p->lchild;     // 找开始结点
   		}
    	printf("%c ", p->data);
    	while (p->rtag == 1 && p->rchild != head) {
    		p = p->rchild;
    		printf("%c ", p->data);
    	}
    	p = p->rchild;
    }
    printf("\n");
}
```

## （八）哈夫曼树（Huffman tree）

将树的每个结点赋予一个权，从根结点到该点之间的路径长度与该结点权的乘积为带权路径长度（Weighted Path Length, WPL），在n个叶子结点构成的所有二叉树中，WPL最小的二叉树称为哈夫曼树或最优二叉树

**定理**：对于有 n 个叶子结点的哈夫曼树，共有 2n - 1 个结点

哈夫曼树构造算法：
1. n个带权叶子节点，看成n个只有根结点的树，构成集合F（森林）
2. 在 F 中取最小和次小权值的两颗树，做左孩子和右孩子，构造一棵新树，根结点为二者之和
3. 将新树放入 F 中，并删除原来的两棵树
4. 重复 2 和 3，直到 F 中只含一颗树

```c++
typedef struct {
    char data;
    double weight;     // 权重
    int parent;        // 伪指针，采用顺序存储
    int lchild;
    int rchild;
} HTNode;     // 哈夫曼树中的结点类型
```

构造哈夫曼树，采用顺序存储 ht[0...2n-1)，ht[0...n-1] 表示叶子结点，ht[n...2n-2]表示非叶子结点，所有结点的 parent lchild rchild 初始值置为 -1，遍历所有 2n - 1 个结点

```c++
void CreatHT(HTNode ht[], int n) {
    int leftIndex, rightIndex, index;
    double minWeight1, minWeight2;
    for (int i = 0; i < 2 * n - 1; ++i) {
        // 所有结点的parent lchild rchild置为 -1
    	ht[i].parent = ht[i].lchild = ht[i].rchild = -1;     
    }
    // 构造剩下的 [n...2n-2] 的结点
    for (int i = n; i < 2 * n - 1; ++i) {
        minWeight1 = minWeight2 = ht[0].weight;
        leftIndex = rightIndex = -1;
        // 在已有的 i 个结点中找到最小和次小
        for (index = 0; index < i; ++index) {
        	// 只在未构造的结点中查找，即parent 为 -1 的
        	if (ht[index].parent == -1) {
        		if (ht[index].weight < minWeight1) {
        			minWeight2 = minWeight1;
        			rightIndex = leftIndex;
        			minWeight1 = ht[index].weight;
        			leftIndex = index;
        		} else if (ht[index].weight < minWeight2) {
        			minWeight2 = ht[index].weight;
        			leftIndex = index;
        		}
        	}
    	}
        ht[i].weight = ht[leftIndex].weight + ht[rightIndex].weight;
        ht[i].lchild = leftIndex;
        ht[i].rchild = rightIndex;
        ht[leftIndex].parent = ht[rightIndex].parent = i;
    }
}
```

哈夫曼编码（huffman coding），规定哈夫曼树中左子树为0，右子树为1，则从根结点到叶子结点所经历的0和1组成的序列即为哈夫曼编码

```c++
typedef struct {
    const static int N = 8;     // 哈夫曼编码的最大长度，为哈夫曼树的最大深度
    char cd[N];
    int start;     // 方便从右向左赋值
} HCode;

void CreateHCode(HTNode ht[], HCode hcd[], int n) {
	int parentIndex, curIndex;
    HCode hc;
    for (int i = 0; i < n; ++i) {
    	hc.start = HCode::N - 1;
    	curIndex = i;
    	parentIndex = ht[curIndex].parent;
    	while (parentIndex != -1) {
    		if (ht[parentIndex].lchild == curIndex) {
   				hc.cd[hc.start--] = '0';
    		} else {
    			hc.cd[hc.start--] = '1';
    		}
    		curIndex = parentIndex;
    		parentIndex = ht[parentIndex].parent;
    	}
    	++hc.start;
    	hcd[i] = hc;
    }
}
```

## （九）用并查集（disjoint-set）求解等价问题

对于集合 S 中的关系 R，若其具有自反、对称和传递性，则 R 是一个等价关系；由等价关系可以产生集合 S 的等价类

### 1. 什么叫并查集

并查集支持 查找一个元素所属的集合 以及 两个元素各自所属的集合的合并 等运算；对于两个元素 a b，需要快速合并 a 和 b 所在的集合时，这期间需要反复“查找”某元素所在的集合，“并”“查”“集”由此而来；在这种数据类型中，n 个不同的元素被分为若干组，每组是一个集合，叫分离集合，称之为 并查集（disjoint-set）。

并查集的数据记录代表了一组分离的动态集合 S = { S1, S2, ..., Sk }，每个动态集合 Si 通过自身的一个任意的元素加以“代表”；对于给定的编号为 1~n 的 n 个元素，x 表示其中的一个元素，设并查集为 S，并查集的实现需要支持如下运算：

1. MAKE_SET(S, n)：初始化并查集S，即 S = { S1, S2, ..., Sn }，每个动态集合 Si（i <= i <= n）仅仅包含一个编号为 i 的元素，并为Si的代表
2. FIND_SET(S, x)：返回并查集 S 中 x 元素所在集合的代表
3. UNION(S, x, y)：在并查集 S 中将 x 和 y 两个元素所在的动态集合合并为一个新的集合，并更新代表（通常以 Sx 或 Sy 的代表作为新集合的代表）

### 2. 并查集的算法实现

并查集必须借助某种数据结构来实现，使用比较多的有 数组实现、链表实现 和 树实现，这里主要介绍 树实现 方法。

- 用一棵有根树表示一个集合，树中的每个结点包含集合的一个元素，树根作为集合的代表，多个集合形成一个森林；树中的每个结点都有一个指向双亲结点的指针，根结点的双亲结点指向自身；
- 在同一棵树中的结点属于同一个集合，虽然它们在树中存在父子结点关系，但并不意味着他们之间存在从属关系；
- 显然在一颗高度较低的树中查找根结点的编号（即该集合的代表）所花的时间较少，故当两棵分离集合树 A 和 B 合并时，总是将高度较小的分离集合树作为子树，如 hA > hB，得到分离集合树 C 的高度 hC = MAX{ hA, hB + 1 }；
- 为此给每个结点增加一个 秩（rank）域，为一个近似子树高度的正整数，同时也是该结点高度的一个上限

为了方便，采用顺序方法存储森林，其中结点的类型声明如下：

```c++
typedef struct {
    int data;     // 结点对应元素的编号
    int rank;     // 结点对应的秩
    int parent;   // 结点对应双亲在结点数组中的下标
} UFSTree;
```

并查集树的初始化，建立一个存放并查集树的数组t，每个结点对应一个元素，data值即为该元素的编号，rank值初始值为0，parent值设置为自己

```c++
void MAKE_SET(UFSTree t[], int n) {
    for (int i = 0; i < n; ++i) {
        t[i].data = i;     // 数据为该元素的编号
        t[i].rank = 0;     // 秩初始化为0
        t[i].parent = i;   // 双亲初始化指向自己
    }
}
```

查找一个元素所属的集合，用分离集合树表示一个集合，故就是查找该元素所在的分离集合树，故就是查找分离集合树的代表，即树的根结点

```c++
int FIND_SET(UFSTree t[], int x) {
    // 双亲不是自己 ? 递归在双亲中找x : 返回x
	return x != t[x].parent ? FIND_SET(t, t[x].parent) : x; 
}
```

两个元素各自所属的集合的合并，只需要让具有较小秩的根指向具有较大秩的根；如果两根的秩相等，只需要使其中一个根指向另一个，同时秩增加1

```c++
void UNION(UFSTree t[], int x, int y) {
    x = FIND_SET(t, x);    // 分别查找x和y所在集合代表的编号
    y = FIND_SET(t, y);
    if (t[x].rank > t[y].rank) {
        t[y].parent = x;    // 将较小秩的根结点 y 连接到较大秩的根结点 x
    } else {
        t[x].parent = y;    // x 连接到 y
        if (t[x].rank == t[y].rank) {
            ++t[y].rank;    // 若x和y的秩相同，增加已连接到的 y 的秩
        }
    }
}
```

# 八、图

## （一）图（graph）的基本概念

### 1. 图的定义

图（graph）G由两个集合V（vertex）和E（edge）组成，记G=(V,E)，其中V是顶点的有限集合，记为V(G)；E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G)；如果表示边的顶点对（或序偶）是有序的，则图G为有向图（digraph），<i,j> 和 <j,i>是两条不同的边；如果表示边的顶点对是无序的，则图G为无向图（undirgraph），(i,j) 和 (j,i) 是同一条边

图的抽象数据类型定义如下：

```c++
ADT Graph {
    数据对象:
    	D = { ai | 1 <= i <= n, n >= 0, ai 为ElemType类型 }     // ElemType 是自定义类型标识符
    数据关系:
    	R = { <ai, aj> | ai、aj ∈ D, 1 <= i,j <= n, 其中每个元素可以有零或多个前驱元素，可以有零或多个后继元素 }
    基本运算:
        CreateGraph(&g);
        DestroyGraph(&g);
        DispGraph(g);
        DFS(g,v);     // 从顶点v出发深度优先遍历图g，Depth First Search
        BFS(g,v);     // 从顶点v出发广度优先遍历图g，Breadth First Search
        FirstNeighbor(g,x);		// 求图g中顶点x的第一个邻接点，若有则返回顶点编号，无则返回-1
    	NextNeighbor(g,x,y);	// 设y是图g中x的一个邻接点，返回除y以外x的下一个邻接点编号，若y是最后一个则返回-1
}
```

图的基本术语

1. 端点（endpoint）和邻接点（adjacent）：有向图中还分起始端点（简称起点）、终止端点（简称终点）、出边邻接点、入边邻接点
2. 顶点的度（degree）：一个顶点所关联的边的数目；有向图中还分入度（indegree）和出度（outdegree），之和为有向图顶点的度
3. 完全图（completed graph）：每两个顶点之间都存在着一条边，即任意两点之间课直接一次到达；无向图边数为n(n-1)/2，有向图边数为n(n-1)
4. 稠密图（dense graph）：当一个图接近完全图时（如e < n·log2(n))，稀疏图（sparse graph）
5. 子图（subgraph）：G'=(V',E') 其中V'是V的子集，E'是E的子集，则G'是G的子集；G的子图一定是个图，并非任意V和E的子集都能构成图
6. 路径（path）和路径长度（path length）：从i到j的路径是一个顶点序列；路径长度是一条路径上经过边的数目；若除了起点和终点外，不重走任一中间点的路径为简单路径（simple path）
7. 回路或环（cycle）：开始点与结束点为同一个顶点的路径；若还是简单路径，则为简单回路或简单环（simple cycle）
8. 连通、连通图（connected graph）（无向图中）：从i到j有路径则称为连通；图G中任意两点都连通则称为连通图，否则是非连通图；
   - 连通分量（connected component）：无向图G中极大连通子图称为G的连通分量，显然连通图的连通分量只有一个为自身，非连通图有多个连通分量
9. 强连通图（strongly connected graph）和强连通分量（strongly connected graph）：有向图中定义类似无向图中，需要求i到j和j到i都有连通
10. 权（weight）和网（net）：每一个边都可以附有一个对应的数值，称为权，这样的图为带权图（weighted graph），也称作网（net）

n (n > 2) 个顶点的强连通图边的取值范围： n <= e <= n(n-1)

### 2. 图的存储结构和基本运算算法

n各顶点物理编号：[0...n-1]

图的存储需要存储各个顶点本身的信息，还要同时存储顶点与顶点之间的所有关系（边的信息）

#### (1) 邻接矩阵（adjacency matrix）存储方法

用n阶方阵的位置\[i\]\[j\]表示i到j之间是否连接；不带权的用1表示连通，0表示不连通；带权的用w表示权，0表示对角线位置，∞表示不连通

```c++
const int MAXV = 50;     // 最大顶点个数
const int INF = INT_MAX;     // 定义∞
    
typedef char InfoType;     // 表示顶点的其他信息类型，此处为char

typedef struct {
    int no;     // 顶点的编号
    InfoType info;
} VertexType;     // 定点类型

typedef struct {
    int edges[MAXV][MAXV];     // 邻接矩阵，[i][j]表示 i->j 的边
    int n, e;     // n表示顶点数，e表示边数
    VertexType vexs[MAXV];     // 存放顶点信息
} MatGraph;     // 完整的图的邻接矩阵类型
```

#### (2) 邻接表（adjacency list）存储方法

对于含n个顶点（从0到n-1编号）的图，用长度为n的数值存储头结点（有值域data和指向相邻顶点的指针firstarc），其中组数下标即顶点编号；对于边结点，需存储它的顶点编号adjvex，下一个边结点的指针nextarc，和其边的权值weight

注：边结点顺序可任意，故邻接表存储方法不唯一；有向图默认连接的是顶点的出边

逆邻接表（inverse adjacency list）：在有向图的邻接表中对每个顶点连接的是指向该顶点的边（入边），以方便找指向某顶点的边

```c++
typedef struct Anode {
    int adjvexNo;     // 该边的邻接点编号
    struct Anode* nextArc;     // 指向下一个边结点的指针
    int weight;     // 该边的相关信息，如权重
} ArcNode;     // 边结点类型

typedef int InfoType;

typedef struct Vnode {
    InfoType info;     // 顶点的其他信息
    ArcNode* firstArc;     // 指向第一个边结点
} VNode;     // 邻接表的头结点类型

const int MAXV = 50;

typedef struct {
    VNode adjList[MAXV];     // 邻接表的头结点数组
    int n, e;    // n表示顶点数，e表示边数
} AdjGraph;      // 完整的图的邻接表类型
```

#### (3) 图基本运算算法设计

讨论的是邻接表的相关算法设计

```c++
// 引用图的邻接矩阵、邻接表存储方式
using dst::_8_2::_8_2_1::MatGraph;
using dst::_8_2::_8_2_1::INF;
using dst::_8_2::_8_2_1::MAXV;
using dst::_8_2::_8_2_2::ArcNode;
using dst::_8_2::_8_2_2::AdjGraph;
```

创建图的运算算法，根据邻接矩阵数组A，顶点个数n和边数e来建立图的邻接表G，扫描数组A查找不为0和∞的元素

```c++
void CreateAdj(AdjGraph*& G, int** edges, int n, int e) {
    ArcNode* p;
    G = (AdjGraph*)malloc(sizeof(AdjGraph));
    // 给邻接表中的所有头结点的指针域置初值
    for (int i = 0; i < n; G->adjList[i++].firstArc = NULL);     
    for (int i = 0; i < n; ++i) {
    	for (int j = n - 1; j >= 0; --j) {
    		// 检查邻接矩阵中的每个元素
    		if (edges[i][j] != 0 && edges[i][j] < INF) {
    			p = (ArcNode*)malloc(sizeof(ArcNode));     // 创建一个结点p
                p->adjvexNo = j;     // 邻接结点编号
                p->weight = edges[i][j];     // 存放权
                p->nextArc = G->adjList[i].firstArc;     // 采用头插法插入结点p
                G->adjList[i].firstArc = p;     // 采用头插法插入结点p
    		}
    	}
    }
    G->n = n;
    G->e = e;
}
```

输出图的运算算法

```c++
void DispAdj(AdjGraph* G) {
    ArcNode* p;
    for (int i = 0; i < G->n; ++i) {
    	printf("%d：", i);     // 输出结点编号
    	p = G->adjList[i].firstArc;
    	while (p != NULL) {
       		printf("=%d=>%d ", p->weight, p->adjvexNo);
        	p = p->nextArc;
    	}
    	printf("\n");
    }
}
```

销毁图的运算算法

```c++
void DestroyAdj(AdjGraph*& G) {
    ArcNode *pre, *p;
    for (int i = 0; i < G->n; ++i) {
    	pre = G->adjList[i].firstArc;
    	if (pre != NULL) {
    		p = pre->nextArc;
    		while (p != NULL) {
    			free(pre);
                pre = p;
                p = pre->nextArc;
    		}
    		free(pre);
    	}
    }
    free(G);
}
```

例8.2 对于具有n个顶点的图G，设计一个将邻接矩阵转换为邻接表的算法；设计一个将邻接表转换为邻接矩阵的算法；分析上述连个算法的时间复杂度 O(n^2) O(n + e)

设计一个将邻接矩阵转换为邻接表的算法，在图的邻接矩阵中查找不为0和∞的元素，类似Create算法

```c++
void MatToList(MatGraph g, AdjGraph*& G) {
    ArcNode* p;
    G = (AdjGraph*)malloc(sizeof(AdjGraph));
    // 给邻接表中的所有头结点的指针域置初值
    for (int i = 0; i < g.n; G->adjList[i++].firstArc = NULL);
    for (int i = 0; i < g.n; ++i) {
    	for (int j = g.n - 1; j >= 0; --j) {
    		// 检查邻接矩阵中的每个元素
            if (g.edges[i][j] != 0 && g.edges[i][j] < INF) {
                p = (ArcNode*)malloc(sizeof(ArcNode));
                p->adjvexNo = j;     // 顶点编号
                p->weight = g.edges[i][j];
                p->nextArc = G->adjList[i].firstArc;
                G->adjList[i].firstArc = p;     // 头插
    		}
    	}
    }
    G->n = g.n;
    G->e = g.e;
}
```

例8.2 (2)、设计一个将邻接表转换为邻接矩阵的算法

```c++
void ListToMat(AdjGraph* G, MatGraph& g) {
    ArcNode* p;
    g.n = G->n;
    g.e = G->e;
    for (int i = 0; i < g.n; ++i) {
        for (int j = 0; j < g.n; ++j) {
        	g.edges[i][j] = i == j ? 0 : INF;     // 不连通权值即为 ∞
        }
    }
    // 扫描所有的单链表
    for (int i = 0; i < G->n; ++i) {
        p = G->adjList[i].firstArc;
        while (p != NULL) {
            // 边的信息
            g.edges[i][p->adjvexNo] = p->weight;
            p = p->nextArc;
        }
    }
}
```

8.2.4 其他存储方法，十字链表（orthogonal list） 和 邻接多重表（adjacency multi-list）

## （三）图的遍历

为了避免同一个顶点被重复访问，用一个visited数组存储是否被访问过的信息

深度优先遍历（Depth First Search，DFS）、广度优先遍历（Breadth First Search，BFS）

```c++
using dst::_8_2::_8_2_2::AdjGraph;     // 引用邻接表存储结构
using dst::_8_2::_8_2_2::MAXV;
using dst::_8_2::_8_2_2::ArcNode;
```

基础算法，请勿显式调用

```c++
// 深度优先遍历，基本算法，若显式调用请查阅文档
static void base_DFS(AdjGraph* G, int v, bool* visited) {
    ArcNode* p;
    visited[v] = true;
    printf("%d ", v);     // 输出被访问的顶点编号
    p = G->adjList[v].firstArc;     // p指向顶点v的第一个邻接结点
    while (p != NULL) {
    	// 若邻接结点未被访问，访问之
    	if (visited[p->adjvexNo] == false) {
    		base_DFS(G, p->adjvexNo, visited);
    	}
    	p = p->nextArc;     // p指向v的下一个邻接点
    }
}

// 广度优先遍历，基本算法，若显式调用请查阅文档
static void base_BFS(AdjGraph* G, int v, bool* visited) {
    int queue[MAXV];     // 存放结点编号的队列，实现基于环形队列
    int front = 0, rear = 0;
    int frontNode;
    ArcNode* p;
    // 输出被访问的开始顶点的编号
    printf("%d ", v);
    visited[v] = true;
    queue[rear++] = v;     // 进队操作
    // 队不为空循环
    while (front != rear) {
    	frontNode = queue[front++];    // 出队一个顶点
    	p = G->adjList[frontNode].firstArc;
    	// 查找p的所有邻接顶点
    	while (p != NULL) {
    		if (visited[p->adjvexNo] == false) {
                printf("%d ", p->adjvexNo);
                visited[p->adjvexNo] = true;     // 设为已访问
                queue[rear++] = p->adjvexNo;     // 进队
    		}
    		p = p->nextArc;
    	}
    }
}
```

深度优先遍历：从初始点v出发，首先访问初始点v，然后选择一个与顶点v相邻且没有被访问过的顶点w，再以w为初始点进行深度优先遍历，直到顶点v的所有都被访问过为止

```c++
void DFS(AdjGraph* G, int v) {
    bool* visited = new bool[MAXV];
    memset(visited, false, MAXV * sizeof(bool));
    _8_3_Base::base_DFS(G, v, visited);
    printf("\n");
}
```

广度优先遍历：首先访问初始顶点v，接着访问顶点v的所有未被访问的邻接点v1，v2...，然后按照次序依次广度优先遍历v1，v2...，直到v的所有邻接点都被遍历过

```c++
void BFS(AdjGraph* G, int v) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    _8_3_Base::base_BFS(G, v, visited);
    printf("\n");
}
```

非连通图的遍历，深度优先遍历

```C++
void DFS_Non_Connected(AdjGraph* G) {
    bool* visited = new bool[MAXV];
    memset(visited, false, MAXV * sizeof(bool));
    for (int i = 0; i < G->n; ++i) {
    	if (visited[i] == false) {
    		printf("[ ");
    		_8_3_Base::base_DFS(G, i, visited);
    		printf("] ");
    	}
    }
    printf("\n");
}
```

非连通图的遍历，广度优先遍历

```c++
void BFS_Non_Connected(AdjGraph* G) {
    bool* visited = new bool[MAXV];
    memset(visited, false, MAXV * sizeof(bool));
    for (int i = 0; i < G->n; ++i) {
    	if (visited[i] == false) {
    		printf("[ ");
    		_8_3_Base::base_BFS(G, i, visited);
    		printf("] ");
    	}
    }
    printf("\n");
}
```

例8.3 假设图G采用邻接表存储，判断G是否连通

```c++
bool Connect(AdjGraph* G) {
    bool* visited = new bool[MAXV];
    memset(visited, false, MAXV * sizeof(bool));
	// 对图进行遍历，此处选DFS，然后根据visited数组是否已经全部访问，判断图是否连通
    _8_3_Base::base_DFS(G, 0, visited);
    for (int i = 0; i < G->n; ++i) {
        if (visited[i] == false) {
            return false;
        }
    }
    return true;
}
```

#### (1) 基于深度优先遍历算法的应用

为消除全局visited数组变量，使用*&传递visited数组，为所有需要全局visited数组算法提供基本算法 base_xxx( , ,..., visited)

基础算法，请勿显式调用

```c++
// 例8.4 base
static void base_8_4(AdjGraph* G, int u, int v, bool& has, bool* visited) {
    visited[u] = true;     // u已访问
    if (u == v) {
        has = true;     // 找到了一条路径
        return;
    }
    int w;     // 表示顶点u的相邻顶点
    ArcNode* p = G->adjList[u].firstArc;
    while (p != NULL) {
        w = p->adjvexNo;     // w为邻接点的编号
        if (visited[w] == false) {
        	base_8_4(G, w, v, has, visited);
        }
        p = p->nextArc;
    }
}

// 例8.5 base
// path不是用的引用，每次递归的所用的函数的path都不同，d表示路径中顶点的个数
static void base_8_5(AdjGraph* G, int u, int v, int path[], int d, bool* visited) {
    visited[u] = true;
    path[d++] = u;     // 路径长度增1，顶点u加入到路径中
    if (u == v) {
        // 找到路径，输出
        for (int i = 0; i < d - 1; ++i) {
        	printf("%d => ", path[i]);
    	}
    	printf("%d\n", path[d - 1]);
    	return;
    }
    int w;
    ArcNode* p = G->adjList[u].firstArc;
    // 依次遍历u的邻接点
    while (p != NULL) {
        w = p->adjvexNo;
        if (visited[w] == false) {
        	base_8_5(G, w, v, path, d, visited);
        }
        p = p->nextArc;
    }
}

// 例8.6 base
static void base_8_6(AdjGraph* G, int u, int v, int path[], int d, bool* visited) {
    visited[u] = true;
    path[d++] = u;     // 路径长度增1，顶点u加入到路径中
    if (u == v && d > 0) {
    	// 找到路径，输出
    	for (int i = 0; i < d - 1; ++i) {
    		printf("%d => ", path[i]);
    	}
    	printf("%d\n", path[d - 1]);
    }
    int w;
    ArcNode* p = G->adjList[u].firstArc;
    // 依次遍历u的邻接点
    while (p != NULL) {
    	w = p->adjvexNo;
    	if (visited[w] == false) {
    		base_8_6(G, w, v, path, d, visited);
    	}
    	p = p->nextArc;
    }
    visited[u] = false;
    // 调用结束后退栈，恢复至上一状态，因调用者中的 d 天然比被调用函数中的 d 小1，故不用d--
}

// 例8.7 base
static void base_8_7(AdjGraph* G, int u, int v, int l, int path[], int d, bool* visited) {
    visited[u] = true;
    path[d++] = u;     // 路径长度增1，顶点u加入到路径中
    if (u == v && d - 1 == l) {
        // 找到路径，输出，其中d为路径中顶点的个数，路径长度为d - 1
        for (int i = 0; i < d - 1; ++i) {
        	printf("%d => ", path[i]);
        }
    	printf("%d\n", path[d - 1]);
    }
    int w;
    ArcNode* p = G->adjList[u].firstArc;
    // 依次遍历u的邻接点
    while (p != NULL) {
        w = p->adjvexNo;
        if (visited[w] == false) {
        	base_8_7(G, w, v, l, path, d, visited);
        }
   		p = p->nextArc;
    }
    visited[u] = false;     // 恢复环境，使该顶点可在不同路径中重复使用
    // 调用结束后退栈，恢复至上一状态，因调用者中的 d 天然比被调用函数中的 d 小1，故不用d--
}

// 例8.8 base 根据教材，此处命名为 DFSPath(...)
static void DFSPath(AdjGraph* G, int u, int v, int path[], int d, bool* visited) {
    visited[u] = true;
    path[d++] = u;
    ArcNode* p = G->adjList[u].firstArc;
    int w;
    while (p != NULL) {
        w = p->adjvexNo;
        // 判断能够构成回路
        if (w == v && d >= 3) {
        	for (int i = 0; i < d; ++i) {
        		printf("%d => ", path[i]);
    		}
    		printf("%d\n", v);
    	}
    	if (visited[w] == false) {
    		DFSPath(G, w, v, path, d, visited);
    	}
    	p = p->nextArc;     // u的下一个邻接顶点
    }
    visited[u] = false;     // 恢复环境，使该顶点在其他路径中可重复使用
    // 调用结束后退栈，恢复至上一状态，因调用者中的 d 天然比被调用函数中的 d 小1，故不用d--
}
```

例8.4 采用邻接表存储的图G，判断G中从顶点u到v是否存在简单路径，采用深度优先遍历，判断当前顶点是否为终点，若是则置true并返回；has 表示 u 到 v 是否有路径，初始值为false

```c++
void ExistPath(AdjGraph* G, int u, int v, bool& has) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    _8_3_5_1_Base::base_8_4(G, u, v, has, visited);
}
```

例8.5 采用邻接表的图G，输出一条从顶点 u 到 v 的简单路径（假设存在），采用深度优先遍历，判断当前顶点是否为终点，若是则输出路径并结束

```c++
void FindAPath(AdjGraph* G, int u, int v) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    int path[MAXV];
    _8_3_5_1_Base::base_8_5(G, u, v, path, 0, visited);
}
```

例8.6 采用邻接表的图G，假设从 u 到 v 存在路径，输出所有简单路径，思路同例8.5，只不过找到终点输出路径后，不结束算法，而是继续回溯寻找，因此要在函数的最后恢复环境使visited[u] = false

```c++
void FindAllPath(AdjGraph* G, int u, int v) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    int path[MAXV];
    _8_3_5_1_Base::base_8_6(G, u, v, path, 0, visited);
}
```

例8.7 采用邻接表的图G，假设从 u 到 v 存在路径，输出所有长度为 l 的简单路径

```c++
void PathLenAll(AdjGraph* G, int u, int v, int l) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    int path[MAXV];
    _8_3_5_1_Base::base_8_7(G, u, v, l, path, 0, visited);
}
```

例8.8 采用邻接表存储的有向图G，求图中通过某顶点 k 的所有简单回路（若存在），简单回路即路径上顶点不重复，且第一个顶点与最后一个顶点相同的回路；利用回溯的深度优先搜索从u开始，若其相邻顶点w等于v，且路径长度大于1（路径上顶点数多于或等于3），则构成回路；经过某顶点k，则可以转换为求从 k 到 k 的路径

```c++
void FindCyclePath(AdjGraph* G, int k) {
    bool* visited = new bool[MAXV];     // 是否访问标志数组
    memset(visited, false, MAXV * sizeof(bool));
    int path[MAXV];
    _8_3_5_1_Base::DFSPath(G, k, k, path, 0, visited);
}
```

#### (2) 基于广度优先遍历算法的应用

例8.9 采用邻接表存储的图G，求不带权的无向连通图G中从顶点u到v的一条最短路径，广度优先遍历的访问过程是一层一层的，采用非环形队列来输出路径（逆序）

```c++
// 例8.9 所用的队列结构
typedef struct {
    int data;     // 顶点编号
    int parent;     // 前一个顶点在队列中的位置
} QUEUE;     // 非环形队列类型

void ShortPath(AdjGraph* G, int u, int v) {
    QUEUE qu[MAXV];     // 非环形队列
    int front = -1, rear = 0;
    bool* visited = new bool[MAXV];     // 标识是否访问过
    memset(visited, false, MAXV * sizeof(bool));
    qu[rear].data = u;     // 顶点u进队
    qu[rear++].parent = -1;
    visited[u] = true;
    ArcNode* p;
    int top;
    // 队不为空，循环
    while (front != rear) {
        top = qu[++front].data;
        if (top == v) {
        	// 找到v时输出
        	int i = front;
    		while (qu[i].parent != -1) {
    			printf("%d ", qu[i].data);
    			i = qu[i].parent;
    		}
    		printf("%d\n", qu[i].data);
    		return;
    	}
   		p = G->adjList[top].firstArc;
    	// 遍历队首结点的所有相邻结点
    	while (p != NULL) {
            if (visited[p->adjvexNo] == false) {
                visited[p->adjvexNo] = true;
                qu[rear].data = p->adjvexNo;
                qu[rear++].parent = front;
            }
            p = p->nextArc;
    	}
    }
}
```

例8.10 采用邻接表存储的图G，求不带权的无向连通图G中举例顶点v最远的一个顶点，返回其顶点编号；采用广度优先遍历，则最后遍历到的一个顶点即为最远的一个，因不需要输出路径，故可以采用环形队列

```c++
int MaxDist(AdjGraph* G, int v) {
    int Qu[MAXV];     // 用一维数组表示环形队列
    int front = 0, rear = 0;
    bool* visited = new bool[MAXV];
    memset(visited, false, MAXV * sizeof(bool));
    Qu[rear] = v;     // 顶点v进队
    rear = (rear + 1) % MAXV;
    visited[v] = true;
    ArcNode* p;
    int k, j;     // k表示队首结点，j表示其相邻结点
    while (front != rear) {
        k = Qu[front];      // 顶点k出队
        front = (front + 1) % MAXV;
        p = G->adjList[k].firstArc;
    	while (p != NULL) {
            j = p->adjvexNo;
            if (visited[j] == false) {
                visited[j] = true;
                Qu[rear] = j;     // 顶点j置为访问，且进队
                rear = (rear + 1) % MAXV;
    		}
    		p = p->nextArc;
    	}
    }
    return k;     // 由广度优先遍历所遍历的最后一个结点即为距离v最远的结点
}
```

8.3.5.3 用图遍历方法求解迷宫问题

8.3.5.4 深度优先遍历和广度优先遍历求解路径问题上的差异

## （四）生成树和最小生成树

生成树（spanning tree）和最小生成树（minimal spanning tree），无向图

### 1. 生成树的概念

一个连通图的生成树是一个含有全部顶点和(n-1)个边的极小连通子图（连通无回路），生成树边上权值之和最小的为最小生成树（minimal spanning tree）（不一定唯一）；最小生成树的准则有以下3条：

1. 必须使用图中的边来构造最小生成树
2. 必须使用且仅使用（n-1）条边来连接图中的n个顶点
3. 不能使用产生回路的边

求图的最小生成树的经典算法为普里姆算法（Prim） 和克鲁斯卡尔算法（Kruskal）

### 2. 无向图的连通分量和生成树

设 G = (V,E) 为连通图，则从图中任一点出发遍历图时必定将 E(G) 分成两个集合 T 和 B，其中 T 是遍历过程中走过的边的集合，B 是剩余边的集合：T ∩ B = 空集，T ∪ B = E(G)。显然，G' = (V, T) 是 G 的极小连通子图，即 G' 是 G 的一棵生成树

由深度优先遍历得到的生成树称为深度优先生成树（DFS tree），由广度优先遍历得到的生成树称为广度优先生成树（BFS tree）；对于非连通图，每个连通分量中的顶点集和遍历时走过的边一起构成一个生成树，各个连通分量的生成树组成生成森林（spanning forest）

### 3. 普里姆（Prim）算法

普里姆算法（无向连通图），采用邻接矩阵（由于需要频繁访问权值），O(n^2)，执行时间与图的边数e无关，适合稠密图；由 G 构造从起始点 v 出发的最小生成树 T 的步骤如下：

1. 初始化 U = { v }，以 v 到其他顶点的所有 邻接的边 作为 U <--> V-U 的侯选边
2. 重复以下步骤 n-1 次，使得其他的 n-1 个顶点被加入到 U 中
   1. 从 侯选边 中挑选出权值最小的边加入到 TE，设该边所连的在 V-U 中的顶点是 k，将 k 加入到 U 中；
   2. 调整剩余顶点集 V-U 中每个顶点 j <--> U 的侯选边，若 (k,j) 边的权小于原来和顶点 j 关联的侯选边，则用 (k,j) 作为 j 的侯选边

普里姆算法是一种增量的构造性算法，根据最小权的侯选边从剩余 V 中选择顶点加入到 U 中

假设 G = (V,E) 为具有 n 个顶点的带权连通图，T = (U,TE) 是 G 的最小生成树；U：生成树的顶点集，TE：生成树的边集，V-U：图中剩余顶点集，侯选边：为了求 U <--> V-U 权值最小的边

1. 由于是无向图，故可以只需考虑 V-U 剩余顶点的集合，对于 V-U 中编号为 j 的顶点，用两个数组closestNode[j]：表示距离 顶点j 的最近顶点编号，lowestWeight[j]：表示 顶点j 所有相邻边的 最小权值，故 顶点j 的最小边为 (closestNode[j], j)，对应的权为 lowestWeight[j]
2. 为确定一个 顶点i 是属于 U 集合还是 V-U 集合，规定：用 lowestWeight[i] = 0 表示 顶点i 属于 生成树顶点集合U，lowestWeight[i] != 0 表示 顶点i 属于剩余顶点集合V-U
3. 初始时，U 中只有一个顶点 v，对于其他所有顶点 i，这时 (v,i) 就是 顶点i 到 U 的最小边，置 lowestWeight[i] = g.edges\[v][i]，closestNode[i] = v
4. 扫描剩下的 V-U集合 中的所有顶点，根据最小的 lowestWeight[k] 求出顶点 k，那么 (closestNode[k], k) 即最小边，输出之（访问操作），将 k 加入到生成树顶点集 U 中，即置 lowestWeight[k] = 0
5. 调整，即修改在 V-U集合 中的所有（需要修改的）顶点 j <--> U 的侯选边，因为 U 的变化仅仅时因为多了刚刚加入的 k，所以只需要比较 lowestWeight[j] 与 g.edges\[k][j]，判断 最小权lowestWeight[j] 和 最近顶点closestNode[j] 是否需要修改

引用图的邻接矩阵存储

```c++
using dst::_8_2::_8_2_1::MatGraph;
using dst::_8_2::_8_2_1::INF;
using dst::_8_2::_8_2_1::MAXV;
```

普里姆算法（无向连通图），采用邻接矩阵（由于需要频繁访问权值）

```c++
void Prim(const MatGraph& g, int v) {
    int closestNode[MAXV];     // 顶点的最近相邻顶点编号
    int lowestWeight[MAXV];     // 顶点的最小权值
    int minWeight;     // 最小权值
    int k;     // 当前处理中的最近顶点
    // 为 lowestWeight 和 closestNode 数组置初值
    for (int i = 0; i < g.n; ++i) {
    	lowestWeight[i] = g.edges[v][i];
    	closestNode[i] = v;
    }
    // n-1 次循环用于将剩下的 n-1 个顶点加入到 生成树顶点集U 中
    for (int iter = 1; iter < g.n; ++iter) {
    	minWeight = INF;
    	// 在 V-U 中找出离 U 最近的顶点 k
    	for (int i = 0; i < g.n; ++i) {
    		if (lowestWeight[i] != 0 && minWeight > lowestWeight[i]) {
    			minWeight = lowestWeight[i];
    			k = i;
    		}
    	}
        // 输出最小生成树的一条边的信息
    	printf("[ (%d,%d) : %d ]\n", closestNode[k], k, minWeight);     
    	lowestWeight[k] = 0;     // 标记 k 已经加入到 U 当中
    	// 调整剩下的 V-U 中顶点的 侯选边 和 最近相邻顶点
    	for (int j = 0; j < g.n; ++j) {
            if (lowestWeight[j] != 0 && lowestWeight[j] > g.edges[k][j]) {
                lowestWeight[j] = g.edges[k][j];
                closestNode[j] = k;
    		}
    	}
    }
}
```

### 4. 克鲁斯卡尔（Kruskal）算法

克鲁斯卡尔算法，采用邻接矩阵（需要频繁的访问一条边的权值），由 G 构造最小生成树 T 的步骤如下：

1. 置 U 的初值为 V，（即包含有 G 中的全部顶点），TE 的初值为空集（即 生成树T 中的每个顶点都构成一个分量）
2. 将图 G 中的边按权值从小到大的顺序依次选取，若选取的边未使生成树 T 形成回路，则加入 TE，否则舍弃，直到 TE 中包含 n-1 条边为止

克鲁斯卡尔算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法，假设 G = (V,E) 为具有 n 个顶点的带权连通图，T = (U,TE) 是 G 的最小生成树；U：生成树的顶点集，TE：生成树的边集

1. 如何判断选取的一条边 (i,j) 加入到 T 中是否出现回路，可以通过判断顶点 i、j 是否属于同一个连通分量的方法来解决
2. 设置一个辅组数组 vest[0...n-1]，用 vest[i] 表示一个顶点 i 所在的连通分量的编号
3. 初始时，每个顶点构成一个连通分量，令 vest[i] = i（所有顶点的连通分量的编号等于该顶点的编号）
4. 若选中的边 (i,j) 的 vest[i] != vest[j] 时表示不会形成回路，可以加入到生成树 T 中，然后将这两个顶点所在的连通分量中所有顶点的连通分量编号改为相同（vest[i] 或 vest[j]均可）

用一个数组 E[] 存放 图G 中的所有边，要求他们是按权值从小到大的顺序排序

```C++
typedef struct {
    int startNo;     // 边的起始节点编号
    int endNo;     // 边的终止顶点编号
    int weight;     // 边的权值
} Edge;     // 边类型
```

所依赖的数据结构和算法如下：

```c++
// 直接插入排序，键值类型为边的权值
void InsertSort(Edge E[], int n);
// 堆排序筛法，大根堆
void sift(Edge E[], int lowIndex, int highIndex);
// 堆排序（递增排序）
void HeapSort(Edge E[], int n);

// 为了方便，采用顺序方法存储森林，其中结点的类型声明如下
typedef struct {
    int data;     // 结点对应元素的编号
    int rank;     // 结点对应的秩
    int parent;     // 结点对应双亲在结点数组中的下标
} UFSTree;

// 并查集树的初始化
void MAKE_SET(UFSTree t[], int n);
// 查找一个元素所属的集合
int FIND_SET(UFSTree t[], int x);
// 两个元素各自所属的集合的合并
void UNION(UFSTree t[], int x, int y);

// 引用图的邻接矩阵存储
using dst::_8_2::_8_2_1::MatGraph;
using dst::_8_2::_8_2_1::INF;
using dst::_8_2::_8_2_1::MAXV;
const int MaxEdgeSize = MAXV * MAXV;     // 最大边的个数
```

克鲁斯卡尔算法（标准版），采用邻接矩阵（需要频繁的访问一条边的权值）

```c++
void Kruskal_standard(const MatGraph& g) {
    int edgeNo = 0;     // 可以表示当前处理的边在边数组中的索引，也表示已经加入到TE中的边的个数
    int startNo, endNo, startSetNo, endSetNo, iter = 0;     // 初始、终止顶点编号，初始、终止顶点所在连通分量编号，遍历用变量
    int vest[MAXV];     // vest 表示顶点所在连通分量的编号
    Edge E[MaxEdgeSize];     // 边的数组

    // 初始化 vest 数组
    for (int i = 0; i < g.n; ++i) {
    	vest[i] = i;
    }
    // 初始化边的数组 E[]
    for (int i = 0; i < g.n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (g.edges[i][j] != 0 && g.edges[i][j] < INF) {
                E[edgeNo].weight = g.edges[i][j];
                E[edgeNo].startNo = i;
                E[edgeNo].endNo = j;
                ++edgeNo;
    		}
    	}
    }
    dep::InsertSort(E, g.e);
    edgeNo = 0;     // 初始 TE 中边数为 0 个，每加入一个增1，直到 n-1 条边
    iter = 0;
    while (edgeNo < g.n - 1) {
        startNo = E[iter].startNo;     // 取 iter 边的信息
        endNo = E[iter].endNo;
        startSetNo = vest[startNo];
        endSetNo = vest[endNo];
        // 如果两个顶点属于不同的连通分量，表示他们的边可以加入到 TE 中
        if (startSetNo != endSetNo) {
            // 输出最小生成树的一条边的信息
            printf("[ (%d,%d) : %d ]\n", startNo, endNo, E[iter].weight);     
            ++edgeNo;
            // 将两个顶点所在的集合合并，即统一编号
            for (int i = 0; i < g.n; ++i) {
                if (vest[i] == endSetNo) {
                    vest[i] = startSetNo;     // 将编号为 endSetNo 的改为 startSetNo
                }
            }
        }
        ++iter;     // 扫描下一条边
    }
}
```

克鲁斯卡尔算法（改进版），采用邻接矩阵（需要频繁的访问一条边的权值）；优化：采用并查集进行连通分量的合并，采用堆排序代替直接插入排序初始化边的数组

```c++
void Kruskal(const MatGraph& g) {
    dep::UFSTree t[MaxEdgeSize];     // 并查集，用于判断某顶点所在的集合
    Edge E[MaxEdgeSize];     // 边的数组
    int edgeNo = 0;
    int startNo, endNo, startSetNo, endSetNo, iter = 0;
    // 初始化边的数组
    for (int i = 0; i < g.n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (i != j && g.edges[i][j] < INF) {
                E[edgeNo].weight = g.edges[i][j];
                E[edgeNo].startNo = i;
                E[edgeNo].endNo = j;
                ++edgeNo;
            }
        }
    }

    // 并查集的元素类型为 int 型（从0开始），而图中顶点的编号也是从0开始的int型（两者一一对应，不需额外的映射）
    // 故并查集中的元素为顶点的编号，而顶点的编号标识唯一的顶点
    dep::MAKE_SET(t, g.n);     // 初始化并查集
    dep::HeapSort(E, g.e);     // 对边的数组递增排序

    edgeNo = 0;
    // 构造剩下的 n-1 条边
    while (edgeNo < g.n - 1) {
        startNo = E[iter].startNo;
        endNo = E[iter].endNo;
        startSetNo = dep::FIND_SET(t, startNo);
        endSetNo = dep::FIND_SET(t, endNo);
        if (startSetNo != endSetNo) {
            // 输出最小生成树的一条边的信息
        	printf("[ (%d,%d) : %d ]\n", startNo, endNo, E[iter].weight);
        	++edgeNo;
        	dep::UNION(t, startNo, endNo);
        }
        ++iter;
    }
}
```

## （五）最短路径（有向图）

### 1. 路径的概念

路径长度：把一条路径上所经边的权之和定义为该路径的路径长度

最短路径：从源点到终点的路径可能不止一条路径，把路径长度最小的那条路径称为最短路径，其路径长度（权之和）称为最短路径长度

求图的最短路径问题有两个方面：某一顶点到其余各顶点的最短路径 和 求图中每一对顶点之间的最短路径

### 2. 狄克斯特拉（Dijkstra）算法

从一个顶点到其余各顶点的最短路径；给定一个带权有向图 G 与源点 v，求从源点 v 到 G 中其他顶点的最短路径，并限定各边上的权值大于0。

狄克斯特拉（Dijkstra）算法基本思想如下：

1. 设 G = (V,E) 是一个带权有向图，集合 V 分为两部分：S（已求出最短路径的顶点集合，初始时只有一个源点），U（其余未确定最短路径的顶点集合）
2. 按路径长度的递增次序把 U 中的顶点 u 加入到 S 中，每求得一条最短路径 v, ..., u，就将顶点 u 加入到集合 S 中，直到全部顶点都加入到S

Dijkstra 算法（采用图的邻接矩阵存储方法，需要频繁访问权值）的具体步骤如下：

1. 初始时 S 只包含源点，即 S = { v }，源点 v 到自己的距离为 0，U 包含除源点 v 以外的其他顶点，源点 v 到 U 中任一顶点 i 最短路径的长度为边 <v,i> 上的权
2. 从 U 中选取一个顶点 u，使源点 v --> u 的最短路径长度为最小，然后把顶点 u 加入到 S 中
3. 以顶点 u 为新考虑的中间点，修改源点 v 到 U 中所有顶点的最短路径长度，即路径调整：v --> j = MIN { Cvu + Wuj, Cvj }
4. 重复步骤 2 和 3，直到 S 中包含所有的顶点

狄克斯特拉（Dijkstra）算法：

1. 用一个一维数组 dist[j] 表示从源点 v --> j 的最短路径长度；inS[j] 表示顶点 j 是否在集合 S 中；preNode[j] 表示 v --> j 最短路径上顶点 j 的前一个顶点编号，没有通路时暂置为-1
2. 在执行中，一个顶点一旦加入到 S 中后，其最短路径长度不再改变，故Dijkstra算法不适合含有负权值的带权图求单源最短路径
3. 按顶点进入 S 的先后顺序最短路径长度越来越长

```c++
// 引用图的邻接矩阵存储
using dst::_8_2::_8_2_1::MatGraph;
using dst::_8_2::_8_2_1::INF;
using dst::_8_2::_8_2_1::MAXV;
```

输出单源最短路径

```c++
void DisPath(bool inS[], int dist[], int preNode[], int n, int v) {
    int path[MAXV];     // 存储源点 v 到某一顶点 i 的最短路径
    int index;     // 路径中顶点的索引
    int preNodeInPath;
    // 循环输出源点 v 到顶点 i 的最短路径
    for (int i = 0; i < n; ++i) {
        // 当顶点 i 在 S 中（与源点 v 能连通）且 i 不为源点 v 时处理
        if (inS[i] == true && i != v) {
            printf("[ %d =%d=> %d ]: ", v, dist[i], i);
            index = 0;
            path[index] = i;     // 添加终点，逆序
            preNodeInPath = preNode[i];
        	if (preNodeInPath == -1) {
        		printf("null\n");     // 没有通路，即无路径的情况
        	} else {
   				while (preNodeInPath != v) {
                    // 当路径上前一个点不为起点时，依次添加到 path[]
                    path[++index] = preNodeInPath;     
                    preNodeInPath = preNode[preNodeInPath];
    			}
    			path[++index] = v;     // 添加起点
    			while (index > 0) {
    				printf("%d --> ", path[index--]);
    			}
    			printf("%d\n", path[index]);
    		}
    	}
    }
}
```

Dijkstra 算法（采用图的邻接矩阵存储方法，需要频繁访问权值）

```c++
void Dijkstra(const MatGraph& g, int v) {
    bool inS[MAXV];     // 标识顶点 i 是否在集合 S 当中
    int dist[MAXV];     // 表示顶点 i 到源点 v 的最短距离
    int preNode[MAXV];     // 表示 v --> j 最短路径上的 j 的前一个顶点
    int minPathLength, u;    // 当前最短路径长度 和 当前处理的顶点 u
    
    // 初始化各种信息
    for (int i = 0; i < g.n; ++i) {
        inS[i] = false;
        dist[i] = g.edges[v][i];
        preNode[i] = g.edges[v][i] < INF ? v : -1;     // -1 表示暂时不连通
    }
    inS[v] = true;      // 初始化源点的信息
    preNode[v] = v;     // different with text: v <==> 0
    
    // 循环 n-1 次，将剩下的 n-1 各顶点加入到 S 中
    for (int iter = 0; iter < g.n - 1; ++iter) {
        minPathLength = INF;
        for (int i = 0; i < g.n; ++i) {
            // 选取不在 S 中（即在 U 中）且具有最小最短路径长度的顶点 u
            if (inS[i] == false && minPathLength > dist[i]) {
            	minPathLength = dist[i];
            	u = i;
        	}
    	}
    	inS[u] = true;     // 顶点 u 加入到 S 中
    	for (int i = 0; i < g.n; ++i) {
    		// 修改不在 S 中（即在 U 中）的顶点的最短路径
    		if (inS[i] == false && g.edges[u][i] < INF && dist[u] + g.edges[u][i] < dist[i]) {
    			dist[i] = dist[u] + g.edges[u][i];
    			preNode[i] = u;
    		}
    	}
    }
    DisPath(inS, dist, preNode, g.n, v);     // 输出源点到各点的最短路径
}
```

### 3. 弗洛伊德（Floyd）算法

每对顶点之间的最短路径；对于一个各边权值均大于零的有向图，对每一对顶点 i != j，求出顶点 i --> j 之间的最短路径和最短路径长度。

可循环 n 次使用狄克斯特拉算法；也可以用弗洛伊德（Floyd）算法：从全局考虑，不用从局部考虑 + 调整。

弗洛伊德算法基本思想：

1. 用一个二维数组 A[][] 存放当前顶点之间的最短路径长度，分量 A\[i\]\[j\] 表示当前 i --> j 的最短路径长度
2. 递推产生一个矩阵序列 A0, A1, ..., A(n-1)， 其中 Ak\[i\]\[j\] 表示 i --> j 的路径上所经过的顶点编号不大于 k 的最短路径长度

弗洛伊德算法：

1. 初始时有 A(-1)\[i][j] = g.edges\[i][j]；有数学归纳法，若 A(k-1)\[i][j] 已求出，
2. 现在考查顶点 k，求 i --> j 上所有经过的顶点编号不大于 k 的最短路径长度 Ak\[i\]\[j\]，此时 i --> j 路径有两条：
3. 即上一次迭代出的不考虑顶点 k 的最短路径长度 A(k-1)\[i][j] 和考虑 k 之后的长度 A(k-1)\[i][k] + A(k-1)\[k][j]，更新 Ak\[i][j] 使之最短，即：Ak\[i][j] = MIN { A(k-1)\[i][j], A(k-1)\[i][k] + A(k-1)\[k][j] } : 0 <= k <= n-1
4. 上式是一个迭代表达式，每迭代一次，i --> j 的最短路径上就多考虑了一个顶点，经过 n 次迭代后所得的 A(n-1)\[i][j] 值就是所求最终解
5. 另外用一个二维数组 preNode\[i][j] 来保存当前 i --> j 最短路径上的顶点 j 之前的顶点编号（考虑顶点k时，即有preNode\[i\]\[j\] = preNode\[k\]\[j\]），用 -1 表示无路径

```C++
// 引用图的邻接矩阵存储
using dst::_8_2::_8_2_1::MatGraph;
using dst::_8_2::_8_2_1::INF;
using dst::_8_2::_8_2_1::MAXV;
```

输出最短路径

```c++
void DisPath(const MatGraph& g, int** A, int** preNode) {
    int path[MAXV];     // 存放一条最短路径中的顶点编号（逆向）
    int index;     // 路径中顶点的索引
    int preNodeInPath;
    // 遍历矩阵输出最短路径
    for (int i = 0; i < g.n; ++i) {
    	for (int j = 0; j < g.n; ++j) {
    		if (A[i][j] < INF && i != j) {
    			// 若 i --> j 之间存在路径
    			printf("[ %d =%d=> %d ]: ", i, A[i][j], j);
    			index = 0;
    			path[index] = j;     // 终点
    			preNodeInPath = preNode[i][j];     // 最短路径上 j 的前一个顶点
    			while (preNodeInPath != -1 && preNodeInPath != i) {
    				path[++index] = preNodeInPath;
    				preNodeInPath = preNode[i][preNodeInPath];
    			}
    			path[++index] = i;     // 起点
    			for (int k = index; k > 0; printf("%d --> ", path[k--]));
    			printf("%d\n", path[0]);
    		}
    	}
    }
}
```

弗洛伊德（Floyd）算法：

```c++
void Floyd(const MatGraph& g) {
    const int N = g.n;     // 顶点数量（编号为 0...n-1）
    // 数组 A[][] 和 preNode[][]
    int** A = new int*[N];
    int** preNode = new int*[N];
    // 初始化数组信息
    for (int i = 0; i < N; ++i) {
        A[i] = new int[N];
        preNode[i] = new int[N];
        for (int j = 0; j < N; ++j) {
        	A[i][j] = g.edges[i][j];
            // i --> j 直接有边时 和 无直接边时
        	preNode[i][j] = (i != j && g.edges[i][j] < INF) ? i : -1;
    	}
    }
    // 依次考查所有顶点 k，迭代矩阵
    for (int k = 0; k < N; ++k) {
    	// i j 遍历矩阵
    	for (int i = 0; i < N; ++i) {
    		for (int j = 0; j < N; ++j) {
    			// 考查顶点 k，注意检查溢出
    			if (/*A[i][k] / 2 + A[k][j] / 2 < INF*/(A[i][k] < INF && A[k][j] < INF) && A[i][k] + A[k][j] < A[i][j]) {
                    // 修改最短路径长度 和 最短路径上前一个顶点
   					A[i][j] = A[i][k] + A[k][j];
    				preNode[i][j] = preNode[k][j];
    			}
    		}
    	}
    }
    DisPath(g, A, preNode);     // 输出最短路径
}
```

## （六）拓扑排序（topological sort）

设 G = (V,E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 v1, v2, ..., vn 称为一个拓扑序列（topological sequence）；若 <vi,vj> 是图中的一条边或路径，则在该序列中顶点 vi 必须排在顶点 vj 之前。

在一个有向图中找一个拓扑序列的过程称为拓扑排序（topological sort），用顶点表示活动，用有向边表示活动之间优先关系的有向图称为顶点表示活动的网（activity on vertex newtork，AOV网）

```c++
// 采用邻接表作为存储结构
using _8_2::_8_2_2::AdjGraph;    // 采用 AdjGraph->adjList[i].info 表示顶点的入度
using _8_2::_8_2_2::MAXV;
using _8_2::_8_2_2::ArcNode;
```

对AOV网进行拓扑排序的方法如下：

1. 从有向图中选择一个没有前驱（即入度为0）的顶点并输出
2. 从图中删去该顶点，并且删除从该顶点出发的全部的有向边（将所有后继顶点的入度减1）
3. 重复上述两步，直到剩余的图中不再存在没有前驱的结点为止

结果有两种：顶点全部输出，部分顶点输出（图中存在回路）（可用于检查图中是否存在回路）

```c++
void TopoSort(AdjGraph* G) {
    int St[MAXV];     // 栈存储入度为零的顶点
    int top = -1;
    int nodeNo;
    ArcNode* p;
    for (int i = 0; i < G->n; G->adjList[i++].info = 0);      // 入度初始值为 0
    	// 求所有顶点的入度
    	for (int i = 0; i < G->n; ++i) {
    		p = G->adjList[i].firstArc;
    		while (p != NULL) {
    			++G->adjList[p->adjvexNo].info;
    			p = p->nextArc;
    		}
    	}
    	// 将入度为零的顶点进栈
    	for (int i = 0; i < G->n; ++i) {
    		if (G->adjList[i].info == 0) {
    		St[++top] = i;
    	}
    }
    // 栈不空循环
    while (top > -1) {
        nodeNo = St[top--];     // 出栈一个顶点 nodeNo
        printf("%d", nodeNo);
        p = G->adjList[nodeNo].firstArc;
    	while (p != NULL) {
    		// 将顶点 nodeNo 的所有出边邻接点的入度减1，若入度为零则进栈
    		if ((--G->adjList[p->adjvexNo].info) == 0) {
    			St[++top] = p->adjvexNo;
    		}
    		p = p->nextArc;
    	}
    	top == -1 ? printf("\n") : printf(" --> ");
    }
}
```

## （七）AOE网与关键路径

### 1. 相关概念

- 用有向无环图（directed acycline graph，DAG）描述工程的预计进度，以顶点表示事件，边e的权c(e)表示完成活动e所需的时间或持续时间；图中入度为0的顶点表示工程的 开始事件，出度为0的顶点表示工程的 结束事件，这样的有向图为 边表示活动的网（activity on egde network，AOE网）
- 表示工程的AOE网只有一个入度为0的顶点，称为源点（source），若存在多个入度为0的顶点，可加一个虚拟源点，其到原入度为0的点都有一条长度为0的边；出度为0的顶点同理，称为汇点（converge）
- 在AOE网中，若存在两条首尾相接的边 ai = <v,w> 和 aj = <w,z>，则称活动 ai 是活动 aj 的前驱活动，aj 是 ai 的后继活动；显然，只有当活动 aj 的所有前驱活动都完成后，事件 w 才发生（这里 w 是 边aj 的头），且活动 aj 才开始
- 当 w 的所有入边表示的事件完成时，事件 w 就发生了，活动 aj 就可以开始了，故称 事件w 为 活动aj 的触发事件
- 在AOE网中，从源点到汇点的所有路径中具有最大路径长度的路径称为关键路径（critical path），可能存在多条，但他们的长度是相同的；关键路径上的活动称为关键活动（key activity），关键活动不存在富余时间，非关键活动存在富余时间；只要找出AOE网中的所有关键活动也就找到了全部的关键路径
- 假设 事件x 是源点，事件y 是汇点，并规定事件 x 的发生时间为0，定义图中任一 事件v 的最早（event early）开始时间ve(v) 等于 x到v 的最长路径的长度，即：ve(v) = MAX { c(<x..v>) }，其中 c<x..v> 表示 x \==> v 的路径长度；完成整个工程所需的事件的最少时间等于汇点y的最早开始时间 ve(y)；
- 为不影响工程进度，使 事件v 尽可能早的开始，在 x \==> v 的最长路径上的活动必须一刻不停的进行，一旦触发事件发生，便立即开始；而不在最长路径上的活动，即使稍微推迟一些时间发生也不影响工程进度；
- 定义在不影响整个工程进度的前提下，事件v 必须开始的时间称为 v 的最迟（event late）开始时间，记作 vl(v)，那么 vl(v) 应等于 整个工程时间 - v到汇点结束的最长路径，即：vl(v) = ve(y) - MAX { c<v..y> }；显然，ve(x) = vl(x) = 0，ve(y) = vl(y)
- 只要计算出各顶点 ve() 和 vl() 值，就有办法找出所有的关键活动，为便于计算，引入下面两个递推式：
  - 对于 x \=\==> vi --ai--> wi \=\==> y，其中 vi 和 wi 为连个相连的事件，ai为其之间的活动；ve(x) = 0；ve(w) = MAX { ve(vi) + c(<vi,w>) }（ w != x） （递推式8.4）
  - vl(y) = ve(y)；vl(v) = MIN { vl(wi) - c(<v,wi>) }（v != y） 递推式8.5
- 只要从 源点x 起按照顶点的拓扑序列次序重复运用 递推式8.4，即可求出 各个顶点w 的 ve(w) 值；只要从 汇点y 起按照顶点的拓扑序列的逆序重复运用 递推式8.5，即可求出 各个顶点v 的 vl(v) 值
- 对于任何 x \==> v --ai--> w \==> y 应有：x --> v 最长路径 + c(<v,w>) <=（早完成于）w的最迟开始时间，即：ve(v) + c(ai) <= vl(w) 式8.3
- 若上式取等号：ve(v) + c(ai) = vl(w)，表示 w 最迟就应该在 事件v 和 活动ai 完成后开始（不能等，没有富余时间），即活动 ai 为关键活动；用 式8.3 判断各活动是否为关键活动

### 2. 求AOE网的关键活动 

x \==> v --ai--> w \==> y

1. 对于源点 x，置 ve(x) = 0
2. 对AOE网进行拓扑排序，如发现回路，工程无法进行，退出
3. 按拓扑次序重复用 式8.4 依次求其余各顶点 v 的 ve(v) 值
4. 对于汇点 y，置 vl(y) = ve(y)
5. 按拓扑次序的逆序重复用 式8.5 依次求其余各顶点 v 的 vl(v) 值（ vl(x) = 0 ）
6. 设 e(ai) 表示 活动ai 的最早开始时间，定义为该活动起点的最早开始时间，即 e(ai) = ve(v)
7. 设 l(ai) 表示 活动ai 的最迟开始时间，定义为该活动终点的最迟开始时间 前推 该活动所需时间，即 l(ai) = vl(w) - c(ai)
8. 设 d(ai) 表示 活动ai 的时间余量（在不增加整个工程完工所需总时间的情况下活动 ai 可以拖延的时间），定义为最迟开始时间 减去 最早开始时间，即 d(ai) = l(ai) - e(ai)
9. 当一个活动的时间余量为零时，说明该活动必须立即完成，否则就会拖延完成整个工程的进度，故 d(ai) = 0，即 e(ai) = l(ai) 表示活动 ai 为关键活动

# 九、查找

## （一）查找（search）的基本概念

被查找的对象是由一组元素（或记录）组成的表或文件，每个元素由若干数据项组成，其中指定一个数据项为关键字（key）（取值唯一）；查找（search）就是给定一个元素 e 或值 k，在含有 n 个元素的表中找出关键字等于 e.key 或 k 的元素。

若在查找的同时对表做修改操作（如插入或删除）则称为 动态查找表（dynamic search table）；反之为 静态查找表（static search table）；若整个查找过程都在内存中进行，则称为 内查找（internal search）；若需访问外存，则称为 外查找（external search）

在查找中时间主要花费在关键字比较上，把平均需要和给定值进行比较的关键字次数称为平均查找长度（Average Search Length，ASL），ASL = ∑\[i=1..n](pi * ci)；其中，n 是查找元素的个数；其中 pi 是查找第 i 个元素的概率，通常假设每个元素查找的概率相等为 1/n；其中 ci 是找到第 i 个元素所需的关键字比较次数；ASL 分为查找成功情况下的 ASL(ok) 和查找不成功（失败）情况下的 ASL(fault)

## （二）线性表的查找

顺序查找（sequential search）、折半查找（binary search）、分块查找（block search）

查找与数据的存储结构有关，线性表有顺序表和链式两种存储结构，这里只介绍以顺序表作为存储结构的算法，顺序表属于静态查找表；查找成功返回找到的元素的逻辑序号，失败时返回 0

为了算法通用，用于查找运算的顺序表采用数组表示，该数组元素的类型声明如下：

```c++
typedef int KeyType;     // 关键字类型
typedef int InfoTyoe;     // 其他数据项类型
typedef struct {
    KeyType key;
    InfoTyoe data;
} RecType;     // 查找元素的类型
```

### 1. 顺序查找（sequential search）

顺序查找，O(n)，ASL = (n + 1) / 2

```c++
int SeqSearch(RecType R[], int n, KeyType k) {
	int i;
	for (i = 0; i < n && R[i].key != k; ++i);     // 从表头往后找
	return i >= n ? 0 : i + 1;     // 未找到返回0，找到返回逻辑序号
}
```

因为是顺序的，所以第 i 个元素需要比较 i 次，即 ci = i；ASL = ∑\[i=1..n](pi * ci) = (1/n) * ∑\[i=1..n](i) = (1/n) * n(n+1) / 2 = (n+1) / 2

顺序查找，在 R 的末尾增加一个关键字为 k 的记录，称之为哨兵，这样查找过程不再需要判断 i 是否越界，从而提高查找速度

```c++
int SeqSearch1(RecType R[], int n, KeyType k) {
    R[n].key = k;
    int i;
    for (i = 0; R[i].key != k; ++i);
    return i == n ? 0 : i + 1;
}
```

### 2. 折半查找（binary search）

折半查找又称为二分查找，要求表为有序表，此处假设有序表是递增有序的，O(log2(n))，ASL = log2(n + 1) - 1

基本思路：设 R[left...right] 是当前查找区间，确定中间位置 mid = ⌊(left+right) / 2⌋，比较 k 和 R[mid].key

- 若 k == R[mid].key，则说明查找成功，返回该元素逻辑序号
- 若 k < R[mid].key，说明要查找元素还在mid左侧，故令 right = mid - 1，更新当前查找区间
- 若 k > R[mid].key，说明要查找元素还在mid右侧，故令 left = mid + 1，更新当前查找区间

```c++
int BinSearch(RecType R[], int n, KeyType k) {
    int left = 0, right = n - 1, mid;
    // 当前区间存在元素时循环
    while (left <= right) {
    	mid = (left + right) / 2;
    	if (k == R[mid].key) {
    		return mid;     // 查找成功返回逻辑序号
    	} else if (k < R[mid].key) {
    		right = mid - 1;
    	} else {
    		left = mid + 1;
    	}
    }
    // right < left && right + 1 == left
    // R[right] < k < R[left]
    return -1;
}
```

折半查找的过程可用二叉树来描述，把当前查找区间的中间位置上的元素作为根，有左子表和右子表构造的的二叉树分别作为根的左子树和右子树，由此得到的二叉树称为描述折半查找过程的判定树（decision tree）或比较树（comparsion tree）；判定树中查找成功对应的结点称为内部结点，而查找失败对应的结点称为外部结点

折半查找判定树的形态只与表元素个数 n 相关，而与输入实例中的 key 取值无关；判定树高度近似为 h = log2(n+1)，树中第 i 层上的结点个数为 2^(i-1)，查找该层上的每个结点恰好需要进行 i 次比较，ASL = ∑\[i=1..n](pi * ci) = (1/n) * ∑\[i=1..h](2^(i-1) * i) = ((n+1) / n) * log2(n+1) - 1 ≈ log2(n+1) - 1

### 3. 索引存储结构和分块查找

索引存储结构（index storage structure）是在存储数据的同时还建立附加的索引表，索引表的每一项称为索引项，其一般形式为（关键字，地址）；其中，关键字唯一标识一个结点，地址作为指向该关键字对应结点的指针（也可以是相对地址，如数组下标）

索引存储结构可以提高关键字查找元素的效率，其缺点是需要建立索引表而增加时间和空间的开销

分块查找（bolck search）要求按如下索引的方式来存储线性表：

1. 将表 R[0...n-1] 均分为 b 块，每块元素个数为s = ⌈n/b⌉，最后一块可能不足 s 个元素
2. 每一块中的关键字不一定有序，但整个表应该是“分块有序”的（前一块中的最大 应小于 后一块中的最小）
3. 抽取各块中最大的关键字及该块的起始位置构成一个索引表 IDX[0...b-1]，IDX[i]（0 <= i <= b-1）存放着第 i+1 块的最大关键字 和 该块在R中的起始位置

```c++
typedef struct {
    KeyType key;     // 关键字类型
    int pointIndex;     // 指向对应块的起始下标
} IdxType;     // 索引表元素的类型
```

分块查找：先查找索引表，因为索引表是有序表，故可采用折半查找或顺序查找，以确定待查找元素在哪一块，然后在已确定的块中顺序查找；采用折半查找索引表的分块查找算法如下（索引表 I 的长度为 b），ASL = log2(b+1) + s/2

```c++
int IdxSearch(IdxType I[], int b, RecType R[], int n, KeyType k) {
    int s = (n - 1 + b) / b;     // s 为每块中的元素的个数，应为 ⌈n/b⌉
    int LI = 0, HI = b - 1, mid, index;
    while (LI <= HI) {
    	mid = (LI + HI) / 2;
    	if (k <= I[mid].key) {
    		HI = mid - 1;
    	} else {
    		LI = mid + 1;
    	}
    }
    // 首先在索引表的 HI + 1 块中查找，再在主数据表中进行顺序查找
    index = I[HI + 1].pointIndex;
    while (index <= I[HI + 1].pointIndex + s - 1 && R[index].key != k) ++index;
    return index <= I[HI + 1].pointIndex + s - 1 ? index + 1 : 0; // 查找成功返回逻辑序号
}
```

采用折半查找来确定元素所在的块：（当 s 越小时，ASL越小），ASL(blk) = ASL(bn) + ASL(sq) = log2(b+1) - 1 + (s+1) / 2 = log2(b+1) + s/2

采用顺序查找来确定元素所找的块：（当 s = n^(1/2)时，ASL最小为 n^(1/2) + 1)，ASL(blk)' = ASL(bn) + ASL(sq) = (b+1) / 2 + (s+1) / 2 = (b+s)/2 + 1

## （三）树表（tree table）的查找

由于折半查找要求表中元素有序，且不适合链式存储的结构，因此当表的插入或删除频繁时，为维护表的有序性，需要移动大量元素，其额外的时间开销会抵消其优点；若要对动态查找表进行高效率的查找，可采用特殊的二叉树/树作为表的组织形式，统称为树表（tree table）

### 1. 二叉排序树（binary search tree）

二叉排序树（binary search tree，BST）又称二叉查找树或二叉搜索树，其定义为二叉搜索树或空树，或是满足以下性质（BST性质）的二叉树：

1. 若根结点的左子树非空，则左子树上的所有结点的关键字均小于根结点关键字
2. 若根结点的右子树非空，则右子树上的所有结点的关键字均大于根结点关键字
3. 根结点的左右子树本身又各自是一个二叉搜索树

按中序遍历该树得到的中序序列是一个递增有序序列；注：其中关键字是唯一的，但在实际应用中，不能保证关键字的唯一性，故可将(1)修改为小于等于或将(2)修改为大于等于

```c++
typedef int KeyType;
typedef int InfoType;

// 二叉搜索树的结点类型声明如下：
typedef struct node {
    KeyType key;
    InfoType data;
    struct node *lchild, *rchild;
} BSTNode;
```

二叉搜索树的插入，任何结点插入到二叉搜索树中都是作为叶子结点插入的，在数bt中，插入一个关键字为k的元素，若bt为空，则创建作为根结点；否则判断 bt->key 与 k，递归调用

```c++
bool InsertBST(BSTNode*& bt, KeyType k) {
    if (bt == NULL) {
        bt = (BSTNode*)malloc(sizeof(BSTNode));
        bt->key = k;      // 创建新结点（作为叶子结点）
        bt->lchild = bt->rchild = NULL;
        return true;
    } else if (k < bt->key) {
    	return InsertBST(bt->lchild, k);     // 插入到左子树中
    } else if (k > bt->key) {
    	return InsertBST(bt->rchild, k);     // 插入到右子树中
    } else {
    	return false;     // k == bt->key 树中存在相同关键字的结点，返回false
    }
}
```

创建二叉搜索树，关键字序列顺序不同，生成的二叉搜索树的树形可能不同；二叉树高度越小，查找效率越高（ 接近O(log2(n)) ）；从关键字数组 a[0...n-1] 生成二叉搜索树，依次调用插入算法即可

```c++
BSTNode* CreateBST(KeyType a[], int n) {
    BSTNode* bt = NULL;
    for (int i = 0; i < n; InsertBST(bt, a[i++]));
    return bt;     // 返回创建的指向树根的二叉搜索树的指针，若数组有零个元素返回NULL
}
```

输出二叉搜索树（的关键字）

```c++
void DispBSTree(BSTNode* bt) {
    if (bt != NULL) {
        // 当前结点非空，输出其表示的值
        printf("%d", bt->key);
        // 至少有一个孩子结点时
        if (bt->lchild != NULL || bt->rchild != NULL) {
        	printf("(");
        	DispBSTree(bt->lchild);     // 递归处理左子树
        	if (bt->rchild != NULL) {
        		// 如果有右孩子结点，先输出 ,
        		printf(",");
        	}
        	DispBSTree(bt->rchild);     递归处理右孩子结点
        	printf(")");
        }
    }
}
```

销毁二叉搜索树

```c++
void DestoryBSTree(BSTNode* bt) {
    if (bt != NULL) {
        DestoryBSTree(bt->lchild);
        DestoryBSTree(bt->rchild);
        free(bt);
    }
}
```

二叉搜索树的查找，和折半查找类似，也是一个逐步缩小查找范围的过程，递归算法如下：

```c++
BSTNode* SearchBST(BSTNode* bt, KeyType k) {
    if (bt == NULL || bt->key == k) {
    	return bt;
    }
    return k < bt->key ? SearchBST(bt->lchild, k) : SearchBST(bt->rchild, k);
}
```

二叉搜索树的查找，非递归

```c++
BSTNode* SearchBST_nonRecursion(BSTNode* bt, KeyType k) {
    while (bt != NULL) {
    	if (k < bt->key) {
    		bt = bt->lchild;
    	} else if (k > bt->key) {
    		bt = bt->rchild;
    	} else {
    		return bt;     // bt->key == k
    	}
    }
    return bt;     // 未找到返回 NULL
}
```

若不仅要找到关键字为 k 的结点，还要找到其双亲结点；返回所查找的结点，用parent引用实参返回其双亲结点，调用如 (bt, k, par, NULL)

```c++
BSTNode* SearchBST_withParent(BSTNode* bt, KeyType k, BSTNode*& parent, BSTNode* p = NULL) {
    if (bt == NULL) {
    	parent = NULL;     // 未找到返回 NULL
    	return NULL;
    } else if (k < bt->key) {
    	return SearchBST_withParent(bt->lchild, k, parent, bt);
    } else if (k > bt->key) {
    	return SearchBST_withParent(bt->rchild, k, parent, bt);
    } else {
    	k == bt->key
    	parent = p;
    	return bt;
    }
}
```

例 9.4 设计一个算法，求出二叉搜索树的左子树中最大结点和右子树中最小结点；根据定义，一颗二叉搜索树，最大结点为最右下结点，最小结点为最左下结点

```c++
void maxMinNode(BSTNode* bt) {
    if (bt != NULL) {
    	BSTNode* p = bt->lchild;
    	if (bt->lchild != NULL) {
    		while (p->rchild != NULL) p = p->rchild;
    		printf("左子树的最大结点关键字为：%d\n", p->key);
    	}
    	p = bt->rchild;
    	if (bt->rchild != NULL) {
    		while (p->lchild != NULL) p = p->lchild;
    		printf("右子树的最小结点关键字为：%d\n", p->key);
    	}
    }
}
```

基础算法，请勿显式调用

```c++
// 删除二叉搜索树中的结点 t （ t != NULL ）
static void DeleteBSTNode(BSTNode*& t) {
    BSTNode* q;
    // t 只有左子树而无右子树
    if (t->rchild == NULL) {
    	q = t;
    	t = t->lchild;     // 用 t 的左孩子代替 t
    	free(q);
    } else if (t->lchild == NULL) {
        // t 只有右子树而无左子树
        q = t;
        t = t->rchild;     // 用 t 的右孩子代替 t
        free(q);
    } else {
        // t 既有左子树又有右子树，此处选择用 t 的左子树的最大结点代替 t，并删除该最大结点
        BSTNode** lmax = &(t->lchild);     // 此处二级指针不能用 *&
        // 找到左子树的最大结点
        while ((*lmax)->rchild != NULL) lmax = &((*lmax)->rchild);     
        t->key = (*lmax)->key;
        t->data = lmax->key;
        q = *lmax;     // 删除左子树最大结点，情况(2)
        *lmax = (*lmax)->lchild;
        free(q);
    }
}
```

二叉树搜索树的删除；不能直接把该结点为根的子树都删除，只能删除该结点本身，且还要保证删除后所得的二叉树仍满足BST性质；即，在二叉搜索树中删除一个结点相当于删除有序序列（即该树的中序序列）中的一个元素；删除操作必须先进行查找，假设在查找结束时，p 指向要删除的结点，分为以下几种情况:

1. p 是叶子结点，直接删除
2. p 仅有左子树而无右子树，直接用 p 的左孩子替换 p（p = p->lchild）
3. p 仅有右子树而无左子树，直接用 p 的右孩子替换 p（p = p->rchild）
4. p 既有左孩子又有右孩子，用左子树中最大的结点 lmax 替换 p，并删除 lmax（ lmax的删除操作符合(2) ），即用中序前驱代替被删除结点；或可以用右子树中最小节点 rmin 替换 p，并删除 rmin（ rmin的删除操作符合(3) ），即用中序后继代替被删除结点

删除二叉搜索树bt中关键字为k的结点

```c++
bool DeleteBST(BSTNode*& bt, KeyType k) {
    if (bt == NULL) {
    	return false;     // 空树删除失败，返回false
    }
    if (k < bt->key) {
    	return DeleteBST(bt->lchild, k);     // 递归在左子树中删除关键字为 k 的结点
    } else if (k > bt->key) {
    	return DeleteBST(bt->rchild, k);     // 递归在右子树中删除关键字为 k 的结点
    } else {
        // k == bt->key，找到要删除的结点，删除之
        _9_3_1_Base::DeleteBSTNode(bt);
        return true;
    }
}
```

### 2. 平衡二叉树（balance binary tree）

含有 n 个结点的二叉搜索树查找操作最坏情况为 O(n)，其与树形有关；通过在往树中插入或删除的同时调整树的形态来保持树的平衡，使之既保持BST性质又保证树的高度在任何情况下均为 log2(n)，从而使查找操作的时间复杂度也为 O(log2(n))

若一颗二叉树中的每个结点的左右子树的高度最多相差1，则称此二叉树为平衡二叉树（balance binary tree）。

平衡的二叉搜索树有很多种，较为著名的有AVL树，AVL平衡二叉树（Adel'son-Vel'sii和Landis），通过平衡因子（balance factor，bf）来具体实现上述平衡二叉树的定义，其定义为：

- 平衡因子 = 左子树的高度 - 右子树的高度（或 右-左）；
- 从平衡因子的角度讲，若 bf 取值为 -1，1，0 则该结点是平衡的，否则是不平衡的；
- 一颗平衡二叉树的所有结点都应该是平衡的；这就要求在插入或删除中，一旦某些结点在操作后不平衡，就要进行调整；
- 加一个头结点 head 标识树，默认 head->lchild 为平衡二叉树的根结点（-1 表示左孩子，0 表示没孩子，1 表示右孩子）

```c++
typedef int KeyType;
typedef int InfoType;

typedef struct avl {
    int height;     // 平衡因子，balance factor，bf = lHeight - rHeight
    KeyType key;
    InfoType data;
    struct avl *lchild, *rchild;
} AVLTreeNode;    // AVL平衡二叉树结点类型
```

基础算法，请勿显式调用

```c++
// 更新结点高度
static void reNodeHeight(AVLTreeNode* node) {
    int lHeight = node->lchild == NULL ? 0 : node->lchild->height;
    int rHeight = node->rchild == NULL ? 0 : node->rchild->height;
    node->height = 1 + (lHeight > rHeight ? lHeight : rHeight);
}

// 计算结点平衡因子
static int getBalanceFactor(AVLTreeNode* node) {
    int lHeight = node->lchild == NULL ? 0 : node->lchild->height;
    int rHeight = node->rchild == NULL ? 0 : node->rchild->height;
    return lHeight - rHeight;
}

static void adjust_LL(AVLTreeNode* A, AVLTreeNode* parent, int whichChild) {
    AVLTreeNode* B = A->lchild;
    A->lchild = B->rchild; reNodeHeight(A);
    B->rchild = A; reNodeHeight(B);
    if (whichChild == -1) {
    	parent->lchild = B;
    } else if (whichChild == 1) {
    	parent->rchild = B;
    }
}

static void adjust_RR(AVLTreeNode* A, AVLTreeNode* parent, int whichChild) {
    AVLTreeNode* B = A->rchild;
    A->rchild = B->lchild; reNodeHeight(A);
    B->lchild = A; reNodeHeight(B);
    if (whichChild == -1) {
    	parent->lchild = B;
    } else if (whichChild == 1) {
    	parent->rchild = B;
    }
}

static void adjust_LR(AVLTreeNode* A, AVLTreeNode* parent, int whichChild) {
    AVLTreeNode* B = A->lchild;
    AVLTreeNode* C = B->rchild;
    B->rchild = C->lchild; reNodeHeight(B);
    A->lchild = C->rchild; reNodeHeight(A);
    C->lchild = B; C->rchild = A; reNodeHeight(C);
    if (whichChild == -1) {
    	parent->lchild = C;
    } else if (whichChild == 1) {
    	parent->rchild = C;
    }
}

static void adjust_RL(AVLTreeNode* A, AVLTreeNode* parent, int whichChild) {
    AVLTreeNode* B = A->rchild;
    AVLTreeNode* C = B->lchild;
    A->rchild = C->lchild; reNodeHeight(A);
    B->lchild = C->rchild; reNodeHeight(B);
    C->lchild = A; C->rchild = B; reNodeHeight(C);
    if (whichChild == -1) {
    	parent->lchild = C;
    } else if (whichChild == 1) {
    	parent->rchild = C;
    }
}

// 重新平衡，at 为其根结点，若为最小失衡树则调整平衡
static void adjustToBalance(AVLTreeNode* at, AVLTreeNode* parent, int whichChild) {
    switch (getBalanceFactor(at)) {
    case 1: case 0: case -1: break;
    case 2:
    	if (getBalanceFactor(at->lchild) == -1) {
    		adjust_LR(at, parent, whichChild);
    	} else {
   			adjust_LL(at, parent, whichChild);     // == 0 || == 1
    	}
    	reNodeHeight(parent);
    	break;
    case -2:
    	if (getBalanceFactor(at->rchild) == 1) {
    		adjust_RL(at, parent, whichChild);
    	} else {
    		adjust_RR(at, parent, whichChild);     // == 0 || == -1
    	}
    	reNodeHeight(parent);
    	break;
    }
}

// insert_base
static bool InsertBBT_AVL_base(AVLTreeNode*& at, KeyType k, AVLTreeNode* parent, int whichChild) {
    bool inserted = false;
    if (at == NULL) {
        at = (AVLTreeNode*)malloc(sizeof(AVLTreeNode));
        at->height = 1;     // 创建结点（根结点），插入关键字
        at->lchild = at->rchild = NULL;
        at->key = k;
        inserted = true;
    } else if (k < at->key) {
    	inserted = InsertBBT_AVL_base(at->lchild, k, at, -1);
    } else if (k > at->key) {
    	inserted = InsertBBT_AVL_base(at->rchild, k, at, 1);
    } // else k == at->key 已存在 inserted = false;
    // 递归调用 和 递归退出 时会逐层遍历检查树的结点是否平衡并调整
    reNodeHeight(parent);
    adjustToBalance(at, parent, whichChild);
    return inserted;
}

// dis base
static void DispBBTree_AVL_base(AVLTreeNode* at) {
    if (at != NULL) {
        // 当前结点非空，输出其表示的值
        printf("%d", at->key);
        // 至少有一个孩子结点时
        if (at->lchild != NULL || at->rchild != NULL) {
            printf("(");
            DispBBTree_AVL_base(at->lchild);     // 递归处理左子树
        	if (at->rchild != NULL) {
            	// 如果有右孩子结点，先输出 ,
            	printf(",");
        	}
        	DispBBTree_AVL_base(at->rchild);     // 递归处理右孩子结点
        	printf(")");
        }
    }
}

// search
static AVLTreeNode* SearchBBT_AVL_base(AVLTreeNode* at, KeyType k) {
    if (at == NULL || at->key == k) {
    	return at;
    }
    return k < at->key ? SearchBBT_AVL_base(at->lchild, k) : SearchBBT_AVL_base(at->rchild, k);
}

// delete the max node of left child
static void DeleteBBTreeNode_AVL_base_Helper(AVLTreeNode* toDeleteNode, AVLTreeNode* t, AVLTreeNode *parent, int whichChild) {
    if (t->rchild != NULL) {
    	DeleteBBTreeNode_AVL_base_Helper(toDeleteNode, t->rchild, t, 1);
    } else {
    	toDeleteNode->key = t->key;
    	if (whichChild == 1) {
    		parent->rchild = t->lchild;
    	} else if (whichChild == -1) {
    		parent->lchild = t->lchild;
    	}
    	free(t);
    }
    reNodeHeight(parent);
}

// delete node base
static void DeleteBBTreeNode_AVL_base(AVLTreeNode* t, AVLTreeNode* parent, int whichChild) {
    if (t->rchild == NULL) {
    	// t 只有左子树而无右子树
    	// 用 t 的左孩子代替 t
    	if (whichChild == -1) {
    		parent->lchild = t->lchild;
    	} else if (whichChild == 1) {
    		parent->rchild = t->lchild;
    	}
    	free(t);
    } else if (t->lchild == NULL) {
    	// t 只有右子树而无左子树
    	// 用 t 的右孩子代替 t
    	if (whichChild == -1) {
    		parent->lchild = t->rchild;
    	} else if (whichChild == 1) {
    		parent->rchild = t->rchild;
    	}
    	free(t);
    } else {
    	// t 既有左子树又有右子树，此处选择用 t 的左子树的最大结点代替 t，并删除该最大结点
    	DeleteBBTreeNode_AVL_base_Helper(t, t->lchild, t, -1);
    }
    reNodeHeight(parent);
}

// delete_base
static bool DeleteBBT_AVL_base(AVLTreeNode* at, KeyType k, AVLTreeNode* parent, int whichChild) {
    bool shouldAdjust = true;
    if (at == NULL) {
    	shouldAdjust = false;     // 空树删除失败
    } else {
        if (k < at->key) {
            // 递归在左子树中删除关键字为 k 的结点
            shouldAdjust = DeleteBBT_AVL_base(at->lchild, k, at, -1);     
        } else if (k > at->key) {
            // 递归在右子树中删除关键字为 k 的结点
            shouldAdjust = DeleteBBT_AVL_base(at->rchild, k, at, 1);     
        } else {
            // k == bt->key，找到要删除的结点，删除之
            DeleteBBTreeNode_AVL_base(at, parent, whichChild);
            shouldAdjust = false;
        }
    }
    if (shouldAdjust) {
    	reNodeHeight(parent);
    	adjustToBalance(at, parent, whichChild);
    }
    return true;
}
```

#### (1) 平衡二叉树插入节点

平衡二叉树中插入结点的过程；若向平衡二叉树中插入一个新结点（总是作为叶子结点插入）后破坏了平衡性，应从该新结点向根结点的方向查找第一个失去平衡的 结点A，刚刚查找过的与A相邻的 结点B，以 A 和 B 结点为根结的两棵子树，构成调整子树；失衡的最小子树是指以离新结点最近的，且平衡因子绝对值大于1的结点为根结点的子树，即 A子树

调整分为以下4种情况：LL型，RR型，LR型，RL型

- LL型调整：
  - 因 A结点 的 左孩子B结点 的左子树上插入新结点，使得 A->bf 不平衡：1 => 2
  - 令 C 为 B->rchild，将 B 上升代替 A 称为根结点，A 作为 B 的右孩子，C 作为 A 的左孩子
- RR型调整：
  - 因 A结点 的 右孩子B结点 的右子树上插入新结点，使得 A->bf 不平衡：-1 => -2
  - 令 C 为 B->lchild，将 B 上升代替 A 作为根结点，A 作为 B 的左孩子，C 作为 A 的右孩子
- LR型调整：
  - 因 A结点 的 左孩子B结点 的右子树上插入新结点，使得 A->bf 不平衡：1 => 2
  - 令 C 为 B->rchild，将 C 上升代替 A 作为根结点，C->lchild 作为 B 的右孩子，C->rchild 作为 A 的左孩子，B 作为 C 的左孩子，A 作为 C 的右孩子
- RL型调整：
  - 因 A结点 的 右孩子B结点 的左子树上插入新结点，使得 A->bf 不平衡：-1 => -2
  - 令 C 为 B->lchild，将 C 上升代替 A 作为根结点，C->lchild 作为 A 的右孩子，C->rchild 作为 B 的左孩子，A 作为 C 的左孩子，B 作为 C 的右孩子

平衡二叉树的插入；任何结点插入到平衡二叉树中都是作为叶子结点插入的，在数bt中，插入一个关键字为k的元素，若bt为空，则创建作为根结点，并调整树形；否则判断 bt->key 与 k，递归调用

```c++
void InsertBBT_AVL(AVLTreeNode* head, KeyType k) {
    // 默认头结点的左孩子连接二叉树的根结点，右孩子为空
	_9_3_2_Base::InsertBBT_AVL_base(head->lchild, k, head, -1);     
}
```

创建平衡二叉树

```c++
AVLTreeNode* CreateBBT_AVL(KeyType K[], int n) {
    AVLTreeNode* head = (AVLTreeNode*)malloc(sizeof(AVLTreeNode));
    head->height = 0;
    head->lchild = head->rchild = NULL;
    for (int i = 0; i < n; ++i) {
    	_9_3_2_Base::InsertBBT_AVL_base(head->lchild, K[i], head, -1);
    }
    return head;
}
```

输出平衡二叉树（的关键字）

```c++
void DispBBTree_AVL(AVLTreeNode* head) {
	_9_3_2_Base::DispBBTree_AVL_base(head->lchild);
}
```

销毁平衡二叉树

```c++
void DestoryBBTree_AVL(AVLTreeNode* head) {
    if (head != NULL) {
        DestoryBBTree_AVL(head->lchild);
        DestoryBBTree_AVL(head->rchild);
        free(head);
    }
}
```

#### (2) 平衡二叉树删除节点

平衡二叉树中删除结点的过程；在平衡二叉树中删除一个结点与二叉搜索树中删除结点类似，只是增加了调整这一步，其过程如下：

1. 查找，先在平衡二叉树中查找关键字为 k 的元素
2. 删除 结点p，分为三种情况：
   1. 叶子结点，直接删除
   2. 单分支结点，用 p 的左孩子或右孩子代替结点 p
   3. 双分支结点，用 p 的中序前驱（后中序后继）的结点 q 代替结点 p，再删除结点 q
3. 调整，若被删除的是结点 p，则从结点 p 向根结点的方向查找第一个失衡结点：
   1. 若所有结点都是平衡的，则无需调整
   2. 若某个结点平衡因子为 -2（R）：右孩子平衡因子为 1（RL），否则可为 RR
   3. 若某个结点平衡因子为 2（L）：左孩子平衡因子为 -1（LR），否则可为 LL

```c++
bool DeleteBBT_AVL(AVLTreeNode* head, KeyType k) {
	return _9_3_2_Base::DeleteBBT_AVL_base(head->lchild, k, head, -1);
}
```

平衡二叉树的查找；其过程和二叉搜索树的查找过程完全相同，而且由于其树形被约束，故平衡二叉树的最大高度 h 约等于 log2(n)；则其平均查找长度为 AVL = log2(n)，算法时间复杂度为 O(log2(n))；和折半查找类似，也是一个逐步缩小查找范围的过程，递归算法如下：

```c++
AVLTreeNode* SearchBBT_AVL(AVLTreeNode* head, KeyType k) {
	return _9_3_2_Base::SearchBBT_AVL_base(head->lchild, k);
}
```

平衡二叉树的查找，非递归

```c++
AVLTreeNode* SearchBBT_AVL_nonRecursion(AVLTreeNode* head, KeyType k) {
    AVLTreeNode* at = head->lchild;
    while (at != NULL) {
        if (k < at->key) {
        	at = at->lchild;
    	} else if (k > at->key) {
    		at = at->rchild;
    	} else {
    		return at;     // bt->key == k
    	}
    }
    return at;     // 未找到返回 NULL
}
```

### 3. B-树（B tree）

仅参考，无法实际使用

二叉排序树和平衡二叉树都是作用于内查找的数据结构，即被查找的数据集不大，可以存放在内存中；此处和之后介绍的 B-树（又称为 B树） 和 B+树 是用作外查找的数据结构，其数据存放在外存中

B-树中所有结点的孩子结点个数的最大值称为B-树的阶，通常用 m 表示，从查找效率考虑，要求 m >= 3；一棵树是B-树或是一棵空树，或者是满足下列要求的 m 叉树：

1. 树中的每个结点最多有 m 棵子树（即最多含有 m-1 个关键字，设 MaxKeyNum = m - 1）
2. 若根结点不是叶子结点，则根结点最少有两棵子树
3. 除根结点外，所有非叶子结点最少有 ⌈m/2⌉ 棵子树（即最少含有 ⌈m/2⌉ - 1 个关键字，设 MinKeyNum = ⌈m/2⌉ - 1
4. 每个结点（含有n个关键字，n+1个子树）的结构为：| n | c0 | k1 | c1 | k2 | c2 | ... | kn | cn |
   - 其中，除根结点外，所有其它结点的关键字个数 n 满足：⌈m/2⌉ - 1 <= n <= m - 1，即 MinKeyNum <= n <= MaxKeyNum
   - ki（1 <= i <= n）为该结点的关键字且满足：ki < k(i+1)；
   - ci（0 <= i <= n）为该结点的孩子结点指针，满足：c0结点任意关键字 < k1 < c1所指孩子结点任意关键字 < ... < ki < AllValue(ci) < k(i+1) < ... < AllValue(cn)
5. 所有的外部结点在同一层，并且不带信息（可以看作是查找失败的结点），通常在计算一个B-树的高度时也将外部结点计入一层；显然，如果一颗B-树中共有n个关键字，则外部结点的个数为 n + 1

```c++
const int MAXM = 10;     // 定义B-树的最大阶数
// 在B-树的存储结构中，结点的声明类型如下：
typedef int KeyType;
typedef struct node {
    int keyNum;     // 结点当前拥有的关键字的个数 n
    KeyType keys[MAXM];    // keys[1...keyNum] 存放关键字，keys[0] 不用
    struct node* parent;    // 双亲结点指针
    struct node* childs[MAXM];    // 指向孩子结点指针的数组 childs[0...keyNum]
} BTNode;     // B-树（B树）的结点类型
```

此处教材采用了全局变量（就此只能同时存在一棵B-树），为防止污染全局空间，将其实现为 struct 作用域内变量，请勿显式修改

```c++
struct _9_3_3_Base {
    static int m;     // B-树的阶
    static int MaxKeyNum;     // m 阶 B-树 中每个结点最多的关键字个数，MaxKeyNum = m - 1
    static int MinKeyNum;     // m 阶 B-树 中每个结点最少的关键字个数，MinKeyNum = ⌈m/2⌉ - 1
    static void set(int parM) {
        m = parM;
        MaxKeyNum = m - 1;
        MinKeyNum = ((m - 1) / 2 + 1) - 1;    // ⌈m/2⌉ - 1
    }
};
int _9_3_3_Base::m = MAXM;
int _9_3_3_Base::MaxKeyNum = _9_3_3_Base::m - 1;
int _9_3_3_Base::MinKeyNum = ((_9_3_3_Base::m - 1) / 2 + 1) - 1;
```

#### (1) B-树的查找

在B-树中查找给定关键字的方法类似于二叉搜索树上的查找，不同的是在每个结点上的向下查找路径不一定是二路的，而是 n + 1 路的；因为结点内的关键字序列 keys[1...n] 是有序的，故既可以采用顺序查找也可以采用折半查找

在一棵B-树上查找关键字为 k 的方法为：将 k 与 根结点中的 keys[i]（1 <= i <= n）比较：

1. 若 k < keys[1]，则沿着指针 childs[0] 所指的子树继续查找
2. 若 k == keys[i]，则查找成功
3. 若 keys[i] < k < keys[i+1]，则沿着指针 childs[i] 所指的子树继续查找
4. 若 keys[n] < k，则沿着指针 childs[n] 所指的子树继续查找
5. 复上述过程，直到找到含有关键字 k 的某个结点 或 一直比较到了某个外部结点表示查找失败

在B-树中进行查找时，其查找时间主要花费在搜索结点上，即主要取决于B-树的高度，第 i 层的最少结点的个数 minNodeNum 为 ：minNodeNum(0) = 1，minNodeNum(1) = 2，minNodeNum(3) = 2 * ⌈m/2⌉^1，...，minNodeNum(h+1) = 2 * ⌈m/2⌉^(h-1)

假设 m 阶 B-树的高度为 h + 1（第h+1层为外部结点），而当前树中含有 n 个关键字，外部结点为 n + 1 个，由此推得：n + 1 >= minNodeNum(h+1) = 2 * ⌈m/2⌉^(h-1)，所以 h <= log(⌈m/2⌉)((n+1) / 2) + 1

因此在含 n 个关键字的B-树上进行查找需访问的结点个数不超过 h 个，即B-树的查找算法的时间复杂度为O(log(m)(n))

#### (2) B-树的插入

利用前述的B-树查找算法找出关键字 k 的插入结点ci（B-树的插入结点一定是某个叶子结点）；在插入结点中插入关键字 k，判断插入结点是否还有空位置，即判断该结点的关键字个数是否小于等于 MaxKeyNum，分两种情况

- 若该结点还有空位置（keyNum < MaxKeyNum），直接把关键字插入到该结点的合适位置上（即使插入后的关键字序列仍保持有序）
- 若该结点无空位置（keyNum == MaxKeyNum），需要将该结点分裂，将原结点上的 keyNum 个关键字和 新关键字 k 合成一个新序列，并使之有序

将新序列从中间（在⌈m/2⌉处，且两部分都不包含⌈m/2⌉处的关键字）分为左右两部分，左为 1 ... ⌈m/2⌉-1 放入到旧结点中，右为 ⌈m/2⌉+1 ... m 放入到新生成的新结点中，将中间位置的关键字和新结点插入到双亲结点中
（放在该插入结点的右边，即|ki|ci|k(i+1)|c(i+1)|的i+1处，k(i+1) = 中间结点的关键字，c(i+1)指向新结点，注意序列后移一位）

如果双亲结点的关键字个数也超过MaxKeyNum，则需要再分裂双亲结点，再往上插，直到这个过程传递到根结点为止，如果根结点需要分裂，则树的高度增加一层；一棵B-树的创建过程就是从一棵空树开始，逐个插入关键字而得到的

#### (3) B-树的删除

利用前述的B-树查找算法找出该关键字 k 所在的结点，称为删除结点 ci；删除结点分为两种情况，一种是属于叶子层的结点，另一种是属于非叶子结点层的结点

当删除结点是非叶子结点层的结点时，假设要删除某个非叶子结点的关键字 k = keys[i]，其删除过程是：

- 用该结点的 childs[i-1] 所指子树中的最大关键字 Max(key) 来代替被删除关键字 keys[i]（注意childs[i-1]所指子树中的最大关键字 Max(key) 一定在叶子结点上）；然后再删除 Max(key)，这样就把在非叶子结点上删除关键字 k 的问题转换成了 在叶子结点上删除关键字 Max(key) 的问题
- 也可以用删除结点的 childs[i] 所指子树的最小关键字 Min(key) 来代替 keys[i]，然后再删除 Min(key)

在某个叶子结点中删除关键字 k，共有以下三种情况：

1. 若删除结点的关键字个数 KeyNum > MinKeyNum，说明删去该关键字后该结点仍满足B-树的定义，则可以直接删除该关键字
2. 若删除结点的关键字个数 KeyNum == MinKeyNum，先删除这个关键字，该结点不再满足B-树的定义；此时若该结点的左（或右）兄弟结点（如果存在）中的关键字个数 KeyNum_L_or_R > MinKeyNum，则把该结点的左（或右）兄弟结点中最大（或最小）的关键字上移到双亲结点中；同时把双亲结点中的大于（或小于）刚刚上移的关键字的那个关键字下移到删除结点中做关键字，即双亲结点中的原ki（或k(i+1)）下降，并用ci的兄弟结点中的相应关键字替换之
3. 若删除结点的关键字个数 KeyNum == MinKeyNum，先删除这个关键字，该结点不再满足B-树的定义；且该删除结点的兄弟结点（如果存在）中的关键字的个数均为MinKeyNum，这时需要将结点合并；把删除结点与其左（或右）兄弟结点以及双亲结点中分割二者的关键字合并成一个结点；如果因此使双亲结点中的关键字个数 KeyNum < MinKeyNum，则对双亲结点做同样的处理，以至于可能直到对根结点做这样的处理而使整个树减少一层

### 4. B+树（B+ tree）

在索引文件组织中经常使用B-树的一些变形，其中B+树是一种应用广泛的变形；一棵 m 阶的 B+树 满足下列条件：

- 每个分支最多有 m 棵子树
- 根结点或者没有子树，或者最少有两颗子树
- 除根结点以外，其他每个分支结点最少有 ⌈m/2⌉ 棵子树
- 有 n 棵子树的结点有 n 个关键字
- 所有的叶子结点包含全部的关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接（可以把每个叶子结点看成是一个基本索引块，它的指针不再指向另一级索引块，而是直接指向数据文件中的记录）
- 所有的分支结点（可以看成是索引的索引）中仅包含它的各个子结点（即下级索引的索引块）中的最大关键字及指向子结点的指针

通常在B+树上有两个头指针，一个指向根结点（如root），另一个指向关键字最小的叶子结点（如sqt）

注意：m 阶的 B+树 和 m 阶的 B-树 的主要差异如下：

- 在B+树中，具有 n 个关键字的结点含有 n 棵子树，即每个关键字对应一颗子树；而在B-树中，具有 n 个关键字的结点含有 (n+1) 棵子树
- 在B+树中，除根结点外，每个结点中的关键字的个数 n 的取值为 ⌈m/2⌉ <= n <= m，根结点 n 的取值为 2 <= n <= m；而在B-树中，除根结点外，所有非叶子结点的关键字个数 n 的取值为 ⌈m/2⌉ - 1 <= n <= m - 1，根结点 n 的取值为 1 <= n <= m-1
- 在B+树中，所有的叶子结点包含了全部的关键字，即其他非叶子结点中的关键字索引到叶子结点中的关键字
  而在B-树中，所有的关键字都是不重复的
- 在B+树中，所有的非叶子结点仅起到索引作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应的记录的存储地址；而在B-树中，每个关键字都对应一个记录的存储地址
- 在B+树中，通常有两个头指针，一个指向根结点，另一个指向关键字中最小的叶子结点，所有的叶子结点链接成一个不定长的线性链表，故B+树可以进行随机和顺序查找；而在B-树中，只能进行随即查找

#### (1)B+树的查找

在B+树中可以采用两种方式查找，一种是直接从最小关键字开始进行顺序查找（通过sqt指针查找）；另一种是从B+树的根结点进行随机查找（通过root指针查找），这种方式与B-树的查找方法相似，只是在分支结点上的关键字和查找值相等时查找并不结束，要继续查找到叶子节点为止，此时若查找成功，则按所给指针取出对应元素即可

因此，在B+树中不管查找成功与否，每次查找都是经过了一条从根结点到叶子结点的路径

#### (2) B+树的插入

与B-树的插入操作相似，B+树的插入也是在叶子结点中进行的；当插入后结点中的关键字个数大于 m 时要分裂成两个结点，它们所含的关键字的个数分别为 ⌈(m+1)/2⌉ 和 ⌊(m+1)/2⌋；同时要使得它们的双亲结点中包含有这两个结点的最大关键字索引和指向它们的指针；若双亲结点的关键字个数大于 m，应继续分裂，以此类推

#### (3) B+树的删除

B+树的删除也是在叶子结点中进行的，当叶子结点中的最大关键字被删除时，分支结点中的值可以作为“分界关键字”存在（注意同步双亲结点中的关键字）；若因删除操作使结点中的关键字个数少于 ⌈m/2⌉，则从兄弟节点中调剂关键字或和兄弟结点合并，其过程和B-树相似

## （四）哈希表（hash table）的查找

### 1. 哈希表的概念

哈希表（hash table）又称散列表，设要存储的元素个数为 n，设置一个长度为 m（m >= n）的连续内存空间，以每个关键字 ki（0 <= i <= n-1）为自变量，通过一个称为哈希函数（hash function）的函数 h(ki) 把 ki 映射为内存单元的地址（或下标)，并把该元素存储在这个内存单元中；h(ki) 也成为哈希地址（hash address），如此构造的线性存储结构称为哈希表

在构建过程中，若出现两个不相同的元素 ki != kj（i != j），但 ki == kj 的情况，称为哈希冲突（hash collisions），这两个元素通常称为同义词（synonym），通常的实际情况是关键字的取值区间远大于哈希地址的变化区间

哈希查找的性能主要与3个因素有关：

1. 装填因子（load factor）α ，即哈希表中已存入的元素数 n 与哈希地址空间大小 m 的比值，即 a = n / m
   α 越小，冲突的可能性越小，存储空间的利用率也越低，通常使最终的 α 控制在 0.6 ~ 0.9 之间
2. 所采用的哈希函数
3. 解决哈希冲突的方法

### 2. 哈希函数的构造方法

哈希地址应尽可能均匀地分布在 m 个连续的内存单元上，同时使计算过程尽可能简单以达到尽可能高的时间效率
此处讨论几处常用的整数类型关键字的哈希函数构造方法

1. 直接定址法：h(k) = k + C
2. 除留余数法：h(k) = k mod p（mod 为求余运算，p <= m），理论研究表明，p 取不大于 m 的素数时效果最好
3. 数字分析法：提取关键字中取值较平均的数字作为哈希地址；etc、平方取中法、折叠法

### 3. 哈希冲突的解决方法

开放定址法（open addressing）：在出现哈希冲突时在哈希表中找一个新的空闲位置存放元素

1. 线性探测法（linear probing）：从发生冲突的地址（设为d0）开始，依次探测 d0 的下一个地址（到表尾时转到表首），直到找到一个空闲单元为止（m >= n 时一定能找到）；数学递推描述公式：d0 = h(k)，di = ( d(i-1) + 1 ) mod m（1 <= i <= m-1），容易产生堆积问题
2. 平方探测法（square probing）：探测序列为 d0 + 1^2， d0 - 1^2，d0 + 2^2，d0 - 2^2，...；数学递推描述公式：d0 = h(k)，di = (d0 +- i^2) mod m（1 <= i <= m-1），避免出现堆积问题，不一定能探测到哈希表上的所有单元（但最少一半）
3. etc、伪随机序列法、双哈希函数法

拉链法（chaining）：把所有的同义词用单链表链接起来，地址为 i 的单元是一个指向对应单链表首结点的指针；在这种方法中，哈希表中的每个单元存放的不再是元素本身，而是相应同义词单链表的指向首结点的指针

### 4. 哈希表的运算算法

哈希表的常见运算有插入及建表、删除和查找等（为了简便，算法中假设每个元素仅含有关键字）

#### (1) 用开放地址法构造的哈希表运算算法

哈希函数：除留余数法，解决冲突的方法：线性探测法；仅参考，无法实际使用

此处教材采用了全局变量（就此只能同时存在一个 hash 表），为防止污染全局空间，将其实现为 struct 作用域内变量，请勿显式修改

```c++
struct _9_4_4_1_Base {
    static int m;     // 表示哈希表的容量
    static int p;     // 除留余数法中的被除数 p，最好为不大于 m 的最大素数
    static void set(int parM, int parP) {
        m = parM;
        p = parP;
    }
};
int _9_4_4_1_Base::m = 50;     // m 默认为 50
int _9_4_4_1_Base::p = 47;     // 不大于 50 的最大素数

const int NULLKEY = -1;     // 定义空关键字类型，由此可见关键字不为负数
const int DELKEY = -2;     // 定义被删除的关键字值
typedef int KeyType;     // 关键字类型
typedef struct {
    KeyType key;     // 关键字
    int probeCount;     // 探测次数
} HashTable;     // 哈希表单元类型，创建数组是务必保证长度大于 m
```

插入算法；求出关键字 k 的哈希地址 adr，若该位置可以直接放置（即 adr 位置的关键字为 NULLKEY 或 DELKEY），将其放入；否则出现冲突，采用线性探测法在表中找到一个开放地址，将 k 插入

```c++
void InsertHT(HashTable ha[], KeyType k) {
    int adr = k % _9_4_4_1_Base::p;     // 计算哈希地址，除留余数法
    if (ha[adr].key == NULLKEY || ha[adr].key == DELKEY) {
        ha[adr].key = k;     // k 可以直接放在哈希表中
        ha[adr].probeCount = 1;
    } else {
    	// 发生冲突时采用线性探测法解决冲突，用 count 记录发生冲突的次数，也是探测的次数
    	int count = 1;
    	do {
    		adr = (adr + 1) % _9_4_4_1_Base::m;     // 线性探测
    		++count;
    	} while (ha[adr].key != NULLKEY && ha[adr].key != DELKEY);
    	// 探测结束，插入 k
    	ha[adr].key = k;
    	ha[adr].probeCount = count;
    }
}
```

建表算法；首先将表中各元素的关键字清空，使其地址为开放的，然后调用插入算法来插入 n 个关键字的序列；务必保证 HashTable 数组长度大于等于 m

```c++
void CreateHT(HashTable ha[], KeyType keys[], int n) {
	for (int i = 0; i < _9_4_4_1_Base::m; ++i) {
        ha[i].key = NULLKEY;     // 初始哈希表
        ha[i].probeCount = 0;
	}
	for (int i = 0; i < n; InsertHT(ha, keys[i++]));
}
```

删除算法；不能简单地将被删除元素的空间置为空，否则将截断在它之后填入哈希表的同义词的查找路径；因为在开放地址法中，空地址单元都是查找失败的条件，因此只能在被删除元素上做删除标记 DELKEY

```c++
bool DeleteHT(HashTable ha[], KeyType k) {
    int adr = k % _9_4_4_1_Base::p;
    while (ha[adr].key != k && ha[adr].key != NULLKEY) 
        adr = (adr + 1) % _9_4_4_1_Base::m;     // 线性探测
    if (ha[adr].key == k) {
    	// 查找成功，删除关键字 k
    	ha[adr].key = DELKEY;
    	return true;
    }
    return false;     // 查找失败，返回 false
}
```

查找算法；先计算出哈希地址，若地址上元素不为 k 且不为空，线性探测，直到某个地址为空（查找失败）或关键字比较相等（查找成功）

```c++
void SearchHT(HashTable ha[], KeyType k) {
    int count = 1;     // 比较次数
    int adr = k % _9_4_4_1_Base::p;
    while (ha[adr].key != k && ha[adr].key != NULLKEY) {
    	++count;     // 累计关键字的比较此数
    	adr = (adr + 1) % _9_4_4_1_Base::m;     // 线性探测
    }
    if (ha[adr].key == k) {
    	printf("Search Succeed. Key: %d , Comparsion count: %d\n", k, count);
    } else {
    	printf("Search Failed. Key: %d , Comparsion count: %d\n", k, count);
    }
}
```

查找性能分析；插入和删除的时间均取决于查找，故这里只分析查找运算的时间性能；采用线性探测法时计算成功和不成功平均查找长度的算法如下

```c++
void ASL(HashTable ha[]) {
    int succ = 0, unsucc = 0, n = 0;
    int adr, count;
    for (int i = 0; i < _9_4_4_1_Base::m; ++i) {
    	if (ha[i].key != NULLKEY) {
            succ += ha[i].probeCount;     // 统计查找成功时总的关键字比较次数
            ++n;     // 统计哈希表中关键字的个数
        }
    }
    printf("ASL of Success = %d / %d = %g\n", succ, n, succ * 1.0 / n);
    for (int i = 0; i < _9_4_4_1_Base::p; ++i) {
        count = 1;
        adr = i;
        while (ha[adr].key != NULLKEY) {
    		++count;
    		adr = (adr + 1) % _9_4_4_1_Base::m;
    	}
    	unsucc += count;      // 累计不成功时总的关键字比较次数
    }
    printf("ASL of Failed = %d / %d = %g\n", unsucc, _9_4_4_1_Base::p, unsucc * 1.0 / _9_4_4_1_Base::p);
}
```

#### (2) 用拉链法构造的哈希表的运算

仅参考，无法实际使用

此处教材采用了全局变量（就此只能同时存在一个 hash 表），为防止污染全局空间，将其实现为 struct 作用域内变量，请勿显式修改

```C++
struct _9_4_4_2_Base {
    static int m;     // 表示哈希表的容量
    static int p;     // 除留余数法中的被除数 p，最好为不大于 m 的最大素数
    static void set(int parM, int parP) {
        m = parM;
        p = parP;
    }
};
int _9_4_4_2_Base::m = 50;     // m 默认为 50
int _9_4_4_2_Base::p = 47;     // 不大于 50 的最大素数

typedef int KeyType;
typedef struct node {
    KeyType key;
    struct node* next;     // 下一个结点指针
} NodeType;
typedef struct {
	NodeType* firstNode;     // 首结点指针
} HashTable;     // 哈希表单元类型，采用顺序和链式相结合的存储结构
```

插入哈希表

```c++
void InsertHT(HashTable ha[], KeyType k) {
    int adr = k % _9_4_4_2_Base::p;
    NodeType* q = (NodeType*)malloc(sizeof(NodeType));
    q->key = k;
    q->next = ha[adr].firstNode;     // 采用头插法将新关键字结点插入到哈希表中
    ha[adr].firstNode = q;
}
```

创建哈希表

```c++
void CreateHT(HashTable ha[], KeyType keys[], int n) {
    for (int i = 0; i < _9_4_4_2_Base::m; ha[i++].firstNode = NULL);
    for (int i = 0; i < n; InsertHT(ha, keys[i++]));
}
```

删除算法

```c++
bool DeleteHT(HashTable ha[], KeyType k) {
    int adr = k % _9_4_4_2_Base::p;
    NodeType* q = ha[adr].firstNode;
    NodeType* pre = q;
    while (q != NULL && q->key != k) {
        pre = q;
        q = q->next;
    }
    if (q == NULL) {
    	return false;     // 未查找到，返回 false
    } else if (q->key == k) {
        pre->next = q->next;
        free(q);
        return true;
    }
    return false;
}
```

查找算法

```c++
void SearchHT(HashTable ha[], KeyType k) {
    int adr = k % _9_4_4_2_Base::p;
    int count = 0;
    NodeType* q = ha[adr].firstNode;
    while (q != NULL && q->key != k) {
        ++count;
        q = q->next;
    }
    if (q != NULL && q->key == k) {
    	printf("Search Succeed. Key: %d , Comparsion count: %d\n", k, count);
    } else {
    	printf("Search Failed. Key: %d , Comparsion count: %d\n", k, count);
    }
}
```

查找性能分析

```c++
void ASL(HashTable ha[]) {
    int succ = 0, unsucc = 0, n = 0, count;
    NodeType* q;
    for (int i = 0; i < _9_4_4_2_Base::m; ++i) {
    	count = 0;
    	q = ha[i].firstNode;
    	while (q != NULL) {
    		++n;
    		q = q->next;
    		++count;
    		succ += count;
    	}
    	unsucc += count;
    }
    printf("ASL of Success = %d / %d = %g\n", succ, n, succ * 1.0 / n);
    printf("ASL of Failed = %d / %d = %g\n", unsucc, _9_4_4_2_Base::m, unsucc * 1.0 / _9_4_4_2_Base::m);
}
```

# 十、内排序

## （一）排序（sort）的基本概念

一组元素组成的表，指定一个数据项为关键字作为排序运算的依据；所谓排序就是要整理表中的元素，使之按关键字递增或递减有序排列

当一维表中的元素关键字都不同时，排序结果唯一，否则不唯一；对于存在多个相同关键字的一维表，如果相同关键字的元素的相对次序在排序后不变，则称这种算法是稳定的（stable），否则为不稳定的（unstable）

若整个表都存在于内存中，排序时不涉及数据的内、外存交换，则称之为内排序（internal sort）；若存在内、外存交换，则称之为外排序（external sort）

其主要进行两种基本操作：比较（compare）和移动（move）；若待排序元素的关键字顺序正好和排序顺序相同，称此表中元素为正序；反之则为反序

对于 n 个元素排序结果有 n! 种情况，对应的判定树是一颗有 n! 个叶子结点的高度最小的二叉树，分支节点个数为0，总结点数 = n0+n2 = 2n! - 1，其高度 h = ⌈log2(2n!)⌉ = ⌈log2(n!)⌉ + 1，关键字比较次数最多的次数为 c = h - 1 = ⌈log2(n!)⌉ ≈ nlog2(n)

故从平均情况看，大约需要 nlog2(n) 次关键字比较（所有 n! 种排序情况的关键字比较次数的平均值），移动次数 和 比较次数 也是相同的数量级，所以基于比较的排序算法最好的平均时间复杂度为 O(nlog2(n))

排序数据的组织

```c++
typedef int KeyType;     // 定义关键字类型为 int
typedef int InfoType;     // 其他数据类型
typedef struct {
    KeyType key;     // 关键字项
    InfoType data;     // 其他数据项
} RecType;     // 排序元素的类型
```

## （二）插入排序（insertion sort）

默认：递增排序

插入排序的基本思想：每次将一个待排序的元素按其关键字大小插入到前面已经排序好的子表中的适当位置，直到全部元素插入完成为止

直接插入排序（straight insertion sort），折半插入排序（binary insertion sort），希尔排序（shell sort）

### 1. 直接插入排序（straight insertion sort）

假设待排序的元素存放在 R[0...n-1]中，在排序过程中，其被分为连个子区间，已经排好的有序区（ordered region）R[0...i-1]，和未排序的无序区（disordered region）R[i...n-1]

直接插入排序（straight insertion sort）的一趟操作是将当前无序区的开头元素 R[i] 插入到有序区中的适当位置，使 R[0...i] 变为有序区

这种方法通常称为 增量法，因为它每次使有序区增加一个元素

说明：直接插入排序每趟产生的有序区并不一定使全局有序区，就是说有序区中的元素并不一定放在排序完的最终位置上；当一个元素在整个排序过程中就已经放在其最终位置上称为归位（homing）

直接插入排序（递增排序），O(n^2)

1. 先将 R[i] 暂存到 tmp 中
2. j 在有序区中从后向前查找（j初值为i-1），凡是关键字大于 temp.key 的记录均后移一个位置，直到找到某个位置 j，有 R[j].key <= tmp.key，则将 tmp 放在 R[j] 的后面

```c++
void InsertSort(RecType R[], int n) {
    RecType tmp;
    int j;     // 用来从后向前遍历 有序区R[0...i-1]
    // n-1 趟
    for (int i = 1; i < n; ++i) {
    	// 若 i 比 i - 1 位置小，即不符合递增，应对其排序
    	if (R[i].key < R[i - 1].key) {
    		tmp = R[i];
    		j = i - 1;
    		// 寻找 R[i] 的插入位置
    		do {
    			R[j + 1] = R[j];     // 将关键字大于 R[i].key 的记录后移
    			--j;
    		} while (j >= 0 && R[j].key > tmp.key);
    		// 最后 j 指向第一个小于 R[i]（tmp）的元素，j + 1 即插入位置
    		R[j + 1] = tmp;     // 在 j+1 处插入 R[i]
    	}
    }
}
```

当初始数据不同时，直接插入排序所耗费的时间有很大的差异

最好的情况是表初态为正序，此时算法的最好时间复杂度为 O(n)；最坏的情况是表初态为反序，此时算法的最坏时间复杂度为 O(n^2)；算法的平均时间复杂度为 O(n^2)，也就是说算法的平均时间复杂度接近最坏情况

算法中使用的辅助变量与问题规模 n 无关，故算法辅助空间复杂度为 O(1)，也就是说它是一个就地排序算法；另外在算法运行中，保持元素的相对顺序不变，故该算法是一种稳定的排序方法

### 2. 折半插入排序（binary insertion sort）

直接插入排序中将无序区的开头元素R[i]（1 <= i <= n-1）插入到有序区R[0..i-1]是采用的顺序比较法

由于有序区的元素是有序的，可以采用折半查找法在有序区R[0..i-1]中寻找插入位置，再统一移到元素进行插入，这样的插入排序称为折半插入排序或二分插入排序

第 i 趟在R[lowIndex..highIndex]（初始时low = 0，high = i-1）中采用折半查找方法查找插入R[i]的位置为R[high+1]，再将R[high+1..i-1]元素后移一个位置，并插入即置R[high+1] = R[i]

说明：和直接插入排序一样，折半插入排序每趟产生的有序区不一定是全局有序区

```c++
void BinInsertSort(RecType R[], int n) {
    int lowIndex, highIndex, midIndex;
    RecType tmp;
    for (int i = 0; i < n; ++i) {
        // 反序时，即不符合要排序的顺序，应对其进行排序
        if (R[i].key < R[i - 1].key) {
            tmp = R[i];     // 将 R[i] 保存到tmp中
            lowIndex = 0;
            highIndex = i - 1;
            // 在 R[low..high] 中找到插入位置，初始时为整个有序区
            while (lowIndex <= highIndex) {
            	midIndex = (lowIndex + highIndex) / 2;
            	if (tmp.key < R[midIndex].key) {
            		highIndex = midIndex - 1;
            	} else {
            		lowIndex = midIndex + 1;
        		}
    		} // 最后 highIndex 所指即第一个小于 R[i]（tmp） 的位置，highIndex + 1 即插入位置
    		// 移动元素
    		for (int j = i - 1; j > highIndex; --j) {
    			R[j + 1] = R[j];
    		}
    		R[highIndex + 1] = tmp;
    	}
    }
}
```

实际上，折半插入排序和直接插入排序相比移动元素的性能没有改善，仅仅减少了关键字的比较次数，就平均性能而言，由于折半查找优于顺序查找，所以折半插入排序也优于直接插入排序；该算法的平均时间复杂度为 O(n^2)，空间复杂度为 O(1)，也是一种稳定的排序方法

### 3. 希尔排序（shell sort）

希尔排序也是一种插入排序，实际上是一种分组插入方法；先取一个小于 n 的整数 d1 作为第一个增量，把表的全部元素分成 d1 个组，将所有距离为 d1 的倍数的元素放在同一组，如下：

| 第1组 |  0   |   d   |   2d   | ...  |    kd    |
| :---: | :--: | :---: | :----: | :--: | :------: |
| 第2组 |  1   |  1+d  |  1+2d  | ...  |   1+kd   |
|  ...  | ...  |  ...  |  ...   | ...  |   ...    |
| 第i组 | i-1  | i-1+d | i-1+2d | ...  |  i-1+kd  |
|  ...  | ...  |  ...  |  ...   | ...  |   ...    |
| 第d组 | d-1  | 2d-1  |  3d-1  | ...  | (k+1)d-1 |

- k = n/d - 1，衡量每组元素的个数

在各组内进行直接插入排序；然后取第二个增量 d2（<d1），重复上述的分组和排序，直到所取的增量 dt = 1（dt < d(t-1) < ... < d2 < d1），即所有的元素放在同一组中进行直接插入排序为止，所以希尔排序称为减少增量的排序方法

每一趟希尔排序从元素R[d]（每组的第二个元素）开始起，采用直接插入排序，直到元素 R[n-1] 为止，每个元素的比较和插入都在同组内部进行，对于元素R[i]，同组的前面的元素有 { R[j] | j = i - d >= 0 }

说明：希尔排序每趟并不产生有序区，在最后一趟排序结束前，所有的元素并不一定归位了，但是在希尔排序每趟完成后数据越来越接近有序

```c++
// 取 d1 = n/2，d(i+1) = ⌊di/2⌋ 时的希尔排序算法如下
void ShellSort(RecType R[], int n) {
    int j;     // 用来遍历有序区
    RecType tmp;
    int d = n / 2;     // 增量置初值
    while (d >= 1) {
    	// 对所有组采用直接插入排序
    	for (int i = d; i < n; ++i) {
    		tmp = R[i];
    		j = i - d;    // 对相隔 d 个位置一组采用直接插入排序
    		while (j >= 0 && tmp.key < R[j].key) {
    			R[j + d] = R[j];
    			j = j - d;
    		}     // 最后 j 指向第一个小于 R[i]（tmp）的元素，j + d 即插入位置
    		R[j + d] = tmp;
    	}
    	d = d / 2;     // 减少增量
    }
}
```

希尔排序算法的时间是一个所取“增量”序列的函数，到目前为止增量的选取无一定论，但无论增量如何取，最后一个增量必须等于 1；希尔算法的时间复杂度难以分析，一般认为其平均时间复杂度为 O(n^1.3)，其速度通常比直接插入排序快；辅助空间复杂度为 O(1)，即希尔排序是一个就地排序，另外希尔排序算法是一种不稳定的排序算法

## （三）交换排序（swap sort）

默认：递增排序

交换排序的基本思想是两两比较待排序元素的关键字，发现这两个元素的次序相反即时进行交换，直到没有反序的元素为止；冒泡排序（bubble sort），快速排序（quick sort）

工具，交换算法

```c++
struct _10_3_Util {
    static void swap(_10_1::_10_1_5::RecType& a, _10_1::_10_1_5::RecType& b) {
        _10_1::_10_1_5::RecType tmp = a;
        a = b;
        b = tmp;
    }
};
```

### 1. 冒泡排序（bubble sort）

冒泡排序也称为气泡排序，是一种典型的交换排序方法，其基本思想是：

通过无序区中相邻元素关键字间的比较和位置的交换使得关键字较小的元素如气泡一般逐渐往上“漂浮”直到“水面”，整个算法从最下面的元素开始，对每两个相邻的关键字进行比较，且使关键字较小的元素换至关键字较大的元素之上，使得经过一趟冒泡排序后关键字最小的元素到达最上端；接着在剩下的元素中找到关键字次小的元素，并把它换至第二个位置上，以此类推，直到所有的元素都有序为止

说明：冒泡排序每趟产生的有序区一定是全局有序的，也就是说每趟产生的有序区中的所有元素都归位了

```c++
void BubbleSort(RecType R[], int n) {
    // 共需要 n - 1 趟冒泡比较
    for (int i = 0; i < n - 1; ++i) {
    	// 将 R[i] 元素归位
    	for (int j = n - 1; j > i; ++i) {
    		// 相邻的两个元素反序时
    		if (R[j].key < R[j - 1].key) {
    			_10_3_Util::swap(R[j], R[j - 1]);     // 将 R[j] 和 R[j-1] 两个元素交换
    		}
    	}
    }
}
```

在有些情况下，在第 i（i < n-1）趟时已经排好序了，但仍会执行后面的几趟比较；实际上，一旦算法中的某一趟比较时不出现任何元素交换，说明已经排序好了，就可以结束算法，为此改进的冒牌排序如下

```c++
void BubbleSort_Refine(RecType R[], int n) {
    bool exchanged = false;
    for (int i = 0; i < n - 1; ++i) {
    	exchanged = false;
    	for (int j = n - 1; j > i; --j) {
    		if (R[j].key < R[j - 1].key) {
    			_10_3_Util::swap(R[j], R[j - 1]);
    			exchanged = true;
    		}
    	}
    	if (!exchanged) {
    		return;
    	}
    }
}
```

当初始数据不同时，冒牌排序所耗费的时间有很大的差异；最好的情况是表初态为正序，此时算法的最好时间复杂度为 O(n)；最坏的情况是表初态为反序，此时算法的最坏时间复杂度为 O(n^2)；算法的平均时间复杂度为 O(n^2)，也就是说算法的平均时间复杂度接近最坏情况

虽然冒泡排序不一定要进行 n-1 趟，但由于它的元素移动次数较多，一般平均时间性能要比直接插入排序差，算法中使用的辅助变量与问题规模 n 无关，故算法辅助空间复杂度为 O(1)，也就是说它是一个就地排序算法；另外在算法运行中，保持元素的相对顺序不变，故该算法是一种稳定的排序方法

### 2. 快速排序（quick sort）

快速排序是由冒泡排序改进而得的，它的基本思想是在待排序的 n 个元素中任取一个元素（通常取第一个元素）作为基准元素，把该元素放入适当的位置后；数据序列被划分为两部分，所有关键字比该元素关键字小的元素放置在前一部分，所有比它大的元素放置在后一部分，并把该元素放在这两部分的中间（称为该元素归位）

这个过程称为一趟快速排序，即一趟划分，之后对产生的两个部分分别重复上述过程，直至每部分内只有一个元素或空为止

简而言之，每趟使表的第一个元素放入适当位置，将表一分为二，对子表按递归方式继续这种划分，直到划分的子表的长度为1或0

 一趟快速排序的划分过程 partition(R,leftIndex,rightIndex) 是采用从两头向中间扫描的办法，同时交换与基准元素逆序的元素，具体方法是：

1. 设两个指示器 i 和 j，它们的初始值分别指向无序区中的第一个元素和最后一个元素，假设无序区中的元素为 R[leftIndex, leftIndex+1, ..., rightIndex]，则 i 的初始值为 leftIndex，j 的初始值为 rightIndex
2. 首先将 R[leftIndex] 移置变量 tmp 中作为基准；令 j 自位置 right 起向前扫描直至 R[j].key < tmp.key 时将 R[j] 移至位置 i，然后让 i 向后扫描直至 R[i].key > tmp.key 时将 R[i] 移至位置 j
3. 依次重复直到 i == j，此时所有 R[left, left+1, ..., i-1] 的关键字都小于 tmp.key，而所有 R[i+1, i+2, ..., right] 的关键字都大于 tmp.key
4. 此时再将 tmp 中的元素移至位置 i，它将无序区中的元素分割成 R[left..i-1] 和 R[i+1..right]，以便分别进行排序

说明：快速排序每趟仅将一个元素归位；显然，快速排序是一个递归过程，其递归模型如下：

f(R,leftIndex,rightIndex)，不做任何事情；当 R[leftIndex..rightIndex]中没有元素或只有一个元素时，i = partition(R,left,right)；其他情况，f(R,left,i-1)，f(R,i+1,right)

基础算法，请勿显式调用

```c++
// 一趟划分
static int partition(RecType R[], int leftIndex, int rightIndex) {
    int i = leftIndex, j = rightIndex;
    RecType tmp = R[i];     // 以 R[i] 为基准
    // 从两端交替向中间扫描，直到 i == j 为止
    while (i < j) {
        // 从右向左扫描，找第一个小于 tmp.key 的 R[j]
    	while (i < j && R[j].key >= tmp.key) --j;     
    	R[i] = R[j];     // 找到这样的 R[j]，将其放入到 R[i] 中
        // 从左向右扫描，找第一个大于 tmp.key 的 R[i]
	    while (i < j && R[i].key <= tmp.key) ++i;     
    	R[j] = R[i];     // 找到这样的 R[i]，将其放入到 R[j] 中
    }
    R[i] = tmp;     // 将基准元素放入到适当的位置
    return i;
}
// 划分的另一种实现方式，也要掌握
int partition2(int R[], int leftIndex, int rightIndex)
{
	int pivot = R[leftIndex];
	int i = leftIndex;
	for (int j = leftIndex + 1; j <= rightIndex; j++)
	{
		if (R[j] < pivot)
		{
			int tmp = R[++i]; R[i] = R[j]; R[j] = tmp;
		}
	}
	int tmp = R[i]; R[i] = R[leftIndex]; R[leftIndex] = tmp;
	return i;
}
```

快速排序

```c++
void QuickSort(RecType R[], int leftIndex, int rightIndex) {
    // 区间内至少存在两个元素的情况
    if (leftIndex < rightIndex) {
        int i = _10_3_2_Base::partition(R, leftIndex, rightIndex);     // 划分
        QuickSort(R, leftIndex, i - 1);      // 对左区间递归排序
        QuickSort(R, i + 1, rightIndex);     // 对右区间递归排序
    }
}
```

实际上，在快速排序中可以以任意一个元素为基准（更好的选择方法时从数序中随机选择一个元素作为基准），以下算法以当前区间的中间位置的元素为基准，同样可以达到快速排序的目的

```c++
void QuickSort_2(RecType R[], int leftIndex, int rightIndex) {
    if (leftIndex < rightIndex) {
    	int pivot = (leftIndex + rightIndex) / 2;     // 用区间中间元素作为基准
    	if (pivot != leftIndex) {
    		// 若基准不是区间的第一个元素，则将之与第一个元素互换
            // 照顾到 partition() 内部是将区间的第一个元素作为基准的
		    _10_3_Util::swap(R[pivot], R[leftIndex]);
    	}
    	int i = _10_3_2_Base::partition(R, leftIndex, rightIndex);     // 划分
    	QuickSort_2(R, leftIndex, i - 1);
    	QuickSort_2(R, i + 1, rightIndex);
    }
}
```

快速排序，非递归实现

```c++
void QuickSort_NoRecursion(RecType R[], int firstIndex, int lastIndex) {
    struct Pair {
        int beginIndex;
        int endIndex;
        void set(int a, int b) { beginIndex = a; endIndex = b; }
        void get(int& a, int& b) { a = beginIndex; b = endIndex; }
    };
    Pair* st = new Pair[lastIndex - firstIndex + 1];
    int top = -1;     // 栈，用来存储每次递归调用时的无序区间的 左索引 和 右索引
    int leftIndex = firstIndex, rightIndex = lastIndex;   // 每次递归调用时的无序区的范围
    int i, j;     // 用于划分的指示器
    RecType tmp;     // 基准元素
    st[++top].set(leftIndex, rightIndex);     // 初次调用现场入栈
    // 栈不为空循环
    while (top >= 0) {
    	st[top--].get(leftIndex, rightIndex);
    	if (leftIndex >= rightIndex) continue;
    	i = leftIndex; j = rightIndex;
    	tmp = R[i];     // 选取该区间的第一个元素作为基准元素
    	while (i < j) {
    		while (i < j && R[j].key >= tmp.key) --j;
    		R[i] = R[j];
    		while (i < j && R[i].key <= tmp.key) ++i;
    		R[j] = R[i];
    	}
    	R[i] = tmp;     // 将基准元素放入到适当位置
    	// 将递归调用的 左区 和 右区 的状态现场依次进栈
    	st[++top].set(i + 1, rightIndex);
    	st[++top].set(leftIndex, i - 1);
    }
}
```

最好的情况是每一次划分都将 n 个元素划分为两个长度差不多的子区间，这样递归树的高度为 O(log2(n))，而每一层划分的时间为 O(n)，所以此时算法的时间复杂度为 O(n\*log2(n))，空间复杂度为 O(n)；

最坏的情况是每次划分选取的基准都是当前无序区中关键字最小（或最大）的元素，划分的结果是基准左边的子区间为空（或右边的子区间为空）；而划分所得的另一个非空的子区间中的元素的数目仅比划分前的无序区中的元素个数减少一个；这样的递归树的高度为 n，需要做 n-1 次划分，此时算法的时间复杂度为 O(n^2)，空间复杂度为 O(n)

在平均的情况下，平均时间复杂度为 O(n*log2(n))，也就是说，算法的平均时间复杂度接近最好情况，平均空间复杂度为 O(log2(n))；另外，快速排序算法是一种不稳定的排序方法

## （四）选择排序（selection sort）

默认：递增排序

选择排序的基本思想是每一趟从待排序的元素中选出关键字最小的元素，顺序放在已排好序的子表最后，直到全部元素排序完毕；由于选择排序方法每一趟总是从无序区中选出全局最小（或最大）的关键字，所以适合于从大量的元素中选择一部分排序元素；简单选择排序（simple selection sort，又称直接选择排序）、堆排序（heap sort）

### 1. 简单选择排序（simple selection sort)

简单选择排序的基本思想是第 i 趟排序开始时，当前有序区和无序区分别为 R[0..i-1] 和 R[i..n-1]（0 <= i < n-1），该趟排序是从当前无序区中选出关键字最小的元素 R[k]，将其与无序区中的第一个元素交换，使 R[0..i] 和 R[i+1..n-1] 分别变为新的有序区和无序区

因为每趟排序均使有序区中增加了一个元素，且有序区中的元素的关键字都不大于无序区中元素的关键字，即第 i 趟排序之后，R[0..i] 的关键字均小于等于 R[i+1..n-1] 的关键字；所以进行 n-1 趟排序之后 R[0..n-2] 的所有关键字均小于等于 R[n-1].key，也就是说，经过 n-1 趟排序后整个表递增有序

说明：简单选择排序每趟产生的有序区一定是全局有序区，也就是说，每趟产生的有序区中所有元素都归位了

```c++
void SelectSort(RecType R[], int n) {
    int k;     // 某次排序中最小元素的位置
    // n - 1 趟排序
    for (int i = 0; i < n - 1; ++i) {
    	k = i;
    	for (int j = i + 1; j < n; ++j) {
    		if (R[j].key < R[k].key) {
    			k = j;     // 在当前的无序区中选择关键字最小的元素的位置
    		}
    	}
    	if (k != i) {
    		_10_3::_10_3_Util::swap(R[i], R[k]);
    	}
    }
}
```

无论初始数据序列的状态如何，在第 i 趟排序中选出最小关键字的元素，所需要的关键字比较相同，因此总的平均时间复杂度为 O(n^2)；辅助变量与问题规模 n 无关，故辅助空间复杂度为 O(1)，也就是说该算法是一个就地排序；另外，简单选择排序算法是一个不稳定的排序算法

### 2. 堆排序（heap sort）

堆排序是一种树形选择排序法，它的特点是将 R[0...n-1] 看成是一棵完全二叉树的顺序存储结构（ i 为逻辑编号 1...n ），利用完全二叉树中的双亲结点和孩子结点之间的位置关系（ i 的左右孩子分别为 2i，2i+1）在无序区中选择关键字最大（或最小）的元素

当 R[0...n-1] 中的 n 个关键字序列 k0, k1, ..., kn 满足如下性质（堆性质）时，称为堆

ki <= k(2i) 且 ki <= k(2i+1)（小根堆） 或 ki >= k(2i) 且 ki >= k(2i+1)（大根堆）

堆排序的排序过程与简单的选择排序类似，只是挑选最大或最小元素时采用的方法不同，这里采用大根堆，每次挑选最大元素归位

挑选最大元素是采用筛选方法实现的，思想为：大者上浮，小者被筛下去；其过程如下：（ i 为逻辑编号）

1. 假设正在处理的元素 R[i] 为某棵子二叉树的根结点，它的左右子树已经是大根堆，将其两个孩子的关键字的最大者与根的关键字比较
   1. 若根的关键字 R[i].key 较小，将其与最大孩子（ MAX{ R[2i], R[2i+1] } ）进行交换（即筛下去）

2. 交换有可能破坏下一级的堆，故继续采用上述方法构造修复刚刚交换孩子（下一级）的堆，直到这颗完全二叉树变成一个大根堆为止
3. 假设对 R[lowIndex...highIndex] 进行筛选，必须满足：以 lowIndex 为根结点的左右子树均为大根堆；注意物理编号（0...n-1），根结点为 index，左右孩子节点为 2 * index + 1 和 2 * index + 2

基础算法，请勿显式调用

```C++
static void sift(RecType R[], int lowIndex, int highIndex) {
    int i = lowIndex, j = 2 * i + 1;     // R[j] 是 R[i] 的左孩子
    RecType tmp = R[i];
    while (j <= highIndex) {
    	// 若右孩子关键字较大，把 j 指向右孩子
    	if (j < highIndex && R[j].key < R[j + 1].key) {
    		++j;
    	}
    	// 此处 j 指向最大孩子，若根结点小于最大孩子，交换之，并修复下一级的堆
    	if (tmp.key < R[j].key) {
    		R[i] = R[j];     // 将最大孩子 R[j] 调整到当前处理的双亲结点 R[i] 的位置上
    		i = j;           // 修改 i 和 j 的值，指向下一级，以便继续向下筛选
    		j = 2 * i + 1;
    	} else {
    		break;     // 若根结点大于等于最大孩子，筛选结束
    	}
    }
    R[i] = tmp;     // 被筛的结点放到适合的最终位置上
}
```

堆排序（递增排序）

构建初始堆 R[0...n-1] 的过程是：对于一颗完全二叉树，从物理编号 i = ⌊n/2⌋-1 ~ 0，即最后一个分支结点开始，利用上述筛法建堆

在初始堆 R[0...n-1] 构造完成后，根结点 R[0] 一定是最大关键字结点，将其放到序列最后，即堆中的根 R[0] 与最后一个叶子结点 R[n-1] 交换；最大元素归位，整个待排序元素个数减少一个，且由于根结的改变，这 n-1 个结点 R[0...n-2] 不一定为堆，但 R[0] 的左右子树均为堆，故再调用一次筛法 sift 将这 n-1 个结点 R[0...n-2] 调整成堆，其根结点 R[0] 为次大元素，将之放到序列的倒数第二个位置，即与堆中最后一个叶子结点交换

如此重复，直到完全二叉树中只剩下一个根为止

```c++
void HeapSort(RecType R[], int n) {
    // 循环建立初始堆，调用 sift 算法 ⌊n/2⌋ 次
    for (int i = n / 2 - 1; i >= 0; _10_4_2_Base::sift(R, i--, n - 1));
    // 进行 n-1 趟完成堆排序，每一趟堆中元素个数减1
    for (int i = n - 1; i > 0; --i) {
    	// 将最后一个元素与根 R[0] 交换
    	_10_3::_10_3_Util::swap(R[0], R[i]);
    	_10_4_2_Base::sift(R, 0, i - 1);  // 对 R[0...n-2] 进行筛选，得到 i-1 个结点的堆
    }
}
```

堆排序的时间主要由建立初始堆和反复重建堆这两部分的时间构成，它们均是通过调用 sift() 实现的，对于高度为 k 的完全二叉树/子树，调用 sift() 时，其中 while 循环最多执行 k-1 次，最多进行 2(k-1) 次比较，最多进行 k+1 次移动，因此主要以关键字比较来分析时间性能

堆排序的最坏时间复杂度为 O(n\*log2(n))，平均时间复杂度分析较难，但实验研究表明，它接近最坏性能；实际上，堆排序和简单选择排序算法一样，其时间性能与初始序列顺序无关，也就是说，堆排序的算法最好、最坏和平均时间复杂度都是 O(n\*log2(n))

由于建初始堆所需的比较次数较多，所以堆排序不适合元素较少的排序表；辅助空间复杂度为 O(1)，堆排序算法是一种不稳定的排序算法

## （五）归并排序（merge sort）

默认：递增排序

归并排序是多次将两个或两个以上的有序表合并成一个新的有序表，最简单的归并是直接将两个有序的子表合并成一个有序的表，即二路归并，二路归并排序（2-way merge sort）的基本思想是将 R[0..n-1]看成是 n 个长度为 1 的有序序列，然后进行两两归并，得到 ⌈n/2⌉ 个长度为 2（最后一个可能小于2）的有序序列

再进行两两归并，得到 ⌈n/4⌉ 个长度为 4（最后一个有序序列长度可能小于4）的有序序列，...，直到得到一个长度为 n 的有序序列

说明：归并排序每趟产生的有序区只是局部有序的，也就是说再最后一趟排序结束前所有的元素并不一定归位了

将两个有序表直接归并为一个有序表的算法 Merge()：

1. 设两个有序表放在同一数组中相邻的位置上，即 R[beginIndex..endIndexOne]（第一段）和 R[endIndexOne+1..endIndexTwo]（第二段）
2. 先将它们合并到一个局部的暂存数组 Rtmp 中，待合并完成后再将其复制到 R 中
3. 每次从两个段中取出一个元素进行关键字比较，将较小者放入 Rtmp 中，较大者留作下次比较，最后将各段中余下的部分直接复制到 Rtmp 中，最后将 Rtmp 复制给 R

基础算法，请勿显式调用

```c++
static void Merge(RecType R[], int beginIndex, int endIndexOne, int endIndexTwo) {
    if (beginIndex > endIndexOne || endIndexOne > endIndexTwo) return;
	// i，j，k 分别扫描 第一段，第二段，Rtmp
    int i = beginIndex, j = endIndexOne + 1, k = 0;
    RecType* Rtmp = (RecType*)malloc((endIndexTwo - beginIndex + 1) * sizeof(RecType));     // 动态分配空间
    while (i <= endIndexOne && j <= endIndexTwo) {
    	if (R[i].key <= R[j].key) {
    		Rtmp[k++] = R[i++];     // 将第一段放入 Rtmp
    	} else {
    		Rtmp[k++] = R[j++];     // 第二代放入 Rtmp
    	}
    }
    // 将剩下的元素放入 Rtmp
    while (i <= endIndexOne) Rtmp[k++] = R[i++];
    while (j <= endIndexTwo) Rtmp[k++] = R[j++];
    // 将合并好的有序序列复制给 R
    for (int m = beginIndex, n = 0; m <= endIndexTwo; R[m++] = Rtmp[n++]);
    free(Rtmp);
}
```

Merge() 实现了一次归并，其中使用的辅助空间正好是要归并的元素的个数，接下来利用 Merge() 解决一趟归并问题；在某趟归并中，设各子表的长度为 length（最后一个子表的长度可能小于length），则归并前 R[0..n-1] 中共有 ⌈n/length⌉ 各子表：R[0..length-1]，R[length..2*length-1]，...，R[length*⌊n/length⌋..n-1]

在调用 Merge() 将相邻的一对子表进行归并时，必须对表的个数可能是奇数以及最后一个子表的长度小于 length 这两种特殊的情况进行特殊处理：

若子表的个数为奇数，则最后一个子表无须和其他子表归并（即本趟为空）；若子表的个数为偶数，则要注意最后一对子表中最后一个子表区间的上界是 n-1

对整个排序序列进行一趟归并

```c++
static void MergePass(RecType R[], int length, int n) {
    int i;
    // 归并长度为 length 的两个相邻子表，若最后剩下的长度小于 2 * length，则不处理
    for (i = 0; i + 2 * length - 1 < n; i = i + 2 * length) {
    	Merge(R, i, i + length - 1, i + 2 * length - 1);
    }
    // 在此处理剩下的表（长度小于2*length），若 i+length-1 > n-1 即剩下的表不足length长，
    // 即表的个数为奇数，不处理；否则处理最后两个表，注意最后一个表的末尾为 n-1
    if (i + length - 1 < n - 1) {
    	Merge(R, i, i + length - 1, n - 1);
    }
}
```

上述二路归并排序实际上采用的是自底向上的过程，也可以采用自顶向下的递归过程，其算法如下：

对 R[lowIndex..highIndex] 进行二路归并

```c++
static void MergeSortRecursionHepler(RecType R[], int lowIndex, int highIndex) {
    if (lowIndex < highIndex) {
        int mid = (lowIndex + highIndex) / 2;
        MergeSortRecursionHepler(R, lowIndex, mid);
        MergeSortRecursionHepler(R, mid + 1, highIndex);
        Merge(R, lowIndex, mid, highIndex);
    }
}
```

在进行二路归并时，第1趟归并排序对应length=1，第2趟对应length=2，第3趟对应length=4，...，每一次length翻一倍，但总小于n，所以总趟数为 ⌈log2(n)⌉

```c++
void MergeSort(RecType R[], int n) {
    for (int length = 1; length < n; length = 2 * length) {
    	_10_5_Base::MergePass(R, length, n);     // 进行 ⌈log2(n)⌉ 趟归并
    }
}
```

自顶向下的递归的二路归并排序

```c++
void MergeSort_Recursion(RecType R[], int n) {
	_10_5_Base::MergeSortRecursionHepler(R, 0, n - 1);
}
```

对于长度为 n 的排序表，二路归并需要进行 ⌈log2(n)⌉ 趟，每趟归并的时间为 O(n)，故其最好、最坏和平均时间复杂度都为 O(n\*log2(n))；每次二路归并都需要使用一个辅助数组来暂存两个有序子表归并的结果，而每次归并后都会释放其空间，但最后一趟需要所有的元素参与归并，故辅助空间复杂度为 O(n)

另外，在一次二路归并中，元素的相对次序不会发生改变，该算法是一种稳定的排序算法；归并排序可以是多路的，如三路归并排序等，归并的趟数为 log3(n)，一趟的时间为 O(n)，时间复杂度为 n*log3(n) = n*log2(n)/log2(3) 仍为 O(n*log2(n))

不过三路归并排序算法的实现远比二路归并排序算法复杂

## （六）基数排序（radix sort）

默认：递增排序

基数排序（radix sort）是通过“分配”和“收集”过程来实现排序，不需要进行关键字间的比较，是一种借助于多关键字排序的思想对单关键字排序的方法

一般情况下，元素 R[i] 的关键字 R[i].key 由 d（digit） 位数字（或字符）组成，即 k:d-1,d-2,...1,0，每一个数字表示关键字的一位，其中 d-1 位最高位，0 位最低位，每一位的值都在 0 <= ki < r 范围内，其中 r 为基数（radix），例如对于二进制 r 为 2，对于十进制 r 为 10 等

基数排序有两种，即最低为优先（least significant digit first，LSD）和最高位优先（most significant digit first，MSD），其原理是相同的，这里主要讨论前者

最低为优先的过程是先按最低位的值对元素进行排序，在此基础上再次按次低位进行排序，以此类推；由低位到高位，每趟都是根据关键字的一位并在前一趟的基础上对所有的元素进行排序，直至最高位，则完成了基数排序的整个过程

对一个数据序列采用LSD还是MSD需要由数据序列的特点确定，一般越重要的位越放在后面排序；以 r（radix）为基数的最低位优先排序的过程是：假设线性表由元素序列 a0, a1, a2, ..., a(n-1) 构成，每个元素 aj 的关键字为 d 的元组 kj:d-1,d-2,...1,0；其中 0 <= kj(i) <= r-1（0 <= j < n，0 <= i <= d-1），在排序过程中使用 r（基数radix）个队列 Q0, Q1, Q2, ..., Q(r-1)，排序过程如下：

1. 对所有位数由低到高 i = 0,1, ..., d-1 依次做一次“分配”和“收集”（即一次稳定排序的过程）
2. 分配：开始时，把 Q0,Q1,...,Q(r-1) 各个队列置成空队列，然后依次考查线性表中每一个元素 aj (j = 0,1,...,n-1)，根据元素 aj 的关键字 aj.ki（设为k），把元素插入到 Qk 中
3. 收集：将 Q0,Q1,...Q(r-1) 各个队列中的元素依次首尾相接，得到新的元素序列，从而组成新的线性表，在 d 趟执行之后数据序列就有序了

说明：基数排序每趟并不产生有序区，与就是说在最后一趟排序结束前所有元素并不一定归位了

基础算法和结构，请勿显式调用

```c++
// 在基数排序中每个元素多次进出队列，如果采用顺序表存储，需要有大量元素的移动，
// 而采用链式即构存储时，只需修改相关指针域
// 假设待排序的数据序列存放在以 p 为首结点的指针的单链表中，其中结点类型 NodeType 的声明如下：
static const int MAXDigit = 10;   // 最大关键字位数，此处为一个 int（ 2^32 - 1 = 4.5E+9 ）
typedef struct node {
    char digit[MAXDigit + 1]; // 关键字位数，地位到高位（适配时逆序该数组可在LSD和MSD中间转换）
    struct node* next;        // 指向下一个结点
} NodeType;     // 基数排序数据的结点类型
static const int MAXRadix = 16;     // 最大支持16进制
// 其中，digit 域存放关键字，它是一个字符数组，data[0..MAXDigit-1] 
// 依次存放关键字的低位到高位的各数字字符，关键字的实际位数由参数 d 指定

// 以下基数排序算法 RadixSort(p,r,d) 实现LSD方法（此处根据教程录入，实际可更改），
// 其中参数 p 为存储的待排序序列的单链表的指针，r 为基数，d 为关键字位数
static void RadixSort_base(NodeType*& p, int radix, int digit) {
	// 定义各链队的首尾指针（ head[i] 和 tail[i] 为同一个链队 ），
    // 链队的个数为基数的大小，即 0,1,...,r-1
    NodeType *head[MAXRadix], *tail[MAXRadix];
    NodeType* t = NULL;     // t 用来指向 p 的尾结点
    int k;     // 用来指示该元素属于哪个链队
    // 用 d 从低位到高位扫描
    for (int d = 0; d < digit; ++d) {
    	for (int i = 0; i < radix; ++i) {
    		head[i] = tail[i] = NULL;     // 每次扫描某一位时，先将链队置为 NULL 的状态
    	}
    	// 分配：遍历原链表 p
    	while (p != NULL) {
            // 将字符转换成数字，k 即该元素 p 的关键字上的第 d 位，将该元素放入 Qk 中
    		k = p->digit[d] - '0';     
    		if (head[k] == NULL) {
    			head[k] = p; tail[k] = p;     // Qk 为空时
    		} else {
    			tail[k]->next = p; tail[k] = p;     // Qk 不为空时
    		}
    		p = p->next;     // 依次遍历原链表中的元素
    	}
    	p = NULL;
    	// 收集：遍历所有链队，重新用 p 收集所有结点
    	for (int i = 0; i < radix; ++i) {
    		// 若该队列非空，即放入了元素，将其连接到 p 上
    		if (head[i] != NULL) {
    			if (p == NULL) {
    				p = head[i]; t = tail[i];    // p 为空，即还没连上过链队
    			} else {
    				t->next = head[i]; t = tail[i];  // p 不为空，t 指向该链队开头，更新 t
    			}
    		}
    	}
    	t->next = NULL;     // 置 p 的最后一个结点的下一个结点为 NULL
    }
}

static void numToSequence(int num, char sequence[]) {
    for (int i = 0; i < MAXDigit; ++i) {
    	sequence[i] = (num % 10) + '0';     // 10 进制，高位用 0 补齐
    	num = num / 10;
    }
    sequence[MAXDigit] = '\0';
}

static int sequenceToNum(char sequence[]) {
    int /*length = 0, */num = 0;
    int i;
    while (*sequence++ != '\0') ++length;
    for (i = MAXDigit - 1; i >= 0; --i) {
        // 因为sequence中的字符是从低位到高位，且高位用 0 补齐，
		// 故从右向左找到第一个非零字符，即原数字的最高位
		if (sequence[i] != '0') break;     
	}
	while (i >= 0) {
		num = num * 10 + sequence[i--] - '0';
	}
    return num;
}
```

基数排序，适配算法

```c++
void RadixSort(RecType R[], int n) {
    if (n <= 0) return;
    _10_6_Base::NodeType* p = (_10_6_Base::NodeType*)malloc(sizeof(_10_6_Base::NodeType));    // 头结点
    _10_6_Base::numToSequence(R[0].key, p->digit);
    _10_6_Base::NodeType *r = p, *s;     // r 为尾指针
    for (int i = 1; i < n; ++i) {
        // 采用尾插法从数据序列生成链表
    	s = (_10_6_Base::NodeType*)malloc(sizeof(_10_6_Base::NodeType));     
    	_10_6_Base::numToSequence(R[i].key, s->digit);
    	r->next = s; r = s;
    }
    r->next = NULL;
    _10_6_Base::RadixSort_base(p, 10, _10_6_Base::MAXDigit);     // 排序
    for (int i = 0; i < n && p != NULL; ++i) {
    	R[i].key = _10_6_Base::sequenceToNum(p->digit);     // 从单链表中取出数据
    	s = p;
    	p = p->next;
    	free(s);
    }
}
```

在基数排序的过程中共进行了 digit 趟的分配和收集，每一趟中分配过程需要扫描所有结点，而收集过程时按队列进行的，所以一趟的执行时间为 O(n+radix)；因此基数排序的时间复杂度为 O(digit*(n+radix))，其中 digit 和 radix 为常量时，时间复杂度为 O(n)；在基数排序中需要辅助空间为 radix（创建radix个队列），辅助空间复杂度为 O(radix)

另外，元素的相对位置不会发生改变，该算法是一种稳定的排序方法

## （七）各种内排序方法的比较和选择

通常按平均时间将排序方法分为下面3种：

1. 平方阶排序：O(n^2)，一般称为简单排序方法，例如直接插入排序、简单选择排序和冒泡排序
2. 线性对数阶排序：O(n*log2(n))，如快速排序、堆排序和归并排序
3. 线性阶排序：O(n)，如基数排序（假定数据的位数digit和进制radix为常量时）

|   排序方法   | 时间复杂度平均情况 |   最坏情况   |   最好情况   | 空间复杂度 | 稳定性 | 复杂性 |
| :----------: | :----------------: | :----------: | :----------: | :--------: | :----: | :----: |
| 直接插入排序 |       O(n^2)       |    O(n^2)    |     O(n)     |    O(1)    |  稳定  |  简单  |
| 折半插入排序 |       O(n^2)       |    O(n^2)    |     O(n)     |    O(1)    |  稳定  |  简单  |
|   希尔排序   |      O(n^1.3)      |              |              |    O(1)    | 不稳定 | 较复杂 |
|   冒泡排序   |       O(n^2)       |    O(n^2)    |     O(n)     |    O(1)    |  稳定  |  简单  |
|   快速排序   |    O(n*log2(n))    |    O(n^2)    | O(n*log2(n)  | O(log2(n)) | 不稳定 | 较复杂 |
| 简单选择排序 |       O(n^2)       |    O(n^2)    |    O(n^2)    |    O(1)    | 不稳定 |  简单  |
|    堆排序    |    O(n*log2(n))    | O(n*log2(n)) | O(n*log2(n)) |    O(1)    | 不稳定 | 较复杂 |
| 二路归并排序 |    O(n*log2(n))    | O(n*log2(n)) | O(n*log2(n)) |    O(n)    |  稳定  | 较复杂 |
|   基数排序   |     O(d(n+r))      |  O(d(n+r))   |  O(d(n+r))   |    O(r)    |  稳定  | 较复杂 |

正是因为不同的排序方法适应不同的应用环境和要求，所以选择适当的排序方法应该综合考虑下列因素：

1. 待排序的元素数目 n（问题规模）
2. 元素的大小（每个元素的规模)
3. 关键字的结构及其初始状态
4. 对稳定性的要求
5. 语言工具的条件
6. 数据的存储结构
7. 时间和空间复杂度

没有哪一种排序方法时绝对好的，每一种排序方法都有其优点，适合于不同的环境，因此在实际应用中应根据具体情况做选择；首先考虑排序对稳定性的要求，若要求稳定，则只能在稳定方法中选取，否则可以在所有方法中选取；其次要考虑待排序元素个数n的大小，若n较大，则可在改进方法中选取，否则在简单方法中选取；然后再考虑其他因素

下面给出综合考虑了以上几个方面所得出的大致结论：

1. 若 n 较小（如n≤50)，可采用直接插入或简单选择排序。一般地，这两种排序方法中，直接插入排序较好，但简单选择排序移动的元素数少于直接插入排序
2. 若文件初始状态基本有序（指正序），则选用直接插入或冒泡排序为宜
3. 若n较大，应采用时间复杂度为 O(n\*log2n) 的排序方法，例如快速排序、堆排序或二路归并排序；快速排序是目前基于比较的内排序中被认为是较好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最少；但堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况；这两种排序都是不稳定的，若要求排序稳定，则可选用二路归并排序
4. 若需要将两个有序表合并成一个新的有序表，最好用二路归并排序方法
5. 基数排序可能在O(n)时间内完成对n个元素的排序；但遗憾的是，基数排序只适用于像字符串和整数这类有明显结构特征的关键字，而当关键字的取值范围属于某个无穷集合（例如实数型关键字）时无法使用基数排序；这时只有借助于“比较”的方法来排序，由此可知，若n很大，元素的关键字位数较少且可以分解时采用基数排序较好


# 十一、外排序（external sort）

## （一）外排序概述

文件存储在外存上，因此外排序方法与各种外存设备的特征有关，外存设备大体上可分为两类；一类是顺序存取设备，例如磁带（tape）；另一类是直接存取设备，例如磁盘（disk）

对于磁盘来说，一般有读写头、主轴、盘面、柱面、磁带等物理和逻辑结构组成；一般情况下，把一次向磁盘写入或读出的数据称为一个物理块，一个物理块通常由若干记录组成

外排序的基本方法是归并排序法，它分为以下两个步骤

1. 生成若干初始归并段（顺串，runs）：将一个文件（含待排序数据）中的数据分段读入内存，在内存中对其进行内排序，并将经过排序的数据段（有序段）写到多个外存文件上
2. 多路归并：对这些初始归并段进行多遍归并，使得有序的归并段逐渐扩大，最后在外存上形成整个文件的单一归并段，也就完成了这个文件的外排序

从中可以看出，外排序的时间主要花费在内、外存数据的交换（对应存取时间）和内排序上

## （二）磁盘排序（disk sort）

### 1. 磁盘排序概述

由于是直接存取设备，读写一个数据块的时间与当前读写头所处的位置关系不大，所以可以通过读写数据块的次数来衡量存取时间

对磁盘中的文件 Fin 进行排序，通过算法将 Fin 文件中的记录一部分一部分地调入内存处理，产生若干个文件 F1，...，Fn，它们都是有序的，称为顺串（runs）；然后再次将 F1，...，Fn 文件中的记录调入内存，通过相关的归并算法（几路归并则同时从几个文件的开头处理）产生一个有序文件 Fout，从而达到数据排序的目的

不同于内排序，磁盘排序中元素移动的次数相对于记录读写次数和关键字比较次数可以忽略，所以一般不考虑元素移动的时间开销；因此可以大致认为，磁盘排序时间 = 读写记录次数 + 关键字比较次数

### 2. 生成初始归并段

一般情况下，初始归并段的个数越多，多路归并的性能越差，这里介绍一种 置换-选择排序（replacement selection sorting）算法，从而减少初始归并段的个数，如下：

1. 从待排序文件中 Fin 中按内存工作区 WA 的容量（设为 w）读入 w 个记录，设归并段编号 i = 1
2. 从 WA 中选出关键字最小的记录 Rmin
3. 将 Rmin 记录输出到文件 Fi 中，作为当前归并段的一个记录
4. 若 Fin 不为空，则从 Fin 中读入下一个记录到 WA 中替代刚输出的记录
5. 在 WA 工作区中所有大于等于 Rmin 的记录中选择最小的记录作为新的 Rmin，转(3)，直到选不出这样的Rmin
6. 置 i = i + 1，开始一个新的归并段
7. 若 WA 工作区不为空，转(2)，否则 WA 工作区为空，初始归并段已全部产生，算法结束

显然，置换-选择排序算法生成的初始归并段的长度既与内存工作区WA的大小有关，也与输入文件中记录的排序次序有关；可以证明，如果输入文件中的记录按关键字随机排列，所得到的初始归并段的平均长度为内存工作区大小的两倍

在置换-选择排序算法中，内存工作区WA内频繁的操作是，从w个记录中选择一个关键字最小的记录，如果采用基于简单选择的排序方法，每次操作需要w-1次比较

若输入文件有n个记录，则算法的时间复杂度为O(nw)，实际上这种频繁的操作可以采用败者树来实现，从w个记录中选择一个关键字最小的记录的时间为O(log2w)；从而使置换-选择排序算法的时间复杂度降低为 O(n*log2w)

### 3. 多路平衡归并

#### (1) k 路平衡归并的效率分析

所谓二路平衡归并（2-way balanced merge）就是每一趟从 m 个归并段得到 ⌈m/2⌉ 个归并段，这样归并树就有 ⌈log2m⌉ + 1 层（根上归并完的那个结点单独占一层），需要对初始数据进行 ⌈log2m⌉ 遍扫描；做类似的推广，当采用 k 路平衡归并时，相应的归并树有 ⌈logk(m)⌉ + 1 层，要对数据进行 s = ⌈logk(m)⌉ 遍扫描，显然 k 越大，磁盘的读写次数越少

在进行 k 路归并时，在 k 个记录中选择最小者，如果采用基于简单比较的的排序方法，需要进行 k-1 次比较，每趟归并 u 个记录需要做 (u-1)\*(k-1) 次关键字比较，则 s 趟归并总共需要的关键字比较次数为 s\*(u-1)\*(k-1) = ⌈logk(m)⌉\*(u-1)\*(k-1) = ⌈log2m⌉\*(u-1)\*(k-1)/⌈log2k⌉

从中可以看出，在初始归并段个数 m 与记录个数 u 确定时，其中的前两项是常量，而 (k-1)/⌈log2k⌉ 随着 k 的增大而增大；因此，若 m 与 u 确定，在选择几路归并方案时，尽管增大归并路数 k 会减少磁盘读写次数，但 k 增大会增加关键字比较次数

当 k 增大到一定程度，就会抵消由于减少磁盘读写次数所赢得的时间；也就是说，在 k 路平衡归并中，如果采用基于简单选择排序方法，其效率并非 k 越大，归并的效率就越好

#### (2) 利用败者树的 k 路平衡归并

利用败者树实现 k 路平衡归并的过程是先建立败者树，然后对 k 个输入有序段进行 k 路平衡归并。败者树（tree of loser）是一棵有 k 个叶子结点的完全二叉树（可将大根堆看成胜者树），其中叶子结点存储参与归并的记录，分支结点存放关键字对应的段号

所谓败者是两个记录比较时关键字较大者，胜者是两个记录比较时关键字较小者；建立败者树是采用类似于堆调整的方法实现的，初始时令所有的分支结点指向一个含最小关键字（MINKEY）的叶子结点，然后从各叶子结点出发调整分支结点为新的败者即可

对 k 个有序段进行 k 路平衡归并的方法如下：

1. 取每个输入有序段的第一个记录作为败者树的叶子结点，建立初始败者树：两两叶子结点进行比较，在双亲结点中存放比较的败者（关键字较大者），而让胜者去参加更高一层的比赛，如此在根结点之上胜出的“冠军”是关键字最小者
2. 将胜出的记录写至输出归并段，在对应的叶子结点处补充其输入有序段的下一个记录，若该有序段变空，则补充一个大关键字（比所有记录关键字都大，设为k(max)）的虚记录
3. 调整败者树，选择新的关键字最小的记录：从补充的记录的叶子结点向上和双亲结点的关键字比较，败者留在该双亲结点，胜者继续向上，直到树的根结点，最后将胜者放在根结点的双亲结点中
4. 若胜出的记录关键字等于 k(max)，则归并结束；否则转 (2) 继续

说明：在上一小节的置换-选择排序的算法中第(2)步从WA中选出关键字最小的记录时也可以使用败者树方法以提高算法效率；显然，k 路平衡归并的高度为 ⌈log2k⌉ + 1，在每次调整找下一个具有最小关键字的记录时仅需要做 ⌈log2k⌉次关键字比较

因此，若初始归并段为 m 个，利用败者树在 k 个记录中选择最小者只需要进行 ⌈log2k⌉ 次关键字比较，则 s =  ⌈logk(m)⌉  趟归并总共需要关键字比较次数为：

s \* (u-1) \* ⌈log2k⌉ = ⌈logk(m)⌉ \* (u-1) \* ⌈log2k⌉ = ⌈log2m⌉ \* (u-1)

关键字比较次数与 k 无关，总的内部归并时间并不会随 k 的增大而增大；且 k 越大，归并树的高度越小，读写磁盘的次数也较少；因此，当采用败者树实现多路平衡归并时，只要内存空间允许，增大归并路数 k 会有效地减少归并树的高度，从而减少读写磁盘次数，提高外排序的速度

### 4. 最佳归并树

由于采用置换-选择排序算法生成的初始归并段长度不等，在进行逐趟 k 路归并时对归并段的组合不同，会导致归并过程中读写记录的次数不同；按照最佳归并树的设计可以使归并过程中对外存的读写次数最少

归并树是描述归并过程的 k 次树，因为每一次做 k 路归并对需要有 k 个归并段参加，因此归并树是只包含度为 0 和度为 k 的结点的标准 k 次树；各叶子结点代表参加归并的各初始段，叶子结点上的权值为该初始段中的记录个数，根结点代表最终生成的归并段；叶子结点到根结点的路径长度表示在归并过程中的读记录次数，各非叶子结点代表归并出来的新归并段；则归并树的带权路径长度 WPL 即为归并过程中的总读记录数，因此在归并过程中的读写记录次数为 2 * WPL

为了使总的读写次数达到最少，需要改变归并方案，重新组织归并树，使其路径长度 WPL 尽可能小，所有归并树中最小带权路径长度WPL的归并树成为最佳归并树（optimal merge tree）；为此，可将哈夫曼树的思想扩充到 k 次树的情形：在归并树中，让记录个少的初始段先归并，记录个数多的初始段最晚归并

为了使归并树成为一棵标准 k 次树，可能需要补入虚段（dummy run，记录个数为 0 的归并段），设参加归并的初始段有 m 个，做 k 路平衡归并

因为归并树是只有度为 0 和度为 k 的结点的正则 k 次树，显然度为 0 的结点有 m 个（因为初始归并段有 m 个，对应归并树的度为零的叶子结点就有 m 个）；度为 k 的结点有 mk 个，则有 m = mk * k + 1 - mk = (k-1) * mk + 1（叶子结点数 = 所有结点 - 非叶子结点数）

因此，可以得出 mk = (m-1) / (k-1)，设 u = (m-1) % (k-1)

- 若 u == 0，则说明这 m 个叶子结点正好可以构造 k 次归并树，不需要加虚段，此时分支结点有 mk 个
- 若 u != 0，则需要补入 t 个虚段，使得剩下的 u 个初始归并段加上 t 个虚段能正好被 (k-1) 除尽，此时分支结点有 mk + 1 个

综上所述，分支结点个数 mk = ⌈(m-1) / (k-1)⌉

因此，最佳归并树是带权路径长度最短的 k 次（阶）哈夫曼树，其构造步骤如下：

1. 若 (m-1) % (k-1) != 0，则需要附加 (k-1) - ((m-1) % (k-1)) 个长度为 0 的虚段，以使每次归并都可以对应 k 个段
2. 按照哈夫曼树的构造原则（权值越小的结点离根结点越远）构造最佳归并树

## （三）磁带排序（tape sort）

### 1. 多路平衡归并排序

磁带的多路平衡归并排序过程与磁盘的多路平衡归并排序过程基本上相同；磁带排序（tape sort）和磁盘排序的主要区别在于磁带排序需要充分考虑归并段的分布状况，因为磁带是顺序存取的，所以各归并段在不同磁带和同一磁带的不同位置对排序效率影响极大

对磁带排序来说，多路归并需要多台磁带，为了避免过多的磁带寻找时间，要归并的归并段需要放在不同的磁带上，因此，k 路归并至少需要 k+1 台磁带，其中 k 台作为输入带，另一台为归并后输出之用

但是这样需要对输出带再做一遍扫描，把输出带上的各归并段重新分配到 k 台磁带上，以便作为下一级归并使用，若使用 2k 台磁带，则可避免这种再分配扫描，把 k 台作为输入带，其余 k 台作为输出带，在下一级归并时输入带与输出带的作用互相对换

### 2. 多阶段归并排序

所谓的多阶段归并排序实际上是多路非平衡排序，即各条带上的归并段不再保持平衡分布，它在 k 路归并中仅使用 k+1 条磁带就可以避免在多路平衡归并排序算法中遇到的重新分布有序段的问题

开始时，初始归并段不平衡地分配在前 k 条磁带上，第 k+1 条磁带作为输出带，初始为空；

第一步归并只是部分记录参加，归并段最少的带在本步归并完成后便成为空带，作为下一次归并的输出带，这样，k+1 条磁带将轮流成为输出带，直到整个文件为一个排序文件为止

为了使归并的趟数达到最小，必须合理地分配各磁带上初始归并段的段数，通过分析可得出以下结论：归并段的总数以及在各带上分布情况与 k 阶 Fibonacci（斐波那契）序列有关

设 Fk(i) 为 k 阶 Fibonacci 序列中的第 i 项，利用 k+1 台磁带机做 k 路多阶段归并时，若初始段归并的总数为：T = k * Fk(i) + (k-1) * Fk(i-1) + ... + 2 * Fk(i-(k-2)) + Fk(i-(k-1)) = ∑(j=0->k-1){ (k-j) * Fk(i-j) }

则需要进行 i-k+2 个归并段的归并，初始归并段在各带上分布的段数应为：Tt = ∑(j=0->k-t){ Fk(i-j) }；其中，Tt 表示第 t 条磁带上的归并段的段数，其中（1<= t <= k）

其中，k 阶Fibonacci 数列可用下面的递推公式导出（第 i 项，从 0 开始）：

- Fk(i) = 0，i <= k-2，前 k-1 项
- Fk(i) = 1，i == k-1，第 k 项
- Fk(i) = Fk(i-1) + Fk(i-2) + ... + Fk(i-k)，i >= k，从第 k+1 项及之后

综上所述，k 阶 Fibonacci 序列为：前 k-1 项为 0，第 k 项为 1，从第 k+1 项开始每项等于前 k 项之和；当 k 取 2 时，其退化为普通的斐波那契数列

# 十二、文件（file）

## （一）文件的基本概念

### 1. 什么是文件

文件（file）是性质相同的记录的集合，文件的数据量通常很大，它被放置在外存上，数据结构中所讨论的文件主要是数据库意义上的文件，而不是操作系统意义上的文件，操作系统中研究的文件是一维的无结构连续字符的序列；数据库中所研究的文件是带有结构的记录集合，每个记录可由若干数据项构成

记录是文件中存取的基本单位，数据项是文件可使用的最小单位，数据项有时也称为字段；其值能唯一标识一个记录的数据项或数据项的组合称为主关键字（primary key），其他不能唯一标识一个记录的数据则称为次关键字（secondary key）

文件可以按照记录中关键字的多少分成单关键字文件和多关键字文件，文件又可以分为定长文件和不定长文件，若文件中记录含有的信息长度相同，则称这类记录为定长记录，由定长记录组成的文件成为定长文件；若记录含有的信息长度不同，称为不定长文件

和其他数据结构一样，文件结构也包括逻辑结构、存储结构以及在文件上的各种操作（运算）这三个方面，文件的操作是定义在逻辑结构上的，但操作的具体实现要在存储结构上进行

### 2. 文件的逻辑结构及操作

文件中各记录之间存在着逻辑关系，当一个文件的各个记录按照某种次序排列起来时（可以根据关键字大小，也可以根据各个记录存入该文件的时间先后等），各记录之间就自然的形成了一种线性关系，在这种次序下，每个记录最多只有一个前驱和一个后继（开始记录和终止记录分别没有前驱和后继），因此文件可看成是一种线性结构

文件上的操作主要有两类：检索和维护

文件检索就是在文件中查找满足给定条件的记录，它既可以按记录的逻辑号（即记录保存入文件时的顺序编号），也可以按关键字查找

文件维护主要是指对文件进行记录的插入、删除及修改等更新操作，此外为了提高文件的效率，还要进行再组织操作、文件被破坏后的恢复操作，以及文件中数据的安全保护等

### 3. 文件的存储结构

文件的存储结构是指文件在外存上的组织方式，采用不同的组织方式就得到了不同的存储结构，基本的组织方式有四种：顺序组织、索引组织、哈希组织和链式组织

文件组织的方式往往是这四种基本方式的结合，选择哪一种文件组织方式取决于对文件中记录的使用方式和频繁程度、存取要求、外存的性质和容量等

## （二）顺序文件（sequential file）

顺序文件是指按记录进入文件的先后顺序在放、其逻辑顺序跟物理顺序一致的文件，若顺序文件中的记录按其主关键字有序，则称此顺序文件为顺序有序文件，否则称为顺序无序文件，为了提高检索效率，经常将顺序文件组织成有序文件

一切存储在顺序存取存储器（如磁带）上的文件都只能是顺序文件；顺序文件只能按顺序查找法存取，即顺序扫描文件，按记录的主关键字逐个查找，如果要检索第 i 个记录，必须检索前 i-1个记录；这种查找法对于少量的检索是不经济的，但适合于批量检索，即把用户的检索要求先进行积累，一旦待查记录聚集到一定数量之后，便把这批记录按主关键字排序，然后通过一次顺序扫描文件来完成这一批检索要求

存储在直接存取存储器（如磁盘）上的顺序文件可以用顺序查找法存取，也可以用分块查找法或二分查找法进行存取；分块查找法在查找时不必扫描整个文件中的记录，先通过关键字找到相应的块，再扫描这个块即可；二分查找法只能对较小的文件或一个文件的索引进行查找，当文件很大，在磁盘上占有多个柱面时，二分查找将引起磁头来回移动，增加寻查时间

顺序文件不能按顺序表那样的方法进行插入、删除和修改（若修改主关键字，则相当于先做删除后做插入），因为文件中的记录不能像向量空间的数据那样“移动”，而只能通过复制整个文件的方法实现上述更新操作，这就是为什么数据库系统总会产生很多临时文件的原因

顺序文件的主要优点是连续存取的速度较快，即若文件中第 i 个记录刚被存取过，而下一个要存取的是第 i+1 个记录，则这种存取将会很快完成；当顺序文件存放在单一存储设备（如磁带）上时，这个优点总是可以保持的；而当它是存放在多路存储设备（如磁盘）上时，在多道程序的情况下，由于其他用户可能驱使磁头移向其他柱面，就会降低这一优点；因此，顺序文件多用于磁带

## （三）索引文件（indexed file）

在用索引的方法组织文件时通常是在文件本身（称为主文件）之外另外建立一张表，它指明逻辑记录和物理记录之间的一一对应关系，这张表就称为索引表（index table），它和主文件一起构成的文件称为索引文件（indexed file）

索引表中的每一项称为索引项（index item），一般索引项都是由主关键字和该关键字所在记录的物理地址组成的；显然，索引表必须按主关键字有序，而主文件本身则可以按主关键字有序或无序，如果主文件有序称为索引顺序文件（indexed sequential file），如果主文件无序称为索引非顺序文件（indexed non-sequential file)

对于索引非顺序文件，由于主文件中的记录是无序的，则必须为每个记录建立一个索引项，这样建立的索引表称为稠密索引；对于索引顺序文件，由于主文件中的记录按关键字有序，则可对一组记录建立一个索引项，例如让文件中的每个物理块对应一个索引项，这种索引表称为稀疏索引；通常将索引非顺序文件简称为索引文件，本节只讨论这种文件

索引文件在存储器上分为两个区，即索引区和数据区，前者存放索引表，后者存放主文件；在建立文件的过程中按输入记录的先后次序建立数据区和索引表，这样的索引表其关键字是无序的；待全部记录输入完毕后再对索引表进行排序，排序后的索引表和主文件一起就形成了索引文件

检索分两步进行，首先将外存上含有索引区的物理块送入内存，查找所需记录的物理地址，然后再将含有该记录的物理块送人内存；若索引表不大，则可将索引表一次读入内存，因此在索引文件中进行检索只需两次访问外存，即一次读索引、一次读记录；由于索引表是有序的，所以对索引表的查找可用顺序查找或二分查找等方法

索引文件的更新操作也很简单，在插入时将插入记录置于数据区的末尾，并在索引表中插入索引项；在删除时删去相应的索引项；若要修改键字，则必须同时修改索引表

当记录数目很大时，索引表也很大，以至于一个物理块容纳不下，在这种情况下查阅索引仍要多次访问外存，为此可以对索引表建立一个索引，称为查找表；上节介绍的索引非顺序文件适合于随机存取，这是由于主文件是无序的，顺序存取将会频繁地引起磁头移动，因此索引非顺序文件不适合于顺序存取

而索引顺序文件的主文件也是有序的，所以它既适合于随机存取，也适合于顺序存取；另外，索引顺序文件由于主文件是按主关键字有序的，因此索引表采取稀疏索引，占用的空间较少，它是常用的一种文件组织结构，此处将介绍两种最常用的索引顺序文件，即 ISAM 文件和 VSAM 文件

### 1. ISAM 文件

ISAM（索引顺序存取方法，indexed sequential access method）文件是一种采用静态索引结构的磁盘存取文件，由于磁盘是盘组、柱面和磁道的三级地址存储设备，因此对磁盘上的数据文件建立盘组、柱面和磁道多级索引；ISAM文件由以下3个部分组成：

1. 基本数据区，由一个或多个柱面组成，文件的记录按关键字有序存放于柱面的每个磁道上
2. 溢出区，每个柱面都开一个溢出区，为插入记录而设，当一个磁道存满记录以后，如果要在该磁道插入记录，就将该磁道的最后一个记录移至溢出区，再将新记录插在此磁道的适当位置，每个磁道的溢出数据在溢出区中组成链表
3. 多级素引，多级索引都采用稀疏索引，各级索引的结构如下：
1.  磁道索引，其包括基本索引项和溢出索引项，基本索引项含本磁道的最大关键字及起始地址；溢出索引项含本磁道溢出记录的最大关键字及本磁道溢出区首地址
2. 柱面索引，索引项包含柱面中的最大关键字和该柱面磁道索引的起始地址
3. 主索引，主索引是柱面索引的索引，每个索引项包含柱面索引中一组记录的最大关键字及该面索引组的起始地址

检索时由高级索引到低级索引逐级查找，找到待查记录所在的磁道后再到此磁道中查找待查记录

因柱面基本区中的主文件按关键字有序，因此可对每个磁道上的记录建立一个磁道索引项，一个柱面上的所有磁道索引项形成一个磁道索引，然后对每个磁道索引块（即同属一个柱面的磁道索引块）建立一个柱面索引项，盘组上对应主文件的所有柱面索引项形成柱面索引；若柱面索引较大，再建立称为主索引的柱面索引的索引；若文件的柱面索引很大，使得一级主引也很大时，主索引可建立多级；当然，若柱面索引较小，也可不建主索引，以减小索引高度

每个柱面分为磁道索引区、基本区和溢出区三个部分；磁道索引区用来存放该柱面的磁道索引，通常规定该柱面最前面的磁道 T0 为磁道索引区，由 T1 开始的若干个磁道用来存放主文件的记录，称为基本区；每个柱面最后若干个磁道称为溢出区，每个柱面的溢出区由该柱面基本区中的各个磁道共享，溢出区为有序链表结构，简称溢出链表

每个磁道索引项有4项，即基本索引项关键字、基本索引项指针、溢出索引项关键字和溢出索引项指针；其中基本索引项关键字为对应磁道在基本区中最末一个记录的关键字（即该磁道的最大关键字），基本索引项指针指示该磁道中第一个记录在基本区中的位置；溢出索引项关键字为对应溢出链表的最大关键字，溢出索引项指针为对应溢出链表的头指针

每个柱面索引项有两项，即关键字和指针，关键字为对应柱面（即对应磁道索引块）中最后一个记录的关键字（即该柱面的最大关键字），指针指示对应柱面上的磁道索引首地址；如前所述，磁道索引放在对应柱面的第一个磁道，即指针指示对应柱面第一个磁道中磁道索引的起始地址

在数据文件初始建立时，磁道索引的溢出索引项均为空，各个柱面溢出区也均为空；当有新的记录插入时需要重组某个磁道的记录，并将该磁道最后一个记录移入该柱面的溢出链表中，同时修改对应磁道索引的基本索引项和溢出索引项内容

在ISAM文件中删除记录的操作比较简单，只要找到待删除的记录，在其存储位置上加一个删除标志即可，而不需要移动记录和修改索引；记录检索有成功和失败两种情况，在ISAM文件中记录检索成功时的检索路径有下面两种：

1. 若被检索记录在某柱面的基本区中，则检索路径为：主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面基本区中某磁道有序表的顺序扫描
2. 若被检索记录在某柱面的溢出区中，则检索路径为：主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面有序溢出链表的顺序扫描

在ISAM文件中记录检索失败时的检索路径也有两种：

1. 主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面基本区中某磁道有序表的顺序扫描 -> 检索失败
2. 主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面有序溢出链表的顺序扫描 -> 检索失败

在ISAM文件中经过多次记录增别后文件的结构可能变得很不合理，此时大量的记录进入溢出区，而基本区中又浪费了很多的空间；因此通常需要周期性地整理ISAM文件，把记录读入内存重新排列，复制成一个新的ISAM文件，填满基本区而空出溢出区

### 2. VSAM 文件

VSAM（虚拟存储存取方法，virtual storage access method）文件是一种采用虚拟存储存取方法的文件，VSAM文件的存储单位是控制区间和控制区域，这是一些逻辑存储单位，与柱面、磁道等实际存储单位并没有必然的联系

用户在存取VSAM文件的记录时不需要考虑该记录的当前位置是在内存还是在外存，也不需要考虑何时执行对外存进行读写的命令，可见，这种文件较ISAM文件更方便用户使用

就文件的组织方式来说，VSAM文件和ISAM文件的相同点是都是索引顺序文件组织方式，其不同点是ISAM文件采用静态索引结构，而VSAM采用 B+树 的动态索引结构

一个VSAM文件的例子，它由数据集、顺序集和索引集3个部分组成

1. 数据集：一个结点称为一个控制区间，它是 I/O 操作的一个基本单位，文件的记录存放于数据集中，一个控制区间除存放一个或多个记录以外，还包含有记录的控制信息和区间的控制信息，且每个控制区间留有空间，为插入记录时备用
2. 顺序集：存放每个控制区间的索引项，一个索引项包含该控制区间的最大关键字和指向区间的指针，若干个控制区间的索引项组成顺序集中的一个结点，结点之间用指针链接，使整个顺序集形成一个链表，顺序集中一个结点和与之对应的控制区间组成一个控制区域
3. 索引集：每个顺序集的结点又在其上一层的结点中建立索引，且逐层向上建立索引，每个索引项都是由下层若干个结点的最大关键字和指向这些结点的指针组成

这些层的索引组成了索引集，它们是 B+ 树的非终端结点，与顺序集共同构成一棵 B+ 树，作为文件的索引部分

VSAM文件的记录均存放在数据集中（其中的一个结点就是一个控制区间）, 每个控制区间存放有若干个按关键字有序排列的记录，控制区间的大小可随文件的不同而不同，但同一文件中控制区间的大小相同；顺序集和索引集一起构成一棵 B+ 树，为有序记录的索引，顺序集和索引集中的所有索引项都由关键字和指针两部分组成；每个控制区间在顺序集中都有一个索引项，其关键字为控制区间中记录的最大关键字，其指针为该控制区间的首地址，顺序集中的一个结点和对应的若干个控制区间组成的部分称为控制区域；每个控制区间可看作一个逻辑磁道，每个控制区域可看作一个逻辑柱面，而控制区间相当于一个磁道

与ISAM文件不同的是，VSAM文件不设溢出区，解决记录插入的方法是在文件初始建立时留下一定的空间，预留空间使用两种方法，一种方法是每个控制区间初建时不填满记录；另一种方法是在每个控制区域中留有一些全空的控制区间

在VSAM文件中记录插入有4种情况：

1. 新记录能直接插入到相应的控制区间中，但需要修改顺序集中的索引项
2. 新记录插入的控制区间未满，但需把其中关键字大于插入记录关键字的记录后移
3. 新记录要插入的控制区间中记录已满，此时要进行控制区间的分裂，即将近一半记录移到同一控制区域中全空的控制区间中，并修改顺序集中相应的索引
4. 新记录要插入的控制区域中已没有全空的控制区间，要进行控制区域的分裂，此时顺序集中的结点也要分裂

记录的删除过程与插入过程相反，当要删除记录时先查找到该记录，然后将该记录右面的记录顺次左移以使空闲空间连续，同时删除相应的控制信息，若删除后该控制区间不再含有记录，则回收做空闲空间使用，同时删除顺序集中相应的索引项

与ISAM文件相比，VSAM文件具有以下优点：1.动态地分配和释放存储空间；2.不需要对文件进行重组；3.插入新记录后对新记录的查找时间和对原有记录的查找时间相同

基于 B+ 树的VSAM文件通常作为大型索引顺序文件的标准组织方式

## （四）哈希文件（hashed file）

哈希文件也称为散列文件，是利用哈希存储方式组织的文件，也称为直接存取文件；它类似于哈希表，即根据文件中关键字的特点设计一个哈希函数和处理冲突的方法，将记录哈希到存储设备上

与哈希表不同的是，对于文件来说，磁盘上的文件记录通常是成组存放的，若干个记录组成一个存储单位，在哈希文件中这个存储单位叫桶（bucket)，假如一个桶能存放 m 个记录，则当桶中已有 m 个同义词的记录时存放第 m+1 个同义词会发生“溢出”；处理溢出虽然可采用哈希表中处理冲突的各种方法，但对哈希文件而言主要采用链地址法

当发生“溢出”时，需要将第 m+1 个同义词存放到另一个桶中，通常称此桶为“溢出桶”，相应的，称前m个同义词存放的桶为“基桶”，溢出桶和基桶大小相同，相互之间用指针链接；当在基桶中没有找到待查记录时就沿着指针到所指溢出桶中进行查找，因此希望同一哈希地址的溢出桶和基桶在磁盘上的物理位置不要相距太远，最好在同一柱面上

在哈希文件中进行查找时首先根据给定值求出哈希桶的地址，将基桶的记录读入内存，进行顺序查找，若找到关键字等于给定值的记录，则检索成功；否则，读入溢出桶的记录继续进行查找

在哈希文件中删去一个记录仅需对被删记录做删除标记即可

哈希文件的优点是文件随机存放，记录不需进行排序；插入、删除方便；存取速度快；不需要索引区，节省存储空间；其缺点是不能进行顺序存取，只能按关键字随机存取，且询问方式限于简单询问，并且在经过多次插入、删除后也可能造成文件结构不合理，需要重新组织文件

## （五）多关键字文件（multiple key file）

以上各节介绍的都是只含一个主关键字的文件，为了提高查找效率，还需要对被查询的次关键字建立相应的索引，这种包含有多个次关键字索引的文件称为多关键字文件；次关键字索引本身可以是顺序表，也可以是树表，下面讨论两种多关键字文件的组织方法

### 1. 多重表文件（multilist file）

多重表文件是将索引方法和链接方法相结合的一种组织方式，它对每个需要查询的次关键字建立一个索引，同时将具有相同次关键字的记录链接成一个链表，并将此链表的头指针、链表长度及次关键字作为索引表的一个索引项

通常，多重表文件的主文件是一个顺序文件；多重表文件在检索时同样先查询索引表，然后在主文件中读出待查记录信息；插入时如果不要求保持链表的某种次序，则可将新记录插在链表的头指针之后；删除记录时比较烦琐，需要在每个次关键字的链表中删去该记录

### 2. 倒排文件（inverted file）

倒排文件和多重表文件的区别在于具有相同次关键字的记录不进行接，而是在相应的次关键字索引表的该索引项中直接列出这些记录的物理地址或记录号；这样的索引表称为倒排表，由主文件和倒排表共同组成倒排文件

倒排文件的主要优点是检索记录较快，在处理复杂的多关键字查询时可在倒排表中确定记录是哪个或哪些，继而直接读取之；倒排文件的缺点是维护困难，在同一个倒排表中不同关键字的记录数不同，各倒排表的长度也不等