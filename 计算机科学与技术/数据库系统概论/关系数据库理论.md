**Typist : Akame Qixisi / Excel Bloonow**

[toc]

------

# 一、概述

针对一个具体问题，应该如何构造一个适合于它的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等。这是数据库设计的问题，确切地讲是关系数据库逻辑设计问题。关系数据库的规范化理论是以关系模型为背景的，数据库逻辑设计的一个有力工具，且对于一般的数据库逻辑设计同样具有理论上的意义。

一个关系模式应当是一个五元组，`R(U,D,DOM,F)`，这里：

- R，关系名是符号化的元组语义。
- U，为一组属性。
- D，为属性组U中的属性所来自的域。
- DOM，为属性到域的映射。
- F，为属性组上的一组数据依赖。

由于D、DOM与模式设计关系不大，因此在此处把关系模式看作一个三元组`R<U,F>`，当且仅当U上的一个关系r满足F时，r称为关系模式R<U,F>的一个关系。

**数据依赖**是一个关系内部属性与属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。己经提出了许多种类型的数据依赖，其中最重要的是函数依赖（Functional Dependency，FD）和多值依赖（Multi-Valued Dependency，MVD）。

一个好的模式应当不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。

# 二、规范化

本节首先讨论一个关系属性间不同的依赖情况，讨论如何根据属性间依赖情况来判定关系是否具有某些不合适的性质，通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式等；然后直观地描述如何将具有不合适性质的关系转换为更合适的形式。

## （一）函数依赖

**定义**：设R(U)是属性集U上的关系模式，X，Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，即一个自变量X有且仅有一个函数值Y，则称X函数确定Y，或Y函数依赖于X，记作X→Y。

函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。

- $X\rightarrow Y$，$Y\not \subseteq X$，则称X→Y是**非平凡的函数依赖**。
- $X\rightarrow Y$，$Y\subseteq X$，则称X→Y是**平凡的函数依赖**。对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。
- 若$X\rightarrow Y$，则X称为这个函数依赖的决定属性组，也称为**决定因素**（determinant）。
- 若$X\rightarrow Y$，$Y\rightarrow X$，则记作$X\leftarrow \rightarrow Y$。
- 若Y不函数依赖于X，则记作$X\not \rightarrow Y$。

**定义**：在R(U)中，如果X→Y，并且对于X的任何一个真子集X'，都有$X'\not \rightarrow Y$，即若X是x维的，Y是X的x维函数，若X'维度减少，则X'无法唯一确定Y。称Y对X**完全函数依赖**，记作$X\stackrel{F}{\longrightarrow} Y$。

如果X→Y，但Y不完全函数依赖于X，即更低维度的X'可以唯一确定Y，则称Y对X**部分函数依赖**（patrial functional dependency），记作$X\stackrel{P}{\longrightarrow} Y$。

**定义**：在R(U)中，如果$X\rightarrow Y（Y\not \subseteq X）$，$Y\not \rightarrow X$，$Y\rightarrow Z（Z\not \subseteq Y）$，则称Z对X**传递函数依赖**（transitive functional dependency），记为$X\stackrel{传递}{\longrightarrow} Y$。

这里加上条件$Y\not \rightarrow X$，是因为如果$Y\rightarrow X$，则$X\leftarrow \rightarrow Y$，实际上是$X\stackrel{直接}{\longrightarrow} Y$，是直接函数依赖，而不是传递函数依赖。

## （二）码

若关系中的某一属性组的值能唯一标识一个元组，而其子集不能，则称该属性组为**候选码**（candidate key），如果一个关系有多个候选码，则选中其中一个作为**主码**（primary key）。在最简单的情况下，候选码中只包含一个属性；在最极端的情况下，关系模式中所有属性整体是这个关系模式的候选码，称为**全码**（all，key）。

候选码中的属性称为**主属性**（prime attribute），不包含在候选码中的属性称为**非主属性**（non-prime  attribute）或**非码属性**（non-key attribute）。

这里用函数依赖的概念来定义码。

**定义**：设K为R<U,F>中的属性或属性组合，若$K\stackrel{F}{\longrightarrow} U$，即整个元组U对K完全函数依赖，则称K为R的**候选码**。如果U部分函数依赖于K，即$K\stackrel{P}{\longrightarrow} U$，则称K为**超码**（Surpkey）。候选码是最小的超码，即候选码的任意一个真子集都不是候选码。若候选码多于一个，则选定其中的一个为**主码**。

在这里主码或候选码都简称为码，请注意根据上下文加以识别。在一些资料中，码也称为键或键码。

关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的**外部码**（foreign key），也称**外码**。主码与外码提供了一个表示关系间联系的手段。

## （三）范式（函数依赖范畴）

关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。满足最低要求的叫第一范式，简称1NF；在第一范式中满足进一步要求的为第二范式，其余以此类推。

关系R为第几范式就可以写成R∈xNF，各种范式之间的关系有$5NF\sub4NF\sub BCNF\sub3NF\sub2NF\sub1NF$成立。

一个低一级范式的关系模式通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。

**第一范式**（1NF）：每一个分量必须是不可分的数据项。它是作为一个二维表，关系要符合一个最基本的条件，满足了这个条件的关系模式就属于第一范式。

**第二范式**（2NF）：若R∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NF。**消除非主属性对码的部分函数依赖**。

一个关系模式R不属于2NF，就会产生插入异常、删除异常、修改复杂的问题。解决的办法是用投影分解把关系模式分解为多个满足2NF的关系。

**第三范式**（3NF）：设关系模式R<U,F>∈1NF，若R中不存在这样的码X、属性组Y、非主属性Z（$Y\not \subseteq Z$），使得$X\rightarrow Y$，$Y\not \rightarrow X$，$Y\rightarrow Z$成立，即不存在一个非主属性对码X部份依赖或传递依赖，则称R<U,F>属于3NF。**消除主属性对码的部分和传递函数依赖**。

可以证明如果R属于3NF，则必有R属于2NF。一个关系模式若不是3NF，就会产生与2NF相类似的问题，解决的办法同样是分解。

3NF的不彻底性表现在可能存在主属性对码的部份依赖和传递依赖。

**BCNF**（又称修正的第三范式或扩充的第三范式）：关系模式R<U,F>∈1NF，若$X\rightarrow Y$，$Y\not \subseteq X$时X必含有码，也就是说关系模式R中，**每一个决定因素都包含码**，则R<U,F>∈BCNF。一个满足BCNF的关系模式有：

- 所有非主属性对每一个码都是完全函数依赖。
- 所有主属性对每一个不包含它的码也是完全函数依赖。
- 没有任何属性完全函数依赖于非码的任何一组属性。

不是BCNF的关系模式，仍然存在不合适的地方，非BCNF关系模式可以通过分解成为BCNF。

若R∈BCNF，则R∈3NF；但若R∈3NF，未必R∈BCNF。

3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内它己实现了彻底的分离，己消除了插入和删除的异常。

## （四）多值依赖

**定义**：设R(U)是属性集U上的一个关系模式，X、Y、Z是U的子集，且其余属性组Z=U-X-Y，当且仅当对R(U)的任一关系r，给定一对(x,z)值，有一组Y值仅仅取决于x值而与z值无关，则称Y**多值依赖**于X，记为X→→Y。（一个X对应一组Y和一组Z，但Y和Z没关系）

若X→→Y，而Z=Φ（为空），即对于R(X,Y)如果有X→→Y成立，则称X→→Y为**平凡的多值依赖**。

多值依赖具有以下性质：

1. 对称性，即若X→→Y，则X→→Z，其中Z=U-X-Y。
2. 传递性，即若X→→Y，Y→→Z，则X→→Z-Y。
3. 函数依赖可以看作是多值依赖的特殊情况，即若X→Y，则X→→Y。这是因为当X→Y时，对X的每一个值x，Y有一个确定的值y与之对应，所以X→→Y。
4. 若X→→Y，X→→Z，则X→→YZ。
5. 若X→→Y，X→→Z，则X→→Y∩Z。
6. 若X→→Y，X→→Z，则X→→Y-Z，X→→Z-Y。

多值依赖与函数依赖相比，具有下面两个基本的区别：

1. 多值依赖的有效性与属性集的范围有关。若X→→Y在U上成立，则在$W(XY\sube W\sube U)$上一定成立；反之则不然，即X→→Y在$W(W\sub U)$上成立，在U上并不一定成立。这是因为多值依赖的定义中不仅涉及属性组X和Y，而且涉及U中其余属性Z。

一般地，在R(U)上若有X→→Y在$W(W\sub U)$上成立，则称X→→Y为R(U)的嵌入型多值依赖。

但是在关系模式R(U)中，函数依赖X→Y的有效性仅决定于X、Y这两个属性集的值。只要在R(U)的任何一个关系r中，元组在X和Y上的值满足定义，则函数依赖X→→Y在任何属性集$W(XY\sube W\sube U)$上成立。

若函数依赖X→→Y在R(U)上成立，则对于任何$Y'\sub Y$均有X→Y'成立。而多值依赖X→→Y若在R(U)上成立，却不能断言对于任何$Y'\sub Y$有X→→Y'成立。

## （五）范式（多值依赖）

**第四范式**（4NF）：设关系模式R<U,F>∈1NF，如果对于R的每个非平凡的多值依赖$X\rightarrow\rightarrow Y(Y\not \sube X)$，X都含有码，则称R<U,F>∈4NF。**消除非平凡且非函数依赖的多值依赖**。

4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。因为根据定义，对于每一个非平凡的多值依赖X→→Y，X都含有候选码，于是就有X→Y，所以4NF所允许的非平凡的多值依赖实际上是函数依赖。显然，如果一个关系模式是4NF，则必为BCNF。

一个关系模式如果己达到了BCNF但不是4NF，这样的关系模式仍然具有不好的性质，如数据的冗余度太大。可以用投影分解的方法消去非平凡且非函数依赖的多值依赖。

事实上，数据依赖中除函数依赖和多值依赖之外，还有其他数据依赖，例如有一种连接依赖。函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。如果消除了属于4NF的关系模式中存在的连接依赖，则可以进一步达到5NF的关系模式。

## （六）规范化小结

规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的分离，它实质上是概念的单一化，类似于设计模式中的单一职责原则。人们认识这个原则是经历了一个过程的，各范式相继提出是这个认识过程逐步深化的标志。

![](关系数据库理论.assets/数据库设计规范过程.jpg)

关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高一级的关系模式，这种分解不是唯一的。

# 三、数据依赖公理系统

数据依赖的公理系统是模式分解算法的理论基础。函数依赖的一个有效而完备的公理系统是Armstrong公理系统。

**定义**：对于满足一组函数依赖F的关系模式R<U,F>，其任何一个关系r，若不存在于F中的函数依赖X→Y都成立（即r中任意两元组t、s，若t[X]=s[X]，则t[Y]=s[Y]），则称F**逻辑蕴涵**X→Y。

Armstrong公理系统（Armstrong’s axiom）设U为属性集总体，F是U上的一组函数依赖，对关系模式R<U,F>来说有以下的推理规则：

- A1 自反律（reflexivity rule），若$Y\subseteq X\subseteq U$，则X→Y为F所蕴涵。由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。
- A2 增广律（augmentation rule），若X→Y为F所蕴涵，且$Z\subseteq U$，则XZ→YZ为F所蕴涵。（XZ表示X∪Z）。
- A3 传递律（transitivity rule），若X→Y及Y→Z为F所蕴涵，则X→Z为F所蕴涵。

根据A1、A2、A3这三条推理规则可以得到下面三条很有用的推理规则。

- 合并规则（union rule），由X→Y，X→Z，有X→YZ。
- 伪传递规则（pseudo transitivity rule），由X→Y，WY→Z，有XW→Z。
- 分解规则（decomposition rule），由X→Y，$Z\subseteq Y$，有X→Z。

根据合并规则和分解规则，得到**引理**：X→A~1~A~2~...A~k~成立的充分必要条件是X→A~i~成立（i=1,2,...k）。

**定义**：在关系模式R<U,F>中为F所逻辑蕴涵的函数依赖的全体，叫作F的**闭包**（closure），记为F^+^。

自反律、传递律和增广律称为Armstrong公理系统，它是有效的、完备的。**有效性**指，由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F^+^中。**完备性**指，F^+^中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。

要证明完备性，就首先要解决如何判定一个函数依赖是否属于由F根据Armstrong公理推导出来的函数依赖的集合。但不幸的是，求这个集合是一个NP完全问题。为此引入了下面的概念：

**定义**：设F为属性集U上的一组函数依赖，$X,Y\subseteq U$，属性集X~F~^+^={A|X→A能由F根据Armstrong公理导出}，X~F~^+^称为属性集X关于函数依赖集F的闭包。如果一个属性的闭包是U，则这个属性是码。

**引理**：设F为属性集U上的一组函数依赖，$X,Y\subseteq U$，X→Y能由F根据Armstrong公理导出的充分必要条件是$Y\subseteq X_F^+$。

于是，判定X→Y是否能由F根据Armstrong公理导出的问题就转化为，求出X~F~^+^，判定Y是否为X~F~^+^的子集的问题。这个问题由下面算法解决，求属性集X（$X\subseteq U$）关于U上的函数依赖集F的闭包X~F~^+^。输入：X、F，输出：X~F~^+^。

1. 令X^(0)^=X，i=0
2. 求$B=\{A|(\exist V)(\exist W)(V\to W\in F\and V\subseteq X^{(i)}\and A\in W)\}$
3. X^(i+1)^=B∪X^(i)^
4. 若X^(i+1)^与X^(i)^相等或者X^(i)^=U，则X^(i)^就是X~F~^+^，算法终止。
5. 否则，i=i+1，返回第2步。

对于上述算法，令a~i~=|X^(i)^|，{a~i~}形成一个步长大于1的严格递增的序列，序列的上界是|U|，因此该算法最多|U|-|X|次循环就会终止。

Armstrong公理系统是有效的、完备的，这两性说明了“导出”和“蕴含”是两个完全等价的概念，于是F^+^也可以说成是由F借助Armstrong公理推导出来的函数依赖集合。

**定义**：如果两个函数依赖集G^+^=F^+^，就说函数依赖集F**覆盖**G（F是G的覆盖，或G是F的覆盖），或F与G等价。

**引理**：等价G^+^=F^+^的充分必要条件是$F^+\subseteq G^+$和$G^+\subseteq F^+$。

**定义**：如果函数依赖集F满足下列条件，则称F为一个极小函数依赖，亦称为**最小依赖集**或**最小覆盖**（minimal cover）。

- F中任一函数依赖的右部仅含有一个属性。
- F中不存在这样的函数依赖X→A，使得F与F - {X→A}等价。
- F中不存在这样的函数依赖X→A，X有真子集Z使得F - {X→A}∪{Z→A}与F等价。该条含义是对于F中的每个函数依赖，它的左部要尽可能简。

**定理**：每一个函数依赖集F均等价于一个极小函数依赖F~m~，此F~m~称为最小依赖集。

# 四、模式的分解

**定义**：关系模式R<U,F>的一个分解是指ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}，其中$U=\stackrel{n}{\bigcup\limits_{i=1}}U_i$，并且没有$U_i\subseteq U_j$，1≤i,j≤n，F~i~是F在U~i~上的投影。

函数依赖集合$\{X\to Y|X\to Y\in F^+\and XY\subseteq U_i\}$的一个覆盖F~i~叫做F在属性U~i~上的投影。

## （一）模式分解的三个定义

要求分解后产生的模式应与原模式等价（起码一个关系被分解后不能丢失原来的信息），从不同的角度，对“等价”的概念形成了三种不同的定义：

1. 分解具有**无损连接**性（lossless join）。
2. 分解要**保持函数依赖**（preserve functional dependency）。
3. 分解既要保持函数依赖，又要具有无损连接性。

这三个定义是实行分解的三条不同准则，按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。

## （二）分解的无损连接性和保持函数依赖性

设ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}是R<U,F>的一个分解，r是R<U,F>的一个关系。定义$m_\rho(r)=\stackrel{k}{\mathop{\Join}\limits_{i=1}}\pi_{R_i}(r)$，即$m_\rho(r)$是r在ρ中各关系模式上投影的连接；这里$\pi_{R_i}(r)=\{t.U_i|t\in r\}$

**引理**：设R<U,F>是一个关系模式，ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}是R的一个分解，r是R的一个关系，$r_i=\pi_{R_i}(r)$，则$r\subseteq m_p(r)$；$\pi_{R_i}(m_p(r))=r_i=\pi_{R_i}(r)$；$m_p(m_p(r))=m_p(r)$。

**定义**：设ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}是R<U,F>的一个分解，若对R<U,F>的任何一个关系r均有$r=m_\rho(r)$成立，则称分解ρ具有无损连接性，简称ρ为无损分解。

直接根据定义是不太可能判断一个分解是不是无损分解，这里给出一个判断分解ρ的无损连接性的算法。ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}是R<U,F>的一个分解，U={A~1~,A~2~,...,A~n~}，F={FD~1~,FD~2~,...,FD~k~}，则：

1. 构造一张k行n列的表（可称为R~ρ~表），其中第i行对应R~i~，第j列对应A~j~，若A~J~∈R~i~，则将表中第i行第j列位置填写符号a~j~，否则填写b~ij~。
2. 根据F中所有函数依赖，对R~ρ~表进行修改。对每一个FD~i~: X→Y，在表中寻找对应于X中所有属性分量之列上符号全相同的行。若能找到，则在这些行的对应于Y中的属性的那些列上置相同的符号：
   - 若其中有一个行之相应列（Y的属性列）上为a~j~，则使其它行同一列上置a~j~；
   - 若相应列上均为b，则使其它行同一列上置某一个b~ij~（可任意，只要相同，一般选择i最小的）。
   - 应该注意的是，如果某个b~ij~被修改，那么该j列中凡是b~ij~的符号都要做相应修改（不论它是否是刚开始找到的那些行）。
   - 如果在某次更改后，有一行称为a~1~,a~2~,...,a~n~，则算法终止，ρ具有无损连接性，否则ρ不具有无损连接性。
3. 在对一个FD进行扫描后，比较扫描前后R~ρ~是否有变化，如果有变化则返回第2步；否则算法终止，分解ρ不具有无损连接性。

**定理**：对于分解为两个模式的ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>}，如果U~1~∩U~2~→U~1~ - U~2~∈F^+^或U~1~∩U~2~→U~2~ - U~1~∈F^+^，则ρ具有无损连接性。

**定义**：已知ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}是R<U,F>的一个分解，若$F^+=\left(\bigcup\limits_{i=1}^kF_i\right)^+$，则称分解ρ保持函数依赖。

## （三）模式分解的算法

关于模式分解的几个重要事实如下，它们由之后的几个算法实现。

- 若仅要分解保持函数依赖，那么模式分解总可以达到3NF，但不一定达到BCNF。
- 若要求分解既保持函数依赖，又具有无损连接性，那么它可以达到，但不一定达到BCNF。
- 若仅要求分解具有无损连接性，那么一定可以达到4NF。

### 1. 转换为3NF的保持函数依赖的分解

1. 对R<U,F>中的函数依赖集F进行极小化处理，去掉之中多余的函数依赖F~0~，处理后得到的依赖集仍记为F。
2. 找出所有不在F中出现的属性（记做U~0~），把这样的属性构成一个关系模式R~0~<U~0~,F~0~>，把这些属性从U中去掉，剩余的属性仍记为U。
3. 若有X→A∈F，且XA=U，则算法终止，ρ={R}。
4. 否则，对F按具有相同左部的原则分组（假定分为k组），每一组函数依赖所涉及的全部属性形成一个属性即U~i~（若$U_i\subseteq U_j\ (i\ne j)$就去掉U~i~，即去掉被其他属性集所包含的）。
5. 由于经历了步骤2，故$U=\bigcup\limits_{i=1}^kU_i$，于是ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}∪R~0~<U~0~,F~0~>构成R的一个保持函数依赖的分解，并且每个R~i~<U~i~,F~i~>均属于3NF，这里F~i~是F在U~i~上的投影，并且F~i~不一定与F~i~'相等，但F~i~'一定被F~i~所包含，因此分解ρ保持函数依赖是显然的。

### 2. 转换为3NF既具有无损连接性又保持函数依赖的分解

1. 设X是R<U,F>的码，R<U,F>已有算法(1)分解为ρ={R~1~<U~1~,F~1~>,R~2~<U~2~,F~2~>,...,R~k~<U~k~,F~k~>}∪R~0~<U~0~,F~0~>，令τ=ρ∪{R^*^<X,F~x~>}。
2. 若有某个U~i~，$X\subseteq U_i$，将R^*^<X,F~x~>从τ中去掉，或$U_i\subseteq X$，将R<U~1~,F~x~>从τ中去掉。
3. τ就是所求的分解。

### 3. 转换为BCNF的无损连接分解

1. 令ρ={R<U,F>}。
2. 检查ρ中各关系是否均属于BCNF，如果是则算法终止。
3. 设ρ中的R~i~<U~i~,F~i~>不属于BCNF，那么必有X→A∈F~i~^+^（$A\notin X$），且X非R~i~的码，因此XA是U~i~的真子集。对R~i~进行分解为σ={S~1~,S~2~}，U~s1~=XA，U~s2~=U~i~ - {A}，以σ代替R~i~<U~i~,F~i~>，返回第2步。

### 4. 达到4NF的具有无损连接性

首先使用算法(3)得到R的一个达到了BCNF的无损连接分解ρ，然后对某一R~i~<U~i~,F~i~>，若不属于4NF，则按下述定理进行分解，直到每一个关系模式均属于4NF为止（平凡的多值依赖）。

**定理**：关系模式R<U,D>中，D为R中函数依赖FD和多值依赖MVD的集合，则X→→Y成立的充要条件是R的分解ρ={R~1~(X,Y),R~2~(X,Z)}具有无损连接性，其中Z=U-X-Y。

# 五、完备的公理系统

关系模式R<U,D>，U是属性总体集，D是U上的一组数据依赖（函数依赖和多值依赖），对于包含函数依赖和多值依赖的数据依赖有一个有效且完备的公理系统。

- A1，若$Y\subseteq X\subseteq U$，则X→Y
- A2，若X→Y且$Z\subseteq U$，则XZ→YZ
- A3，若X→Y，Y→Z，则X→Z
- A4，若X→→Y，$V\subseteq W\subseteq U$，则XW→→YV
- A5，若X→→Y，则X→→U-X-Y
- A6，若X→→Y，Y→→Z，则X→→Z-Y
- A7，若X→Y，则X→→Y
- A8，若X→→Y，W→Z，$W\cap Y=\varnothing,Z\subseteq Y$，则X→Z

公理系统的有效性是从D出发根据8条公理推导出的函数依赖或多值依赖一定为D蕴涵；完备性是指凡D所蕴涵的函数依赖或多值依赖均可以从D根据8条公理系统推导出来。也就是说，在函数依赖和多值依赖的条件下，“蕴涵”与“导出”仍是等价的。

由8条公理可得如下4条有用的推理规则：

- 合并规则，X→→Y，X→→Z，则X→→YZ
- 伪传递规则，X→→Y，WY→Z，则WX→→Z-WY
- 混合伪传递规则，X→→Y，XY→Z，则X→Z-Y
- 分解规则，X→→Y，X→Z，则X→→Y∩Z，X→→Y-Z，X→→Z-Y