[toc]

# 一、概述

## （一）查询处理步骤

1. 查询分析，对查询语句进行扫描、词法分析和语法分析。从查询语句中识别出语言符号，进行语法检查和语法分析，即判断查询语句是否符合SQL语法规则。
2. 查询检查，对合法的查询语句进行语义检查，即根据数据字典中有关的模式定义检查语句中的数据库对象，是否存在和有效；如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作；还要根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。当然，这时的完整性检查是初步的、静态的检查。检查通过后便把SQL查询语句转换成内部表示，即等价的**关系代数表达式**。这个过程中要把数据库对象的外部名称转换为内部表示。关系数据库管理系统一般都用查询树（query tree），也称为语法分析树（syntax tree）来表示扩展的关系代数表达式。
3. 查询优化，每个查询都会有许多可供选择的执行策略和操作算法，查询优化就是选择一个高效执行的查询处理策略。按照优化的层次一般可将查询优化分为代数优化和物理优化。代数优化是指关系代数表达式的优化，即按照一定的规则，通过对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询执行更高效；物理优化则是指存取路径和底层操作算法的选择。
4. 查询执行，依据优化器得到的执行策略生成查询执行计划，由代码生成器（code generator）生成执行这个查询计划的代码，然后加以执行，回送查询结果。

## （二）数据库的三大类操作

- 一次单一元组的一元操作，如选择（SELECTION）、投影（PROJECTION）。迭代器算法（也可用于某些二元操作）。
- 整个关系的一元操作，如去重复（DISTINCT）、分组（GROUP BY）、排序（SORTING）。一趟扫描算法（一张关系从头扫到尾）、二趟扫描算法（一趟扫描的结果存在内存上不够用，把它存在磁盘上，再读出来进行二趟处理）、多趟扫描算法；它们都有基于排序的算法、基于散列的算法、基于索引的算法。
- 整个关系的二元操作，如集合上的并交差、包上的并交差、积（PRODUCT）、连接（JOIN）。

## （三）三个层面进行优化

- 语义优化，利用模型的语义及完整性规则，优化查询。
- 语法优化（逻辑层优化），利用语法结构，优化操作执行顺序。
- 执行优化（物理层优化），存取路径和执行算法的选择与执行次序优化。

# 二、逻辑层的查询优化

## （一）关系代数表达式等价变换规则

关系代数的基本操作，并、差、积、选择、投影。哪些关系代数操作能够交换次序，根据两两组合交换是否等价，判断是否可以交换。用相同的关系代数代替两个表达式中相应的关系所得到的结果是相同的，则称两个关系表达式是等价的，记为$E_1\equiv E_2$。

需要注意的是，下面的这些定律都不是独立使用的，而是需要和其他定律一起考虑。

### 1. 交换律

1. **连接、笛卡尔积的交换律**

设E~1~、E~2~是关系代数表达式，F是连接运算的条件，则有
$$
\begin{align}
& E_1\times E_2\equiv E_2\times E_1 \\
& E_1\Join E_2\equiv E_2\Join E_1 \\
& E_1\mathop{\Join}\limits_{F} E_2\equiv E_2\mathop{\Join}\limits_{F} E_1
\end{align}
$$
考虑哪一个关系最先装到内存中，通常选择结果关系小的表达式先计算。

2. **选择、投影的交换律**

设条件F只涉及属性$\{A_1,A_2,\dots,A_n\}$，E是关系表达式，则有
$$
\Pi_{A_1,A_2,\dots,A_n}(\sigma_{F}(E))\equiv \sigma_{F}(\Pi_{A_1,A_2,\dots,A_n}(E))
$$
若F中有不属于$\{A_1,A_2,\dots,A_n\}$的属性$\{B_1,B_2,\dots,B_m\}$，则更一般的规则
$$
\Pi_{A_1,A_2,\dots,A_n}(\sigma_{F}(E))\equiv \Pi_{A_1,A_2,\dots,A_n}(\sigma_{F}(\Pi_{A_1,A_2,\dots,A_n,_1,B_2,\dots,B_m}(E)))
$$
尽可能的。

3. **选择、笛卡尔积的交换律**

如果F中涉及的属性都是E~1~中的属性，则
$$
\sigma_{F}(E_1\times E_2)\equiv \sigma_{F}(E_1)\times E_2
$$
如果$F=F_1\and F_2$，并且F~1~只涉及E~1~中的属性，F~2~只涉及E~2~中的属性，则由其他的等价变换规则可推出
$$
\sigma_{F}(E_1\times E_2)\equiv \sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)
$$
若F~1~只涉及E~1~的属性，F~2~涉及E~1~、E~2~中的属性，则仍有
$$
\sigma_{F}(E_1\times E_2)\equiv \sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2)
$$
它使部分选择在笛卡尔积前先做，尽可能的把选择操作移动到乘积操作前面。

### 2. 结合律

1. **连接、笛卡尔积的结合律**

设E~1~、E~2~、E~3~是关系代数表达式，F~1~、F~2~是连接运算的条件，则有
$$
\begin{align}
& (E_1\times E_2)\times E_3\equiv E_1\times (E_2\times E_3) \\
& (E_1\Join E_2)\Join E_3\equiv E_1\Join (E_2\Join E_3) \\
& (E_1\mathop{\Join}\limits_{F_1} E_2)\mathop{\Join}\limits_{F_2} E_3\equiv E_1\mathop{\Join}\limits_{F_1} (E_2\mathop{\Join}\limits_{F_2} E_3) \\
\end{align}
$$
考虑哪一个关系最先装到内存中，通常选择结果关系小的表达式先计算。

### 3. 串接定律

1. **投影的串接定律**

设$\{A_1,A_2,\dots,A_n\}\subseteq\{B_1,B_2,\dots,B_m\}$，E是表达式，则
$$
\Pi_{A_1,A_2,\dots,A_n}(\Pi_{B_1,B_2,\dots,B_m}(E))\equiv \Pi_{A_1,A_2,\dots,A_n}(E)
$$
此定律可双向使用。从左向右去掉一些无意义属性，把两边扫描数据库变成一遍扫描数据库；从右向左扩展一些属性，便于投影操作向下（叶子节点）移动。

2. **选择的串接定律**

设E是关系代数表达式，F~1~、F~2~是连接运算的条件，则有
$$
\sigma_{F_1}(\sigma_{F_2}(E))\equiv \sigma_{F_1\and F_2}(E)
$$
此定律可双向使用。从左向右把选择条件结合起来，把两边扫描数据库变成一遍扫描数据库；从右向左分解复杂选择条件，便于选择操作向下（叶子节点）移动。

### 4. 分配律

1. **选择、并的分配律**

设E=E~1~∪E~2~，且E~1~、E~2~有相同的属性名（并相容），则
$$
\sigma_{F}(E_1\cup E_2)\equiv \sigma_{F_1}(E_1)\cup \sigma_{F_2}(E_2)
$$

由左到右，降低中间运算结果。

2. **选择、差的分配律**

设E~1~、E~2~有相同的属性名（并相容），则
$$
\sigma_{F}(E_1-E_2)\equiv \sigma_{F_1}(E_1)-\sigma_{F_2}(E_2)
$$

由左到右，降低中间运算结果。

3. **选择、自然连接的分配律**

如果F只涉及E~1~、E~2~中的公共属性，则
$$
\sigma_{F}(E_1\Join E_2)\equiv \sigma_{F}(E_1)\Join \sigma_{F}(E_2)
$$

4. **投影、并的分配律**

设E~1~、E~2~有相同的属性名（并相容），则
$$
\Pi_{A_1,A_2,\dots,A_n}(E_1\cup E_2)\equiv \Pi_{A_1,A_2,\dots,A_n}(E_1)\cup \Pi_{A_1,A_2,\dots,A_n}(E_2)
$$

投影、差是的分配是不成立的。

5. **投影、笛卡尔积的分配律**

设E~1~、E~2~是关系代数表达式，$A_1,A_2,\dots,A_n$是E~1~的属性，$B_1,B_2,\dots,B_m$是E~2~的属性，则
$$
\Pi_{A_1,A_2,\dots,A_n,B_1,B_2,\dots,B_m}(E_1\times E_2)\equiv \Pi_{A_1,A_2,\dots,A_n}(E_1)\times \Pi_{B_1,B_2,\dots,B_m}(E_2)
$$
做了乘积再做投影，等价于先做投影再做乘积。它能够减少每条记录的长度，从而一个内存块可以存放更多的记录。

## （二）查询树的启发式优化

结点代表操作，边代表操作之间的组合关系和先后顺序。查询树的启发式优化，典型启发式规则有：

- 选择、投影运算尽可能先做。
- 投影运算和选择运算同时进行。
- 把投影和其前或其后的双目运算符结合起来。
- 把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算。
- 执行连接操作前，对关系做适当的处理（如排序、索引等）。
- 找出公共子表达式，一次计算完成，多次使用。

## （三）基于关系代数的查询优化算法

输入：一个关系代数表达式的语法树。输出：计算该表达式的程序。算法：

1. 依据*选择的串接定律*，把复杂的选择表达式分解成串接形式。
2. 对每个选择，依据一系列选择有关的定律，将它尽可能的移到查询树的底部。
3. 对每个投影，依据*投影的串接定律*和一系列投影有关的定律，将它尽可能的移到查询树的底部。如果一个投影是对某表达式所有属性进行的，则去掉之。
4. 利用*选择的串接定律*、*投影的串接定律*、*选择、投影的交换律*，把串接的选择和投影组合为单个选择、单个投影，或者一个选择后跟一个投影。使多个选择或投影能同时执行，或在一次扫描中完成。
5. 对修改后的语法树，将其内的结点按以下方式分组：
   - 每个二元运算结点（积、并、差、连接等）和其所有一元运算直接祖先结点放在一组。
   - 对于其后代结点，若后代结点是一串一元运算且以树叶为终点，则将这些一元运算结点放在该组中。
   - 若该二元运算结点是笛卡儿积，且其后代结点不能和它组合成等连接，则不能将后代结点归入该组。
6. 产生一个程序，它以每组结点为一步，从后代组开始执行。

# 三、物理层的查询优化

利用模式信息和统计信息。

对于选择。全表扫描法（table scan）；索引扫描法（index scan），可以使用散列索引、或B+树索引。使用索引时还应考虑数据量，如果满足条件的数量占表的一大半，则使用索引不见得更好，因为一大半数据几乎接近全部扫描了，使用索引还要查索引跳来跳去。

对于连接。嵌套循环法（nested loop join）、排序合并算法（sort-merge join）、索引连接。

## （一）查询操作的实现

### 1. 选择操作的实现

SELECT语句功能强大，且有很多选项，因此实现的算法和优化策略也很复杂，不失一般性，这里选择简单的选择操作作为典例介绍。

简单的全表扫描算法（tables can)，全表扫描算法只需要很少的内存（最少为1块）就可以运行，而且控制简单。对于规模小的表，这种算法简单有效。对于规模大的表进行顺序扫描，当选择率（即满足条件的元组数占全表的比例）较低时，这个算法效率很低。假设可以使用的内存为M块，全表扫描的算法思想如下：

1. 按照物理次序读表的M块到内存。
2. 检查内存的每个元组t，如果t满足选择条件，则输出t。
3. 如果表还有其他块未被处理，重复上述步骤。

索引扫描算法（index scan），如果选择条件中的属性上有索引（如B+树索引或hash索引），可以用索引扫描方法，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组。

1. 选择条件是`主码=值`查询，可以选择主码索引。
2. 选择条件是`非等值或范围`查询，并且选择列上有索引，可以使用索引扫描方法。
3. 选择条件是`AND`连接的合取，如果都有索引，可以先分别找到两者的一组索引指针，然后求交集；或找到其中一者的一组索引指针，再检查对另一者的条件是否满足，把满足条件的元组输出。

一般情况下，当选择率较低时，基于索引的选择算法要优于全表扫描算法。但在某些情况下，例如选择率较高，或者要查找的元组均匀地分布在查找的表中，这时基于索引的选择算法的性能不如全表扫描算法。因为除了对表的扫描操作，还要加上对B+树索引的扫描操作，对每一个检索码，从树根结点到叶子结点路径上的每个结点都要执行一次IO操作。

### 2. 连接操作的实现

连接操作是查询处理中最常用也是最耗时的操作之一，不失一般性，这里简单介绍等值连接（或自然连接）最常
用的几种算法思想。

嵌套循环算法（nested loop join）最简单可行的算法。对外层循环表的每一个元组，检索内层循环表中的每一个元组，并检查这两个元组在连接属性上是否相等。如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止。在实际实现中数据存取是按照数据块读入内存，而不是按照元组进行IO的。

排序-合并算法（sort-merge join，merge join）是等值连接常用的算法，尤其适合参与连接的诸表己经排好序的情况。用排序-合并连接算法的步骤是：

1. 如果参与连接的表没有排好序，首先对外表和内表按连接属性排序。
2. 取外表中第一个连接属性值，依次扫描内表表中具有相同连接属性值的元组，把它们连接起来。
3. 当扫描到连接属性值不相同的第一个内表元组时，返回外表表扫描它的下一个元组，再扫描内表表中具有相同连接属性值的元组，把它们连接起来。
4. 重复上述步骤直到外表扫描完。这样外表和内表都只要扫描一遍即可。
5. 当然，如果两个表原来无序，执行时间要加上对两个表的排序时间。一般来说，对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少。

索引连接（index join）算法的步骤是：

1. 在内表上己经建立了连接属性的索引。
2. 对外表中每一个元组，由连接属性值通过内表的索引查找相应的内表元组。
3. 把这些内表元组和外表元组连接起来。
4. 循环执行2、3，直到外表表中的元组处理完为止。

hash join算法也是处理等值连接的算法。它把连接属性作为hash码，用同一个hash函数把外表和内表中的元组散列到hash表中。分为两个阶段：

1. 划分阶段（building phase），也称为创建阶段，即创建hash表。对包含较少元组的表进行一遍处理，把它的元组按hash函数（hash码是连接属性）分散到hash表的桶中。
2. 试探阶段（probing phase），也称为连接阶段（join phase），对另一个表进行一遍处理，把表的元组也按同一个hash函数（hash码是连接属性）进行散列，找到适当的hash桶，并把该表元组与桶中来自构建时的表与之相匹配的元组连接起来。

上面的hash join算法假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中。以上的算法思想可以推广到更加一般的多个表的连接算法上。

## （二）基于启发式规则的优化

这里列出了一些主要的启发式规则，在实际的关系数据库管理系统中启发式规则要多得多。

### 1. 选择操作的启发式规则

对于小关系，使用全表顺序扫描，即使选择列上有索引。

对于大关系，启发式规则有：

1. 选择条件是`主码=值`查询，查询结果最多是一个元组，可以选择主码索引。一般的关系数据库管理系统会自动建立主码索引。
2. 选择条件是`非主属性=值`查询，并且选择列上有索引，则要估算查询结果的元组数目，如果比例较小（＜10%）可以使用索引扫描方法，否则还是使用全表顺序扫描。
3. 选择条件是`非等值或范围`查询，并且选择列上有索引，同样要估算查询结果的元组数目，如果选择率＜10%可以使用索引扫描方法，否则还是使用全表顺序扫描。
4. 选择条件是`AND`连接的合取，如果有涉及这些属性的组合索引，则优先采用组合索引扫描方法；如果某些属性上有一般索引，则可采用先索引一个找到满足部分的元组，或都索引求交集等方法，否则使用全表顺序扫描。
5. 选择条件是`OR`连接的析取，一般使用全表顺序扫描。

### 2. 连接操作的启发式规则

1. 如果2个表都已经按照连接属性排序，则选用排序-合并算法。
2. 如果一个表在连接属性上有索引，则可以选用索引连接算法。
3. 如果上面2个规则都不适用，其中一个表较小，则可以选用hash-join算法。
4. 最后可以选用嵌套循环算法，并选择其中较小的表，确切地讲是占用的块数（B）较少的表，作为外表（外循环的表）。

## （三）基于代价估算的优化

这里仅仅列出了少数操作算法的代价估算示例。在实际的关系数据库管理系统中代价估算公式要多得多，也复杂得多。

### 1. 统计信息

基于代价的优化方法要计算各种操作算法的执行代价，它与数据库的状态密切相关。为此在数据字典中存储了优化器需要的统计信息（database statistics），主要包括如下几个方面：

1. 对每个基本表，该表的元组总数（N）、元组长度（l）、占用的块数（B）、占用的溢出块数（BO）。
2. 对基本表的每个列，该列不同值的个数（m）、该列最大值、最小值，该列上是否已经建立了索引，是哪种索引（B+树索引、hash索引、聚集索引）。根据这些统计信息，可以计算出谓词条件的选择率（f），如果不同值的分布是均匀的，则f=1/m；如果不同值的分布不均匀，则要计算每个值的选择率，则f=具有该值的元组数/N。
3. 对索引，例如B+树索引，该索引的层数（L）、不同索引值的个数、索引的选择基数S（有S个元组具有某个索引值）、索引的叶结点数（Y）。
4. 等等。

### 2. 代价估算示例

下面给出若干操作算法的执行代价估算。

全表扫描算法的代价估算公式：

- 如果基本表大小为B块，全表扫描算法的代价cost=B。
- 如果选择条件是“码=值”，那么平均搜索代价cost=B/2。

索引扫描算法的代价估算公式：

- 如果选择条件是“码=值”，若为B+树索引，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1。
- 如果选择条件涉及非码属性，若为B+树索引，选择条件是相等比较，S是索引的选择基数（有S个元组满足条件），因为满足条件的元组可能会保存在不同的块上，所以最坏的情况cost=L+S。如果比较条件是比较操作，假设有一半的元组满足条件，那么就要存取一半的叶结点，并通过索引访问一半的表存储块。所以cost=L+Y/2+B/2。如果可以获得更准确的选择基数，可以进一步修正Y/2与B/2。

嵌套循环连接算法的代价估算公式：

- 嵌套循环连接算法的代价cost=B~r~+B~r~B~s~/(K-1)。如果需要把连接结果写回磁盘，则cost=B~r~+B~r~B~s~/(K-1)+(F~rs~×N~r~×N~s~)/M~rs~。
- 其中F~rs~为连接选择率（join selectivity），表示连接结果元组数的比例，M~rs~是存放连接结果的块因子，表示每块中可以存放的结果元组数目。

排序-合并连接算法的代价估算公式：

- 如果连接表己经按照连接属性排好序，则cost=B~r~+B~s~+(F~rs~×N~r~×N~s~)/M~rs~。
- 如果必须对文件排序，那么还需要在代价函数中加上排序的代价。对于包含B个块的文件排序的代价大约是(2×B)+(2×B×log~2~B)。