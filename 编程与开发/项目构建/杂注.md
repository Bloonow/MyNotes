# universal

单位GB通常表示十进制，即10^3^B，而单位GiB通常表示二进制，即2^30^B。

删除列表元素应倒序遍历，防止发生越界错误。

注意`&&`的短路特性，cond1 && cond2完全等价于if (cond1) { if (cond2) { ... }}，它有时会造成难以预料的错误，如下所示。

```c++
if (ptr != nullptr && ptr->data < x) { /* ... */ }  // Anytimes ok
if (ptr->data < x && ptr != nullptr) { /* ... */ }  // When ptr is nullptr, will cause error
```

现代计算机的一组性能参数，如下所示。

|            资源名            | 反应延时级别（ns） |  ms  |
| :--------------------------: | :----------------: | :--: |
|          L1缓存读取          |        0.5         |  -   |
|          L2缓存读取          |         7          |  -   |
|        Mutex上锁/解锁        |         25         |  -   |
|          主内存读取          |        100         |  -   |
| 以1Gb/s的速率高速传输1KB数据 |    10000（1e4）    | 0.01 |
|   从主内存线性读取1MB数据    |   2500（2.5e4）    | 0.25 |
|   同一个数据中心的通信速度   |   500000（5e5）    | 0.5  |
|     从SSD线性读取1MB数据     |   1000000（1e6）   | 1ms  |
|   从硬盘线性读取1MB的数据    |  20000000（2e7）   | 20ms |

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。这样的存储模式有点类似于把数据当作字符串顺序处理，地址由小向大增加，数据从高位往低位放，这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

# 正则表达式介绍

## （一）串和语言

字母表（alphabet）是一个有限的符号集合，常用Σ表示，ASCII是字母表的一个重要的例子。某个字母表上的一个串（string）是该字母表中符号的一个有穷序列，串s的长度记为|s|，是指s中符号出现的次数。空串（empty string）是指长度为0的串，用ε表示。语言（language）是某个给定字母表上一个任意的可数的串的集合。

跟串有关的术语有：前缀（prefix）、后缀（suffix）、子串（substring）、真前缀、真后缀、真子串、子序列。其中子序列是从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻。

如果x和y是串，那么x和y的连接（connection）是把y附加到x后面形成的串，即xy。空串是连接运算的单位元，也就是说，对于任何串ε都有，sε=εs=s。

如果把两个串的连接看成是这两个串的“乘积”，那么可以定义串的幂运算如下，定义s^0^=ε，并且对于i>0，s^i^=s^i-1^s。因为εs=s，由此可知s^1^=s，s^2^=ss，s^3^=sss，依此类推。

## （二）语言上的运算

语言上的运算可分为并、连接和闭包运算；并就是常见的集合运算，连接就是两个集合做笛卡尔积。

一个语言L的Kleene闭包（closure），记为L^*^，就是将L连接0次或多次后得到的串的集合。注意L^0^，即“将L连接0次得到的集合”，被定义为{ε}，并且L^i^被归纳地定义为L^i-1^L，即L^*^={ε}∪L^1^∪L^2^∪...。最后，L的正闭包（记为L^+^）和Kleene闭包基本相同，但不包含L^0^。也就是说，除非ε属于L，否则ε不属于L^+^。

上面介绍的这些运算如下表所示。

|     运算      |         定义和表示          |
| :-----------: | :-------------------------: |
|   L和M的并    |   L∪M={s\|s属于L或s属于M}   |
|  L和M的连接   |   LM={st\|s属于L且t属于M}   |
| L的Kleene闭包 | $L^*=\cup_{i=0}^\infty L^i$ |
|   L的正闭包   | $L^+=\cup_{i=1}^\infty L^i$ |

## （三）正则表达式

正则表达式可以由较小的正则表达式按照如下规则递归的构建。每个正则表达式r表示一个语言L(r)，这个语言也是根据r的子表达式所表示的语言递归地定义的。下面的规则定义了某个字母表Σ上的正则表达式以及这些表达式所表示的语言。

归纳基础，下面的两个规则构成了归纳基础：

1. ε是一个正则表达式，L(ε)={ε}，即该语言只包含空串。
2. 如果符号*a*是Σ上的一个符号，那么a是一个正则表达式，并且L(a)={*a*}。也就是说，这个语言仅包含一个长度为1的符号串*a*。

归纳步骤，由小的正则表达式构造较大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：

1. (r)|(s)是一个正则表达式，表示语言L(r)∪L(s)。
2. (r)(s)是一个正则表达式，表示语言L(r)L(s)。
3. (r)^*^是一个正则表达式，表示语言(L(r))^*^。
4. (r)是一个正则表达式，表示语言L(r)。最后这个规则是说在表达式的两边加上括号并不影响表达式所表示的语言。

按照上面的定义，正则表达式经常会包含一些不必要的括号，可以采用以下的约定，就可以丢掉一些不必要的括号：

1. 一元运算符*具有最高的优先级，并且是左结合的。
2. 连接具有次高的优先级，它也是左结合的。
3. |的优先级最低，并且也是左结合的。

可以用一个正则表达式定义的语言叫做正则集合（regular set），如果两个正则表达式r和s表示同样的语言，则称r和s等价（equivalent），记作r=s。

下面给出了一些对于任意正则表达式r、s、t都成立的代数定律。

|               定律                |        描述        |
| :-------------------------------: | :----------------: |
|             r\|s=s\|r             |   \|是可以交换的   |
|        r\|(s\|t)=(r\|s)\|t        |   \|是可以结合的   |
|            r(st)=(rs)t            |   连接是可结合的   |
|  r(s\|t)=rs\|rt  (s\|t)r=sr\|tr   | 连接对\|是可分配的 |
|              εr=rε=r              |  ε是连接的单位元   |
| r^*^=(r\|ε)^*^=ε\|r\|rr\|rrr\|... |  闭包中一定含有ε   |
|            r^**^=r^*^             |    *具有幂等性     |

## （四）正则定义

为方便表示，我们希望给某些常用的正则表达式命名，并在之后的正则表达式中像使用符号一样使用这些名字。如果Σ是基本符号的集合，那么一个正则定义（regular definition）是具有如下形式的定义序列：
$$
d_1\to r_1\\
d_2\to r_2\\
\dots\\
d_n\to r_n
$$
其中，每个d~i~都是一个新符号，它们都不再Σ中，并且各不相同；每个r~i~是字母表Σ∪{d~1~,d~2~,...,d~i-1~}上的正则表达式。显然，我们限制了每个r~i~中只含有Σ中的符号和在它之前定义的各个d~j~，因此避免了递归定义的问题，并且我们可以为每个r~i~构造出只包含Σ中符号的正则表达式。

从上面可知，正则定义避免了递归定义，因为它最终要展开为由基本符号组成的表达式，如果其中包含递归，则无法展开。同时也正因如此，正则表达式不能用来描述递归结构，如算数表的式、if语句等，因为它们都是典型的递归结构。

## （五）正则表达式的扩展

自从Kleene在20世纪50年代提出了带有基本运算符并、连接和Kleene闭包的正则表达式之后，已经出现过很多种针对正则表达式的扩展，这里介绍一些最早出现在像Lex这样的Unix实用程序中的扩展表示法。

1. 一个或多个实例。单目后缀运算符`+`表示一个正则表达式及其语言的正闭包。也就是说，如果r是一个正则表达式，那么(r)^+^就表示语言(L(r))^+^。运算符+和\*具有同样的优先级和结合性。两个有用的代数定律r^*^=r^+^|ε和r^+^=rr^*^=r^*^r说明了Kleene闭包和正闭包之间的关系。
2. 零个或一个实例。单目运算符`?`的意思是“零个或一个出现”，也就是说r?等价于r|ε，换句话说，L(r?)=L(r)∪{ε}。运算符?与运算符+和运算符*具有同样的优先级和结合性。
3. 字符类。一个正则表达式a~1~|a~2~|...|a~n~（其中a~i~是字母表中各个符号）可以缩写为[a~1~a~2~...a~n~]。更重要的是，当a~1~,a~2~,...,a~n~形成一个连续的序列时，比如连续的大写字母、小写字母或数字时，可以把它们表示成[a~1~-a~n~]，也就是说只写出第一个和最后一个字符，中间用连词符连接。

可以看到，上面所述的3种扩展，已经和当前所使用的正则表达式语法非常相近了。更为详细的ECMAScript正则表达式语法，可以参看《C++高级编程》，这里就不再赘述了。