# universal

单位GB通常表示十进制，即10^3^B，而单位GiB通常表示二进制，即2^30^B。

删除列表元素应倒序遍历，防止发生越界错误。

注意`&&`的短路特性，cond1 && cond2完全等价于if (cond1) { if (cond2) { ... }}，它有时会造成难以预料的错误，如下所示。

```c++
if (ptr != nullptr && ptr->data < x) { /* ... */ }  // Anytimes ok
if (ptr->data < x && ptr != nullptr) { /* ... */ }  // When ptr is nullptr, will cause error
```

现代计算机的一组性能参数，如下所示。

|            资源名            | 反应延时级别（ns） |  ms  |
| :--------------------------: | :----------------: | :--: |
|          L1缓存读取          |        0.5         |  -   |
|          L2缓存读取          |         7          |  -   |
|        Mutex上锁/解锁        |         25         |  -   |
|          主内存读取          |        100         |  -   |
| 以1Gb/s的速率高速传输1KB数据 |    10000（1e4）    | 0.01 |
|   从主内存线性读取1MB数据    |   2500（2.5e4）    | 0.25 |
|   同一个数据中心的通信速度   |   500000（5e5）    | 0.5  |
|     从SSD线性读取1MB数据     |   1000000（1e6）   | 1ms  |
|   从硬盘线性读取1MB的数据    |  20000000（2e7）   | 20ms |

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。这样的存储模式有点类似于把数据当作字符串顺序处理，地址由小向大增加，数据从高位往低位放，这与人类的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

# 计算机中的维度

人类在认识世界的过程中，发现宇宙是多维的，因此人类使用多维对象（Multiple Dimension Object）的概念描述物质世界。以下对一些概念进行规范。

| 概念   | 英文   | 描述                                                         | 备注                                                         |
| ------ | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 维度轴 | Axis   | 多维对象的若干维度的其中之一                                 | 三维空间通常使用X维、Y轴、Z轴进行表示                        |
| 维度   | Rank   | 多维对象的维度轴的数目                                       | 三维空间具有三个维度轴，其维度是3                            |
| 维数   | Extent | 多维对象在某个维度轴之上的元素数目                           | 当某个维度轴是离散的且有限时，该维度轴之上的元素数目称为维数 |
| 形状   | Shape  | 多维对象在各个维度轴之上的维数                               | 对R维对象而言，其形状可以由Shape{D1,D2,...,DR}描述           |
| 索引   | Index  | 用于在多维对象中进行标识的坐标，以访问特定位置的元素         | 对R维对象应用R维索引，得到一个标量元素；<br/>对R维对象应用K维索引，得到一个张量元素，即一个R-K维对象 |
| 切片   | Slice  | 用于在多维对象中进行标识的坐标范围，以访问特定位置范围的元素 | 对R维对象应用切片，得到的仍然是R维对象，只不过是R维对象的部分范围的元素 |

在计算机科学中，由于冯诺依曼架构，尽管存储器SDRAM芯片包含多个Bank存储体，且在访存时采用行列地址线复用技术，但存储控制单元（Memory Control Uint，MCU）在对存储单元进行编址时，是以一维线性连续的方式对存储单元进行编址的，并为每个字节指定一个地址。即，计算机上层软硬件所访问的地址空间，实际上是一维的。于是，在存储逻辑上的多维对象时，实际上是将多维对象中的所有元素，以一维线性连续的方式存储在一维线性连续的实际内存当中的。以下对一些概念进行规范。

| 概念     | 英文           | 描述                                                         | 备注                                                         |
| -------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 多维数组 | Multi Array    | 具有多个维度的数组                                           | 最左侧维度称为第一维度，最右侧维度称为最后维度；<br/>二维数组Array{M,N}通常描述为M行N列 |
| 多维索引 | Multi Index    | 用于在多维数组中进行标识的坐标                               | 对R维数组应用K维索引，得到一个R-K维数组                      |
| 首地址   | Head Address   | 多维数组在存储时，第一个元素的存储地址                       | 第一个元素是指多维索引都取第一个的元素                       |
| 偏移     | Offset         | 多维数组的某个元素的存储位置，<br/>与第一个元素的存储位置之间的差距 | 是一个标量值，如何计算偏移与元素的存储布局有关               |
| 布局     | Layout         | 用于将元素索引转换为偏移值的映射                             | 是一种映射计算，用于将多维索引转换为一维偏移值，<br/>描述元素在内存中的排布组织方式，反映元素在一维内存中的实际存储方式 |
| 存储顺序 | Storage Order  | 指定多个维度轴存储时的先后顺序                               | 先存储最左侧维度是列主序（Column-Major），先存储最右侧维度时行主序（Row-Major）；<br/>对于二维数组Array{M,N}，先存储M轴是列主序，先存储N轴是行主序 |
| 跨步     | Stride         | 两个相应元素的存储位置之间的差距                             | 两个相邻元素连续存储时，其跨步为1，若跨步大于1，则相邻元素的存储位置不连续；<br/>以列主序存储无填充的三维数组Array{D1,D2,D3}，其跨步为Stride(1,D1,D1\*D2) |
| 前导维度 | Leading Rank   | 先进行存储的维度轴                                           | 或称为主维度，在逻辑上，具有若干个有效元素                   |
| 前导维数 | Leading Extent | 先进行存储的维度轴之上的元素数目                             | 或称为主维数，主维度之上的有效元素数目，与跨步带来的填充元素数目，之和称为主维数 |

> 有时，将最左侧维度轴称为最低维度，将最右侧维度轴称为最高维度，但此描述因人而异，为避免歧义应尽量避免使用。
>
> 有时，将元素连续存储的维度轴称为最内层维度，将元素最不连续存储的维度轴称为最外层维度，但此描述因人而异，为避免歧义应尽量避免使用。

# 托管内存

在C#编程语言所开发的应用程序中，所使用的内存称为托管内存（managed memory）；当C#程序运行时，会向操作系统申请一块专用内存，即托管内存。在C#语言开发的程序中，所声明的变量，不论是常量还是变量，都位于托管内存。C#的托管内存，是具有自身管理功能的，并使用垃圾回收器（GC）工具，判断程序所声明的内存是否仍在使用，来实现对托管内存的管理。

C#程序所使用的内存，都叫托管内存，而C#程序不使用的内存，即是非托管内存。其它许多语言并没有托管内存的概念，例如C++语言，没有专门的内存管理机制。所以，在C#程序和其它语言开发的程序进行交互时，或使用C#进行混合开发时，需要使用C#语言访问非托管内存。

# 正则表达式介绍

## （一）串和语言

字母表（alphabet）是一个有限的符号集合，常用Σ表示，ASCII是字母表的一个重要的例子。某个字母表上的一个串（string）是该字母表中符号的一个有穷序列，串s的长度记为|s|，是指s中符号出现的次数。空串（empty string）是指长度为0的串，用ε表示。语言（language）是某个给定字母表上一个任意的可数的串的集合。

跟串有关的术语有：前缀（prefix）、后缀（suffix）、子串（substring）、真前缀、真后缀、真子串、子序列。其中子序列是从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻。

如果x和y是串，那么x和y的连接（connection）是把y附加到x后面形成的串，即xy。空串是连接运算的单位元，也就是说，对于任何串ε都有，sε=εs=s。

如果把两个串的连接看成是这两个串的“乘积”，那么可以定义串的幂运算如下，定义s^0^=ε，并且对于i>0，s^i^=s^i-1^s。因为εs=s，由此可知s^1^=s，s^2^=ss，s^3^=sss，依此类推。

## （二）语言上的运算

语言上的运算可分为并、连接和闭包运算；并就是常见的集合运算，连接就是两个集合做笛卡尔积。

一个语言L的Kleene闭包（closure），记为L^*^，就是将L连接0次或多次后得到的串的集合。注意L^0^，即“将L连接0次得到的集合”，被定义为{ε}，并且L^i^被归纳地定义为L^i-1^L，即L^*^={ε}∪L^1^∪L^2^∪...。最后，L的正闭包（记为L^+^）和Kleene闭包基本相同，但不包含L^0^。也就是说，除非ε属于L，否则ε不属于L^+^。

上面介绍的这些运算如下表所示。

|     运算      |         定义和表示          |
| :-----------: | :-------------------------: |
|   L和M的并    |   L∪M={s\|s属于L或s属于M}   |
|  L和M的连接   |   LM={st\|s属于L且t属于M}   |
| L的Kleene闭包 | $L^*=\cup_{i=0}^\infty L^i$ |
|   L的正闭包   | $L^+=\cup_{i=1}^\infty L^i$ |

## （三）正则表达式

正则表达式可以由较小的正则表达式按照如下规则递归的构建。每个正则表达式r表示一个语言L(r)，这个语言也是根据r的子表达式所表示的语言递归地定义的。下面的规则定义了某个字母表Σ上的正则表达式以及这些表达式所表示的语言。

归纳基础，下面的两个规则构成了归纳基础：

1. ε是一个正则表达式，L(ε)={ε}，即该语言只包含空串。
2. 如果符号*a*是Σ上的一个符号，那么a是一个正则表达式，并且L(a)={*a*}。也就是说，这个语言仅包含一个长度为1的符号串*a*。

归纳步骤，由小的正则表达式构造较大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：

1. (r)|(s)是一个正则表达式，表示语言L(r)∪L(s)。
2. (r)(s)是一个正则表达式，表示语言L(r)L(s)。
3. (r)^*^是一个正则表达式，表示语言(L(r))^*^。
4. (r)是一个正则表达式，表示语言L(r)。最后这个规则是说在表达式的两边加上括号并不影响表达式所表示的语言。

按照上面的定义，正则表达式经常会包含一些不必要的括号，可以采用以下的约定，就可以丢掉一些不必要的括号：

1. 一元运算符*具有最高的优先级，并且是左结合的。
2. 连接具有次高的优先级，它也是左结合的。
3. |的优先级最低，并且也是左结合的。

可以用一个正则表达式定义的语言叫做正则集合（regular set），如果两个正则表达式r和s表示同样的语言，则称r和s等价（equivalent），记作r=s。

下面给出了一些对于任意正则表达式r、s、t都成立的代数定律。

|               定律                |        描述        |
| :-------------------------------: | :----------------: |
|             r\|s=s\|r             |   \|是可以交换的   |
|        r\|(s\|t)=(r\|s)\|t        |   \|是可以结合的   |
|            r(st)=(rs)t            |   连接是可结合的   |
|  r(s\|t)=rs\|rt  (s\|t)r=sr\|tr   | 连接对\|是可分配的 |
|              εr=rε=r              |  ε是连接的单位元   |
| r^*^=(r\|ε)^*^=ε\|r\|rr\|rrr\|... |  闭包中一定含有ε   |
|            r^**^=r^*^             |    *具有幂等性     |

## （四）正则定义

为方便表示，我们希望给某些常用的正则表达式命名，并在之后的正则表达式中像使用符号一样使用这些名字。如果Σ是基本符号的集合，那么一个正则定义（regular definition）是具有如下形式的定义序列：
$$
d_1\to r_1\\
d_2\to r_2\\
\dots\\
d_n\to r_n
$$
其中，每个d~i~都是一个新符号，它们都不再Σ中，并且各不相同；每个r~i~是字母表Σ∪{d~1~,d~2~,...,d~i-1~}上的正则表达式。显然，我们限制了每个r~i~中只含有Σ中的符号和在它之前定义的各个d~j~，因此避免了递归定义的问题，并且我们可以为每个r~i~构造出只包含Σ中符号的正则表达式。

从上面可知，正则定义避免了递归定义，因为它最终要展开为由基本符号组成的表达式，如果其中包含递归，则无法展开。同时也正因如此，正则表达式不能用来描述递归结构，如算数表的式、if语句等，因为它们都是典型的递归结构。

## （五）正则表达式的扩展

自从Kleene在20世纪50年代提出了带有基本运算符并、连接和Kleene闭包的正则表达式之后，已经出现过很多种针对正则表达式的扩展，这里介绍一些最早出现在像Lex这样的Unix实用程序中的扩展表示法。

1. 一个或多个实例。单目后缀运算符`+`表示一个正则表达式及其语言的正闭包。也就是说，如果r是一个正则表达式，那么(r)^+^就表示语言(L(r))^+^。运算符+和\*具有同样的优先级和结合性。两个有用的代数定律r^*^=r^+^|ε和r^+^=rr^*^=r^*^r说明了Kleene闭包和正闭包之间的关系。
2. 零个或一个实例。单目运算符`?`的意思是“零个或一个出现”，也就是说r?等价于r|ε，换句话说，L(r?)=L(r)∪{ε}。运算符?与运算符+和运算符*具有同样的优先级和结合性。
3. 字符类。一个正则表达式a~1~|a~2~|...|a~n~（其中a~i~是字母表中各个符号）可以缩写为[a~1~a~2~...a~n~]。更重要的是，当a~1~,a~2~,...,a~n~形成一个连续的序列时，比如连续的大写字母、小写字母或数字时，可以把它们表示成[a~1~-a~n~]，也就是说只写出第一个和最后一个字符，中间用连词符连接。

可以看到，上面所述的3种扩展，已经和当前所使用的正则表达式语法非常相近了。更为详细的ECMAScript正则表达式语法，可以参看《C++高级编程》，这里就不再赘述了。