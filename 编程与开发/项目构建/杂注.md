# universal

单位GB通常表示十进制，即10^3^B，而单位GiB通常表示二进制，即2^30^B。

删除列表元素应倒序遍历，防止发生越界错误。

注意`&&`的短路特性，cond1 && cond2完全等价于if (cond1) { if (cond2) { ... }}，它有时会造成难以预料的错误，如下所示。

```c++
if (ptr != nullptr && ptr->data < x) { /* ... */ }  // Anytimes ok
if (ptr->data < x && ptr != nullptr) { /* ... */ }  // When ptr is nullptr, will cause error
```

现代计算机的一组性能参数，如下所示。

|            资源名            | 反应延时级别（ns） |  ms  |
| :--------------------------: | :----------------: | :--: |
|          L1缓存读取          |        0.5         |  -   |
|          L2缓存读取          |         7          |  -   |
|        Mutex上锁/解锁        |         25         |  -   |
|          主内存读取          |        100         |  -   |
| 以1Gb/s的速率高速传输1KB数据 |    10000（1e4）    | 0.01 |
|   从主内存线性读取1MB数据    |   2500（2.5e4）    | 0.25 |
|   同一个数据中心的通信速度   |   500000（5e5）    | 0.5  |
|     从SSD线性读取1MB数据     |   1000000（1e6）   | 1ms  |
|   从硬盘线性读取1MB的数据    |  20000000（2e7）   | 20ms |

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。这样的存储模式有点类似于把数据当作字符串顺序处理，地址由小向大增加，数据从高位往低位放，这与人类的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

# 维度、维数、多维数组

维度，指的是维度轴的数目。例如，三维空间指的是具有三个维度轴的空间。

维数，指的是在某个维度轴上元素的数目。例如，维数为D指的是在某个维度轴上具有D个元素。

索引，指的是在某个维度轴上，以给定值作为依据，来访问该维度轴上的特定元素。按照人类的表示习惯，以方括号[]或圆括号()指定索引。例如，以切片形式[0:N-1]表示维度轴上给定范围的元素，表示从索引0到索引N-1的共计N个元素，包含两侧索引位置。

> 需要注意的是，不同的编程语言，使用的索引范围有所不同。

多维数组，指的是具有多个维度轴的数组。按照人类的阅读习惯，用符号表示一个数组时，将最左侧的维度轴称为第一个维度轴，将最右侧的维度轴称为最后一个维度轴。例如，四维数组可以表示为Array[N1,N2,N3,N4]的形式。按照人类的阅读习惯，会将二维数组Array[M,N]描述为M行N列。

多维数组索引，在多维数组的一个维度轴上进行索引，其结果可能仍是一个多维数组。例如，对N维数组在某个维度轴上进行索引，得到N-1维数组。

在计算机的存储器内存中，多维数组本质上是按照一维数组的方式连续存储的，不同的概念指定数组元素在内存中不同的存储方式。

存储顺序，指的是先存储哪一个维度轴上的元素，而先存储的维度轴上的元素在内存中通常是连续的。因为按照人类的阅读习惯，会将二维数组Array[M,N]描述为M行N列，故将先存储最左侧维度轴上元素的方式称为列主序（Column-Major）存储，将先存储最右侧维度轴上元素的方式称为行主序（Row-Major）存储。例如，在存储四维数组Array[N1,N2,N3,N4]时，若先存储N1维度轴的元素，再依次向右存储各个维度轴，则称为列主序存储；若先存储N4维度轴的元素，再依次向左存储各个维度轴，则称为行主序存储。

先存储的元素连续的维度轴，称为前导（leading）维度，或称为主维度，该维度轴上的维数，与可能存在的填充元素数目，一起称为前导维数，或称为主维数。即，在存储元素时存在填充时，则前导维数等于前导维度轴上有效元素数目与填充元素数目之和，表示在内存中实际需要存储的元素数目。

跨步，指的是在存储某个维度轴上的元素时，两个相邻元素的存储位置之间的差距，也即元素索引增加时，其存储位置在内存中跨过的距离。对于主维度轴来说，其元素在内存中连续存储时，元素跨步为1，若跨步值大于1，则表示相邻元素之间的存储位置不连续。例如，在以行主序的方式存储四维数组Array[N1,N2,N3,N4]时，其各个维度对应的跨步值为Stride(N2\*N3\*N4, N3\*N4, N4, 1)。

> 有时，将最左侧维度轴称为最低维度，将最右侧维度轴称为最高维度，但此描述因人而异，为避免歧义应尽量避免。
>
> 有时，将元素连续存储的维度轴称为最内层维度，将元素最不连续存储的维度轴称为最外层维度，但此描述因人而异，为避免歧义应尽量避免。

# 托管内存

在C#编程语言所开发的应用程序中，所使用的内存称为托管内存（managed memory）；当C#程序运行时，会向操作系统申请一块专用内存，即托管内存。在C#语言开发的程序中，所声明的变量，不论是常量还是变量，都位于托管内存。C#的托管内存，是具有自身管理功能的，并使用垃圾回收器（GC）工具，判断程序所声明的内存是否仍在使用，来实现对托管内存的管理。

C#程序所使用的内存，都叫托管内存，而C#程序不使用的内存，即是非托管内存。其它许多语言并没有托管内存的概念，例如C++语言，没有专门的内存管理机制。所以，在C#程序和其它语言开发的程序进行交互时，或使用C#进行混合开发时，需要使用C#语言访问非托管内存。

# 正则表达式介绍

## （一）串和语言

字母表（alphabet）是一个有限的符号集合，常用Σ表示，ASCII是字母表的一个重要的例子。某个字母表上的一个串（string）是该字母表中符号的一个有穷序列，串s的长度记为|s|，是指s中符号出现的次数。空串（empty string）是指长度为0的串，用ε表示。语言（language）是某个给定字母表上一个任意的可数的串的集合。

跟串有关的术语有：前缀（prefix）、后缀（suffix）、子串（substring）、真前缀、真后缀、真子串、子序列。其中子序列是从s中删除0个或多个符号后得到的串，这些被删除的符号可能不相邻。

如果x和y是串，那么x和y的连接（connection）是把y附加到x后面形成的串，即xy。空串是连接运算的单位元，也就是说，对于任何串ε都有，sε=εs=s。

如果把两个串的连接看成是这两个串的“乘积”，那么可以定义串的幂运算如下，定义s^0^=ε，并且对于i>0，s^i^=s^i-1^s。因为εs=s，由此可知s^1^=s，s^2^=ss，s^3^=sss，依此类推。

## （二）语言上的运算

语言上的运算可分为并、连接和闭包运算；并就是常见的集合运算，连接就是两个集合做笛卡尔积。

一个语言L的Kleene闭包（closure），记为L^*^，就是将L连接0次或多次后得到的串的集合。注意L^0^，即“将L连接0次得到的集合”，被定义为{ε}，并且L^i^被归纳地定义为L^i-1^L，即L^*^={ε}∪L^1^∪L^2^∪...。最后，L的正闭包（记为L^+^）和Kleene闭包基本相同，但不包含L^0^。也就是说，除非ε属于L，否则ε不属于L^+^。

上面介绍的这些运算如下表所示。

|     运算      |         定义和表示          |
| :-----------: | :-------------------------: |
|   L和M的并    |   L∪M={s\|s属于L或s属于M}   |
|  L和M的连接   |   LM={st\|s属于L且t属于M}   |
| L的Kleene闭包 | $L^*=\cup_{i=0}^\infty L^i$ |
|   L的正闭包   | $L^+=\cup_{i=1}^\infty L^i$ |

## （三）正则表达式

正则表达式可以由较小的正则表达式按照如下规则递归的构建。每个正则表达式r表示一个语言L(r)，这个语言也是根据r的子表达式所表示的语言递归地定义的。下面的规则定义了某个字母表Σ上的正则表达式以及这些表达式所表示的语言。

归纳基础，下面的两个规则构成了归纳基础：

1. ε是一个正则表达式，L(ε)={ε}，即该语言只包含空串。
2. 如果符号*a*是Σ上的一个符号，那么a是一个正则表达式，并且L(a)={*a*}。也就是说，这个语言仅包含一个长度为1的符号串*a*。

归纳步骤，由小的正则表达式构造较大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：

1. (r)|(s)是一个正则表达式，表示语言L(r)∪L(s)。
2. (r)(s)是一个正则表达式，表示语言L(r)L(s)。
3. (r)^*^是一个正则表达式，表示语言(L(r))^*^。
4. (r)是一个正则表达式，表示语言L(r)。最后这个规则是说在表达式的两边加上括号并不影响表达式所表示的语言。

按照上面的定义，正则表达式经常会包含一些不必要的括号，可以采用以下的约定，就可以丢掉一些不必要的括号：

1. 一元运算符*具有最高的优先级，并且是左结合的。
2. 连接具有次高的优先级，它也是左结合的。
3. |的优先级最低，并且也是左结合的。

可以用一个正则表达式定义的语言叫做正则集合（regular set），如果两个正则表达式r和s表示同样的语言，则称r和s等价（equivalent），记作r=s。

下面给出了一些对于任意正则表达式r、s、t都成立的代数定律。

|               定律                |        描述        |
| :-------------------------------: | :----------------: |
|             r\|s=s\|r             |   \|是可以交换的   |
|        r\|(s\|t)=(r\|s)\|t        |   \|是可以结合的   |
|            r(st)=(rs)t            |   连接是可结合的   |
|  r(s\|t)=rs\|rt  (s\|t)r=sr\|tr   | 连接对\|是可分配的 |
|              εr=rε=r              |  ε是连接的单位元   |
| r^*^=(r\|ε)^*^=ε\|r\|rr\|rrr\|... |  闭包中一定含有ε   |
|            r^**^=r^*^             |    *具有幂等性     |

## （四）正则定义

为方便表示，我们希望给某些常用的正则表达式命名，并在之后的正则表达式中像使用符号一样使用这些名字。如果Σ是基本符号的集合，那么一个正则定义（regular definition）是具有如下形式的定义序列：
$$
d_1\to r_1\\
d_2\to r_2\\
\dots\\
d_n\to r_n
$$
其中，每个d~i~都是一个新符号，它们都不再Σ中，并且各不相同；每个r~i~是字母表Σ∪{d~1~,d~2~,...,d~i-1~}上的正则表达式。显然，我们限制了每个r~i~中只含有Σ中的符号和在它之前定义的各个d~j~，因此避免了递归定义的问题，并且我们可以为每个r~i~构造出只包含Σ中符号的正则表达式。

从上面可知，正则定义避免了递归定义，因为它最终要展开为由基本符号组成的表达式，如果其中包含递归，则无法展开。同时也正因如此，正则表达式不能用来描述递归结构，如算数表的式、if语句等，因为它们都是典型的递归结构。

## （五）正则表达式的扩展

自从Kleene在20世纪50年代提出了带有基本运算符并、连接和Kleene闭包的正则表达式之后，已经出现过很多种针对正则表达式的扩展，这里介绍一些最早出现在像Lex这样的Unix实用程序中的扩展表示法。

1. 一个或多个实例。单目后缀运算符`+`表示一个正则表达式及其语言的正闭包。也就是说，如果r是一个正则表达式，那么(r)^+^就表示语言(L(r))^+^。运算符+和\*具有同样的优先级和结合性。两个有用的代数定律r^*^=r^+^|ε和r^+^=rr^*^=r^*^r说明了Kleene闭包和正闭包之间的关系。
2. 零个或一个实例。单目运算符`?`的意思是“零个或一个出现”，也就是说r?等价于r|ε，换句话说，L(r?)=L(r)∪{ε}。运算符?与运算符+和运算符*具有同样的优先级和结合性。
3. 字符类。一个正则表达式a~1~|a~2~|...|a~n~（其中a~i~是字母表中各个符号）可以缩写为[a~1~a~2~...a~n~]。更重要的是，当a~1~,a~2~,...,a~n~形成一个连续的序列时，比如连续的大写字母、小写字母或数字时，可以把它们表示成[a~1~-a~n~]，也就是说只写出第一个和最后一个字符，中间用连词符连接。

可以看到，上面所述的3种扩展，已经和当前所使用的正则表达式语法非常相近了。更为详细的ECMAScript正则表达式语法，可以参看《C++高级编程》，这里就不再赘述了。